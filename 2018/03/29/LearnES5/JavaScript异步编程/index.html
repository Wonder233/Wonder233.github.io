<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>JavaScript异步编程 | Wonder233&#39;s Blog</title>
  <meta name="author" content="Wonder">
  
  <meta name="description" content="努力努力再努力">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="JavaScript异步编程"/>
  <meta property="og:site_name" content="Wonder233&#39;s Blog"/>

  
    <meta property="og:image" content=""/>
  

  
    <link rel="alternative" href="/atom.xml" title="Wonder233&#39;s Blog" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">  
  <link rel="stylesheet" href="/css/sidenav.css" media="screen" type="text/css">  
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  

</head>

<body id="body" data-spy="scroll" data-target=".toc">
  <div class="container" id="container">
	<div class="content">
	  <div class="page-header">		
  <h1><a class="brand" href="/">Wonder233&#39;s Blog</a><span class="split"></span><span class="title">JavaScript异步编程</span><span class="date" id="title-date"><i class="fa fa-clock-o"></i> 2018-03-29</span></h1>
</div>		

<div class="row page">
  <!-- cols -->	
  
  <div class="col-xs-12 col-sm-3 col-md-3 toc"> 
	<!-- toc -->
<script type="text/javascript">
		jQuery(document).ready(function() {
 		   generateWikiTOC('.note', '.toc',  2 , 2 );
		});
</script>
  </div><!-- col-md-3 -->
  
  

  
  <div class="col-xs-12 col-sm-9 col-md-9 note">
	

	  <!-- content -->
	  <h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><ol>
<li>JavaScript语言执行环境是单线程的，单线程在程序执行时，所走的程序路径按照连续顺序排下来，前面的必须处理好，后面的才会执行。</li>
<li>在某个特定的时刻只有特定的代码能够被执行，且会阻塞其它的代码。</li>
</ol>
<p>基于JavaScript的单线程语言执行环境及其不足，提出了JavaScript的同步与异步编程方式：</p>
<ol>
<li>同步，即任务一步一步执行，当前代码执行完毕后才能继续执行后续代码，程序的执行顺序与任务的排列顺序是一致的、同步的；</li>
<li>异步，每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。</li>
</ol>
<p>JavaScript异步编程实现主要归为三类：<strong>回调函数、事件监听、发布订阅、Promise对象</strong></p>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>假定有三个函数 f1 、 f2 和 f3，f2 等待 f1 的执行结果。</p>
<pre><code>f1();
f2();
f3();
</code></pre><p>如果 f1 是一个很耗时的任务，则可以改写 f1，把 f2 写成 f1 的回调函数。</p>
<pre><code>function f1(callback) {
    setTimeout(function() {
        // f1 的任务代码
        callback();
    }, 1000);
}
</code></pre><p>则执行代码就编程这样：</p>
<pre><code>f1(f2);
f3();
</code></pre><p>这样把同步操作变成了异步操作，f1 不会堵塞后面的程序例如 f3 的运行，相当于先执行程序的主要逻辑，将耗时的操作推迟执行。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>简单、容易理解和部署。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。</p>
<h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><p>采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生。<br>为f1绑定一个事件（这里采用的jQuery的写法）。</p>
<pre><code>f1.on(&apos;done&apos;, f2);
</code></pre><p>当 f1 发生 done 事件，就执行 f2。<br>对f1进行改写：</p>
<pre><code>function f1(){
    setTimeout(function () {
    　　// f1的任务代码
    　　f1.trigger(&apos;done&apos;);
    }, 1000);
}
</code></pre><p>f1.trigger(‘done’)表示，执行完成后，立即触发done事件，从而开始执行f2。</p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合”（Decoupling），有利于实现模块化。</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>整个程序都要变成事件驱动型，运行流程会变得很不清晰。</p>
<h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><p>假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”（publish-subscribe pattern），又称”观察者模式”（observer pattern）。</p>
<p>PubSub，发布、订阅模式， 用以分发事件。常见的有jQuery的自定义事件监听、Node的EventEmitter对象等。</p>
<h3 id="jQuery事件监听"><a href="#jQuery事件监听" class="headerlink" title="jQuery事件监听"></a>jQuery事件监听</h3><pre><code>$(&apos;#btn&apos;).on(&apos;myEvent&apos;, function(e) {
    console.log(&apos;There is my Event&apos;);
});
$(&apos;#btn&apos;).trigger(&apos;myEvent&apos;); //触发 myEvent 事件
</code></pre><h3 id="PubSub"><a href="#PubSub" class="headerlink" title="PubSub"></a>PubSub</h3><pre><code>var PubSub = function(){
    this.handlers = {}; 
};

// 订阅事件
PubSub.prototype.subscribe = function(eventType, handler) {
    // 如果操作中心没有这个事件类型，则将该事件初始化
    if (!(eventType in this.handlers)) { 
        this.handlers[eventType] = [];
    }
    this.handlers[eventType].push(handler); //添加事件监听器
    return this;//返回上下文环境以实现链式调用
};
// 发布事件
PubSub.prototype.publish = function(eventType) {
    // 获取除事件类型之外的其他参数
    var _args = Array.prototype.slice.call(arguments, 1);
    for (var i = 0, _handlers = this.handlers[eventType]; i &lt; _handlers.length; i++) {
        _handlers[i].apply(this, _args);//遍历事件监听器
    }
    return this;
};

var event = new PubSub;//构造PubSub实例
// 订阅一个事件
event.subscribe(&apos;list&apos;, function(msg) { 
    console.log(msg);
});
// 发布这个事件
event.publish(&apos;list&apos;, {data: [&apos;one,&apos;, &apos;two&apos;]});
//Object {data: Array[2]}
</code></pre><h2 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h2><p>Promises对象是CommonJS工作组提出的一种规范，目的是为异步编程提供统一接口。</p>
<h3 id="Promise-的生命周期"><a href="#Promise-的生命周期" class="headerlink" title="Promise 的生命周期"></a>Promise 的生命周期</h3><ol>
<li>一个promise可能有三种状态：等待（pending）、已完成（fulfilled）、已拒绝（rejected）;</li>
<li>一个promise的状态只可能从“等待”转到“完成”态或者“拒绝”态，不能逆向转换，同时“完成”态和“拒绝”态不能相互转换；</li>
<li>promise 必须实现 then 方法（可以说，then就是promise的核心），而且 then 必须返回一个 promise，同一个 promise 的 then 可以调用多次，并且回调的执行顺序跟它们被定义时的顺序一致；</li>
<li>then 方法接受两个参数，第一个参数是 Promise 被完成时要调用的函数，在 promise 由“等待”态转换到“完成”态时调用；另一个是 Promise 被拒绝时的回调，在 promise 由“等待”态转换到“拒绝”态时调用。</li>
<li>同时，then 可以接受另一个 promise 传入，也接受一个“类 then ”的对象或方法，即 thenable 对象。（thenable 是一个包含了then方法的对象或函数。）</li>
</ol>
<pre><code>let promise = readFile(&quot;example.txt);

promise.then(function(contents){
    //完成
    console.log(contents);
},function(err){
    //拒绝
    console.error(err.message);
});
</code></pre><p>也可以写成：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let promise = readFile("example.txt);</span><br><span class="line"></span><br><span class="line">promise.then(function(contents)&#123;</span><br><span class="line">	<span class="comment">//完成</span></span><br><span class="line">	console.<span class="built_in">log</span>(contents);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.catch(function(<span class="keyword">err</span>)&#123;</span><br><span class="line">	<span class="comment">//拒绝</span></span><br><span class="line">	console.<span class="keyword">error</span>(<span class="keyword">err</span>.message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在Node.js中也是使用 Promise 实现上面的 readFile() 函数。</span></span><br><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">		<span class="comment">//触发异步操作：Node.js原生的异步调用包在一个 Promise 中。</span></span><br><span class="line">		fs.readFile(filename,&#123;<span class="attr">encoding</span>:<span class="string">"utf8"</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,contents</span>)</span>&#123;</span><br><span class="line">			<span class="comment">//检查错误</span></span><br><span class="line">			<span class="keyword">if</span>(err)&#123;</span><br><span class="line">				reject(err);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//读取成功</span></span><br><span class="line">			resolve(contents);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>	  

	  <div>
  		<center>
		  <div class="pagination">
<ul class="pagination">
	
	
	
	
	
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
			
			
		
	
		
	
		
			
			
			
		
	
		
	
		
	
		
	
		
			
		
	
	
	
		<li class="prev"><a href="/2018/03/29/LearnES5/用ES5-实现一个简单的Promise/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>prev</a></li>
	
	<li><a href="/"><i class="fa fa-archive"></i>Home</a></li>
	
		<li class="next"><a href="/2018/03/28/LearnES5/js代码判断浏览器种类/" class="alignright next">next<i class="fa fa-arrow-circle-o-right"></i></a></li>
	
</ul>
</div>

		</center>
	  </div>
	  
	</div> <!-- col-md-9/col-md-12 -->
	
  </div><!-- row -->

	</div>
  </div>
  <div class="container-narrow">
	<footer> <p>
  &copy; 2018 Wonder
  
      with help from <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-wixo/">Wixo</a>.    
</p> </footer>
  </div> <!-- container-narrow -->
  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/jquery.tableofcontents.min.js"></script>
<script src="/js/tocgenerator.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>


</body>
</html>
