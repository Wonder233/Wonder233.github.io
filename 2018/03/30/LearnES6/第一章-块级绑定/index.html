<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第一章 块级绑定 | Wonder233&#39;s Blog</title>
  <meta name="author" content="Wonder">
  
  <meta name="description" content="努力努力再努力">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="第一章 块级绑定"/>
  <meta property="og:site_name" content="Wonder233&#39;s Blog"/>

  
    <meta property="og:image" content=""/>
  

  
    <link rel="alternative" href="/atom.xml" title="Wonder233&#39;s Blog" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">  
  <link rel="stylesheet" href="/css/sidenav.css" media="screen" type="text/css">  
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  

</head>

<body id="body" data-spy="scroll" data-target=".toc">
  <div class="container" id="container">
	<div class="content">
	  <div class="page-header">		
  <h1><a class="brand" href="/">Wonder233&#39;s Blog</a><span class="split"></span><span class="title">第一章 块级绑定</span><span class="date" id="title-date"><i class="fa fa-clock-o"></i> 2018-03-30</span></h1>
</div>		

<div class="row page">
  <!-- cols -->	
  
  <div class="col-xs-12 col-sm-3 col-md-3 toc"> 
	<!-- toc -->
<script type="text/javascript">
		jQuery(document).ready(function() {
 		   generateWikiTOC('.note', '.toc',  2 , 2 );
		});
</script>
  </div><!-- col-md-3 -->
  
  

  
  <div class="col-xs-12 col-sm-9 col-md-9 note">
	

	  <!-- content -->
	  <h2 id="var-声明与变量提升"><a href="#var-声明与变量提升" class="headerlink" title="var 声明与变量提升"></a>var 声明与变量提升</h2><p><strong>变量提升（ hoisting ）：</strong>使用 var 关键字声明的变量，无论其实际声明位置在何处，都会被视为声明于所在函数的顶部（如果声明不在任意函数内，则视为在全局作用域的顶部）。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span><span class="params">(condition)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (condition) &#123;</span><br><span class="line">		<span class="keyword">var</span> value = <span class="string">"blue"</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 其他代码</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// value 在此处可访问，值为 undefined</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// value 在此处可访问，值为 undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>JS 引擎会将 getValue 函数调整为如下形式：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">getValue</span>(<span class="params">condition</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        <span class="keyword">value</span> = <span class="string">"blue"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其他代码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="块级声明"><a href="#块级声明" class="headerlink" title="块级声明"></a>块级声明</h2><p><strong>块级声明</strong>：让所声明的变量在指定块的作用域外无法被访问。</p>
<p>块级作用域（又被称为词法作用域）在如下情况被创建：</p>
<ol>
<li>在一个函数内部</li>
<li>在一个由一对花括号包裹的代码块内部</li>
</ol>
<h3 id="let-声明"><a href="#let-声明" class="headerlink" title="let 声明"></a>let 声明</h3><p>大体上可以直接用 let 代替 var 进行变量声明，但会将变量的作用域限制在当前代码块中。</p>
<blockquote>
<p>由于 let 声明并不会被提升，因此若想让变量在整个代码块内部可用，需要手动将 let 声明放置到代码块顶部。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">getValue</span>(<span class="params">condition</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (condition) &#123;</span><br><span class="line">		<span class="keyword">let</span> <span class="keyword">value</span> = <span class="string">"blue"</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 其他代码</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// value 在此处不可用</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// value 在此处不可用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>在 condition 的值为 false 时，该变量永远不会被声明并初始化。</p>
<h4 id="禁止重复声明"><a href="#禁止重复声明" class="headerlink" title="禁止重复声明"></a>禁止重复声明</h4><p>如果一个标识符已经在代码块内部被定义，那么在此代码块内使用同一个标识符进行 let 声明就会导致错误。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法错误</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">count</span> = <span class="number">40</span>;</span><br></pre></td></tr></table></figure></p>
<p>在嵌套的作用域内使用 let 声明一个同名新变量，就不会有问题。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不会抛出错误</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> <span class="built_in">count</span> = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>原因：</strong><br>不是在同一作用域级别再次创建 count 变量，而是在 if 语句内部创建新变量。在 if 代码块内部，这个新变量会屏蔽全局的 count 变量，从而在局部阻止对于后者的访问。</p>
<h3 id="常量声明"><a href="#常量声明" class="headerlink" title="常量声明"></a>常量声明</h3><p>使用 const 声明的变量会被认为是常量（ constant ），值在被设置完成后就不允许再被更改。</p>
<blockquote>
<p>所有的 const 变量都需要在声明时进行初始化。<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有效的常量</span></span><br><span class="line"><span class="keyword">const</span> maxItems = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法错误：未进行初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="常量声明与-let-声明对比"><a href="#常量声明与-let-声明对比" class="headerlink" title="常量声明与 let 声明对比"></a>常量声明与 let 声明对比</h4><p><strong>相似点：</strong></p>
<ol>
<li><p>常量声明与 let 声明一样，都是块级声明。常量在声明它们的语句块之外是无法被访问的，并且声明也不会被提升。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">	<span class="keyword">const</span> maxItems = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 其他代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// maxItems 在此处无法访问</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在同一作用域内定义一个已有变量时会抛出错误，无论是在全局还是函数作用域，无论该变量此前是用 var 声明的，还是用 let 声明的。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">"Hello!"</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二者均会抛出错误</span></span><br><span class="line"><span class="keyword">const</span> message = <span class="string">"Goodbye!"</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">30</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>本质区别：</strong><br>试图对 const 声明的常量再次赋值会抛出错误，无论是否运行在严格模式下：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const maxItems = <span class="number">5</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">maxItems</span> = <span class="number">6</span><span class="comment">;      // 抛出错误</span></span><br></pre></td></tr></table></figure></p>
<h4 id="使用-const-声明对象"><a href="#使用-const-声明对象" class="headerlink" title="使用 const 声明对象"></a>使用 const 声明对象</h4><p>const 声明会阻止对于<strong>变量绑定与变量自身值</strong>的修改，但不会阻止对<strong>变量成员</strong>的修改。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">    <span class="built_in">name</span>: <span class="string">"Nicholas"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工作正常</span></span><br><span class="line">person.<span class="built_in">name</span> = <span class="string">"Greg"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line">person = &#123;</span><br><span class="line">    <span class="built_in">name</span>: <span class="string">"Greg"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>使用 let 或 const 声明的变量，在达到声明位置之前都是无法访问的，试图访问会导致一个引用错误。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    console.log(<span class="keyword">typeof</span> <span class="keyword">value</span>);  <span class="comment">// 引用错误</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">value</span> = <span class="string">"blue"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>原因：</strong><br>因为 value 位于被 JS 社区称为<strong>暂时性死区（ temporal dead zone ， TDZ ）</strong>的区域内。</p>
<p>当 JS 引擎扫描接下来的代码块并发现变量声明时：</p>
<ul>
<li>在处理 var 时将声明提升到函数或全局作用域的顶部；</li>
<li>处理 let 或 const 时，则会将声明放入暂时性死区。</li>
</ul>
<p>任何在暂时性死区内访问变量的企图都会导致“运行时”错误（runtime error）。只有执行到变量的声明语句时，该变量才会从暂时性死区内被移除，才可以安全使用。</p>
<blockquote>
<p>可以在变量被定义的代码块之外对该变量使用 typeof。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(<span class="keyword">typeof</span> <span class="keyword">value</span>);     <span class="comment">// "undefined"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">value</span> = <span class="string">"blue"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>typeof 运算符被用于 value 变量被定义的代码块外部，此时 value 并未在暂时性死区内。因为 value 变量绑定尚不存在，而 typeof 仅会单纯返回 “undefined” 。</p>
</blockquote>
<h2 id="循环中的块级绑定"><a href="#循环中的块级绑定" class="headerlink" title="循环中的块级绑定"></a>循环中的块级绑定</h2><h3 id="循环内的-var-声明"><a href="#循环内的-var-声明" class="headerlink" title="循环内的 var 声明"></a>循环内的 var 声明</h3><p>在 JS 中，由于 var 声明导致了变量提升，循环结束后 i 仍然可被访问，于是在循环内创建函数就会产生问题。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(i); &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    func();     <span class="comment">// 输出数值 "10" 十次</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><strong>解决方案：</strong><br>在循环内使用立即调用函数表达式（IIFEs），以便在每次迭代中强制创建变量的一个新副本：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    funcs.push((<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(i)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    func();     <span class="comment">// 从 0 到 9 依次输出</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="循环内的-let-声明"><a href="#循环内的-let-声明" class="headerlink" title="循环内的 let 声明"></a>循环内的 let 声明</h3><p>使用 let 声明，在每次迭代中，都会创建一个新的同名变量并对其进行初始化。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    func();     <span class="comment">// 从 0 到 9 依次输出</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>这种方式在 for-in 和 for-of 循环中同样适用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [],</span><br><span class="line">    object = &#123;</span><br><span class="line">        a: <span class="literal">true</span>,</span><br><span class="line">        b: <span class="literal">true</span>,</span><br><span class="line">        c: <span class="literal">true</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(key);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    func();     <span class="comment">// 依次输出 "a"、 "b"、 "c"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>let 声明在循环内部的行为是在规范中特别定义的，与不提升变量声明的特征没有必然联系。</p>
</blockquote>
<h3 id="循环内的常量声明"><a href="#循环内的常量声明" class="headerlink" title="循环内的常量声明"></a>循环内的常量声明</h3><p>ES6 规范没有明确禁止在循环中使用 const 声明，然而它会根据不同循环方式而有不同行为。</p>
<h4 id="常规-for-循环"><a href="#常规-for-循环" class="headerlink" title="常规 for 循环"></a>常规 for 循环</h4><p>可以在初始化时使用 const ，但循环会在试图改变该变量的值时抛出错误。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在一次迭代后抛出错误</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="for-in-或-for-of-循环"><a href="#for-in-或-for-of-循环" class="headerlink" title="for-in 或 for-of 循环"></a>for-in 或 for-of 循环</h4><p>const 变量在 for-in 或 for-of 循环中使用时，与 let 变量效果相同。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [],</span><br><span class="line">    object = &#123;</span><br><span class="line">        a: <span class="literal">true</span>,</span><br><span class="line">        b: <span class="literal">true</span>,</span><br><span class="line">        c: <span class="literal">true</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不会导致错误</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(key);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    func();     <span class="comment">// 依次输出 "a"、 "b"、 "c"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><strong>原因：</strong><br>因为for-in 与 for-of 循环为每次迭代创建了一个新的变量绑定，而不是像 for 循环那样试图去修改已绑定的变量的值。</p>
<h2 id="全局块级绑定"><a href="#全局块级绑定" class="headerlink" title="全局块级绑定"></a>全局块级绑定</h2><h3 id="使用-var-声明"><a href="#使用-var-声明" class="headerlink" title="使用 var 声明"></a>使用 var 声明</h3><p>在全局作用域上使用 var 时，会创建一个新的全局变量，并成为全局对象（在浏览器中是 window ）的一个属性。</p>
<blockquote>
<p>使用 var 可能会无意中覆盖一个已有的全局属性。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：浏览器中才有 window 属性</span></span><br><span class="line"><span class="comment">// 在浏览器中</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.RegExp);     <span class="comment">//function RegExp()&#123;&#125;</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">RegExp</span> = <span class="string">"Hello!"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.RegExp);     <span class="comment">// "Hello!"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ncz = <span class="string">"Hi!"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.ncz);        <span class="comment">// "Hi!"</span></span><br></pre></td></tr></table></figure>
<h3 id="使用-let-或-const-声明"><a href="#使用-let-或-const-声明" class="headerlink" title="使用 let 或 const 声明"></a>使用 let 或 const 声明</h3><p>在全局作用域上使用 let 或 const 声明时，会创建新的绑定，但不会有任何属性被添加到全局对象上。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在浏览器中</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">RegExp</span> = <span class="string">"Hello!"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>);                    <span class="comment">// "Hello!"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.RegExp === <span class="built_in">RegExp</span>);  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ncz = <span class="string">"Hi!"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(ncz);                       <span class="comment">// "Hi!"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"ncz"</span> <span class="keyword">in</span> <span class="built_in">window</span>);           <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>若想让代码能从全局对象中被访问，仍然需要使用 var 。这种做法常见于在浏览器中跨越帧或窗口去访问代码的场合。</p>
</blockquote>
	  

	  <div>
  		<center>
		  <div class="pagination">
<ul class="pagination">
	
	
	
	
	
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	
	
		<li class="prev disabled"><a><i class="fa fa-arrow-circle-o-left"></i>prev</a></li>
	
	<li><a href="/"><i class="fa fa-archive"></i>Home</a></li>
	
		<li class="next disabled"><a>next<i class="fa fa-arrow-circle-o-right"></i></a></li>
	
</ul>
</div>

		</center>
	  </div>
	  
	</div> <!-- col-md-9/col-md-12 -->
	
  </div><!-- row -->

	</div>
  </div>
  <div class="container-narrow">
	<footer> <p>
  &copy; 2018 Wonder
  
      with help from <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-wixo/">Wixo</a>.    
</p> </footer>
  </div> <!-- container-narrow -->
  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/jquery.tableofcontents.min.js"></script>
<script src="/js/tocgenerator.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>


</body>
</html>
