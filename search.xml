<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>书籍整理</title>
      <link href="/2018/03/29/%E7%94%9F%E6%B4%BB/%E4%B9%A6%E7%B1%8D%E6%95%B4%E7%90%86/"/>
      <url>/2018/03/29/%E7%94%9F%E6%B4%BB/%E4%B9%A6%E7%B1%8D%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="正在看"><a href="#正在看" class="headerlink" title="正在看"></a>正在看</h2><h3 id="《你不知道的-JavaScript-上卷》"><a href="#《你不知道的-JavaScript-上卷》" class="headerlink" title="《你不知道的 JavaScript 上卷》"></a><a href="https://book.douban.com/subject/26351021/" target="_blank" rel="noopener">《你不知道的 JavaScript 上卷》</a></h3><p><img src="/2018/03/29/生活/书籍整理/1_1.jpg" alt="《你不知道的 JavaScript 上卷》"></p><h3 id="《HTTP-权威指南》"><a href="#《HTTP-权威指南》" class="headerlink" title="《HTTP 权威指南》"></a><a href="https://book.douban.com/subject/10746113/" target="_blank" rel="noopener">《HTTP 权威指南》</a></h3><p><img src="/2018/03/29/生活/书籍整理/1_2.jpg" alt="《HTTP 权威指南》"></p><h3 id="《ES6-标准入门》"><a href="#《ES6-标准入门》" class="headerlink" title="《ES6 标准入门》"></a><a href="https://book.douban.com/subject/27127030/" target="_blank" rel="noopener">《ES6 标准入门》</a></h3><p><img src="/2018/03/29/生活/书籍整理/1_3.jpg" alt="《ES6 标准入门》"></p><h3 id="《深入理解-ES6-》"><a href="#《深入理解-ES6-》" class="headerlink" title="《深入理解 ES6 》"></a><a href="https://book.douban.com/subject/27072230/" target="_blank" rel="noopener">《深入理解 ES6 》</a></h3><p><img src="/2018/03/29/生活/书籍整理/1_4.jpg" alt="《深入理解 ES6》"></p><h2 id="已看完"><a href="#已看完" class="headerlink" title="已看完"></a>已看完</h2><h3 id="《Head-First-HTML-与-CSS（第2版）》"><a href="#《Head-First-HTML-与-CSS（第2版）》" class="headerlink" title="《Head First HTML 与 CSS（第2版）》"></a><a href="https://book.douban.com/subject/25752357/" target="_blank" rel="noopener">《Head First HTML 与 CSS（第2版）》</a></h3><p><img src="/2018/03/29/生活/书籍整理/2_1.jpg" alt="《Head First HTML 与 CSS（第2版）》"></p><h3 id="《HTML-5-CSS-3-从入门到精通》"><a href="#《HTML-5-CSS-3-从入门到精通》" class="headerlink" title="《HTML 5 + CSS 3 从入门到精通》"></a><a href="https://book.douban.com/subject/24708139/" target="_blank" rel="noopener">《HTML 5 + CSS 3 从入门到精通》</a></h3><p><img src="/2018/03/29/生活/书籍整理/2_2.jpg" alt="《HTML 5 + CSS 3 从入门到精通》"></p><h3 id="《JavaScript-高级程序设计（第3版）》"><a href="#《JavaScript-高级程序设计（第3版）》" class="headerlink" title="《JavaScript 高级程序设计（第3版）》"></a><a href="https://book.douban.com/subject/10546125/" target="_blank" rel="noopener">《JavaScript 高级程序设计（第3版）》</a></h3><p><img src="/2018/03/29/生活/书籍整理/2_3.jpg" alt="《JavaScript 高级程序设计（第3版）》"></p><h3 id="《JavaScript-语言精粹》"><a href="#《JavaScript-语言精粹》" class="headerlink" title="《JavaScript 语言精粹》"></a><a href="https://book.douban.com/subject/11874748/" target="_blank" rel="noopener">《JavaScript 语言精粹》</a></h3><p><img src="/2018/03/29/生活/书籍整理/2_4.jpg" alt="《JavaScript 语言精粹》"></p><h3 id="《CSS-权威指南》"><a href="#《CSS-权威指南》" class="headerlink" title="《CSS 权威指南》"></a><a href="https://book.douban.com/subject/2308234/" target="_blank" rel="noopener">《CSS 权威指南》</a></h3><p><img src="/2018/03/29/生活/书籍整理/2_5.jpg" alt="《CSS 权威指南》"></p><h3 id="《大话数据结构》"><a href="#《大话数据结构》" class="headerlink" title="《大话数据结构》"></a><a href="https://book.douban.com/subject/6424904/" target="_blank" rel="noopener">《大话数据结构》</a></h3><p><img src="/2018/03/29/生活/书籍整理/2_6.jpg" alt="《大话数据结构》"></p><h2 id="准备看"><a href="#准备看" class="headerlink" title="准备看"></a>准备看</h2><h3 id="《JavaScript-DOM-编程艺术（第2版）》"><a href="#《JavaScript-DOM-编程艺术（第2版）》" class="headerlink" title="《JavaScript DOM 编程艺术（第2版）》"></a><a href="https://book.douban.com/subject/6038371/" target="_blank" rel="noopener">《JavaScript DOM 编程艺术（第2版）》</a></h3><p><img src="/2018/03/29/生活/书籍整理/3_1.jpg" alt="《JavaScript DOM 编程艺术（第2版）》"></p><h3 id="《高性能-JavaScript》"><a href="#《高性能-JavaScript》" class="headerlink" title="《高性能 JavaScript》"></a><a href="https://book.douban.com/subject/26599677/" target="_blank" rel="noopener">《高性能 JavaScript》</a></h3><p><img src="/2018/03/29/生活/书籍整理/3_2.jpg" alt="《高性能 JavaScript》"></p><h3 id="《Effective-JavaScript-编写高质量-JavaScript-代码的-68-个有效方法》"><a href="#《Effective-JavaScript-编写高质量-JavaScript-代码的-68-个有效方法》" class="headerlink" title="《Effective JavaScript 编写高质量 JavaScript 代码的 68 个有效方法》"></a><a href="https://book.douban.com/subject/25786138/" target="_blank" rel="noopener">《Effective JavaScript 编写高质量 JavaScript 代码的 68 个有效方法》</a></h3><p><img src="/2018/03/29/生活/书籍整理/3_3.jpg" alt="《Effective JavaScript 编写高质量 JavaScript 代码的 68 个有效方法》"></p><h3 id="《你不知道的-JavaScript-中卷》"><a href="#《你不知道的-JavaScript-中卷》" class="headerlink" title="《你不知道的 JavaScript 中卷》"></a><a href="https://book.douban.com/subject/26854244/" target="_blank" rel="noopener">《你不知道的 JavaScript 中卷》</a></h3><p><img src="/2018/03/29/生活/书籍整理/3_4.jpg" alt="《你不知道的 JavaScript 中卷》"></p><h3 id="《你不知道的-JavaScript-下卷》"><a href="#《你不知道的-JavaScript-下卷》" class="headerlink" title="《你不知道的 JavaScript 下卷》"></a><a href="https://book.douban.com/subject/27620408/" target="_blank" rel="noopener">《你不知道的 JavaScript 下卷》</a></h3><p><img src="/2018/03/29/生活/书籍整理/3_5.jpg" alt="《你不知道的 JavaScript 下卷》"></p>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>js代码判断浏览器种类</title>
      <link href="/2018/03/28/LearnES5/js%E4%BB%A3%E7%A0%81%E5%88%A4%E6%96%AD%E6%B5%8F%E8%A7%88%E5%99%A8%E7%A7%8D%E7%B1%BB/"/>
      <url>/2018/03/28/LearnES5/js%E4%BB%A3%E7%A0%81%E5%88%A4%E6%96%AD%E6%B5%8F%E8%A7%88%E5%99%A8%E7%A7%8D%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h2 id="只区分浏览器，不考虑版本"><a href="#只区分浏览器，不考虑版本" class="headerlink" title="只区分浏览器，不考虑版本"></a>只区分浏览器，不考虑版本</h2><p><code>var browserVersions = function(){    var u = navigator.userAgent;    var app = navigator.appVersion;    return {        trident: u.indexOf(‘Trident’) &gt; -1, //IE内核        presto: u.indexOf(‘Presto’) &gt; -1, //opera内核        webKit: u.indexOf(‘AppleWebKit’) &gt; -1, //苹果、谷歌内核        gecko: u.indexOf(‘Gecko’) &gt; -1 &amp;&amp; u.indexOf(‘KHTML’) == -1, //火狐内核        mobile: !!u.match(/AppleWebKit.*Mobile.*/)||!!u.match(/AppleWebKit/), //是否为移动终端        ios: !!u.match(/(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端        android: u.indexOf(‘Android’) &gt; -1 || u.indexOf(‘Linux’) &gt; -1, //android终端或者uc浏览器        iPhone: u.indexOf(‘iPhone’) &gt; -1 || u.indexOf(‘Mac’) &gt; -1, //是否为iPhone或者QQHD浏览器        iPad: u.indexOf(‘iPad’) &gt; -1, //是否iPad        webApp: u.indexOf(‘Safari’) == -1 //是否web应该程序，没有头部与底部    };}();</code></p>]]></content>
      
      <categories>
          
          <category> LearnES5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>华为笔试题</title>
      <link href="/2018/03/28/Programming/%E5%8D%8E%E4%B8%BA%E7%AC%94%E8%AF%95%E9%A2%98/"/>
      <url>/2018/03/28/Programming/%E5%8D%8E%E4%B8%BA%E7%AC%94%E8%AF%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>华为笔试题，前面两道题非常简单就不进行记录了。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入是一个整型数组，数组里的整形数可以是正数，也可以是负数。子数组指的是数组中连续的一个或多个元素的集合，求这些子数组中，求和后最大值是多少。</p><p><strong>输入描述：</strong></p><blockquote><p>一个整型数组</p></blockquote><p><strong>输出描述：</strong></p><blockquote><p>最大连续子数组的和。</p></blockquote><h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><pre><code>function GreatSum(arr){    var sum = 0;    var result = 0;    for(var i in arr){        sum += arr[i];        if(sum &lt; 0){            sum = 0;        }        if(sum &gt; result){            result = sum;        }        if(result == 0){            for(var j in arr){                if(result == 0){                    result = arr[j];                } else if (result &lt; arr[j]){                    result = arr[j];                }            }        }    }    return result;}</code></pre>]]></content>
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网易互娱一面</title>
      <link href="/2018/03/28/%E7%94%9F%E6%B4%BB/%E7%BD%91%E6%98%93%E4%BA%92%E5%A8%B1%E4%B8%80%E9%9D%A2/"/>
      <url>/2018/03/28/%E7%94%9F%E6%B4%BB/%E7%BD%91%E6%98%93%E4%BA%92%E5%A8%B1%E4%B8%80%E9%9D%A2/</url>
      <content type="html"><![CDATA[<p>邮件通知我今天下午网易互娱一面视频面试，我当时心里是很紧张的。担心出现像之前今日头条视频面一样的情况，在公司的会议室面试结果老大来视察，差点被抓到暗地找实习，所以这次我背着电脑回寝室面。</p><p>中午怎么也睡不好觉，一点风吹草动就被惊醒，直接导致面试的时候思路不是很清晰。</p><p>但是，其实最郁闷的是面试，面试官先让我介绍一下我自己。我就说本科怎么怎么样，然后现在研究生怎么怎么blabla说了一堆。介绍完之后，他也不问我基础，让我说一下我最熟练的项目。我就说我现在正在重构的视频侦查作战平台，基于angularjs1做的，然后介绍了一堆。然后面试官问我知不知道前端框架，用前端框架会轻松得很多，你知不知道vue。我说我看过一些文档，但因为公司项目基于angularjs1，所以没有上手实战过。</p><p>看得出来他对我所知道的知识也不是很感兴趣，所以也没有怎么针对我所了解的知识进行深问。然后没问多少东西就结束了。最后的最后他给我提了一些意见：对前端的兴趣是有的，但热情不够= =。。。让我多去看github上人家写的源码。</p><p>本来我以为会像头条那样把基础问得很深，问得特别难，没想到会被技术刷人了。</p><p>结论：果然我要去上手实战一下 Vue 么！</p><p>后来佳静回来了，说了一番话让我没那么感觉郁闷了。她说不仅是前端团队在选择你，其实你也要选择前端团队。其实框架是互通的，如果他们并不知道angularjs也是前端框架的话，那说明这个团队其实知识面也是局限的，可能在这个团队学到的东西也很有限。嗯，我觉得也有道理。</p>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>HTML</title>
      <link href="/2018/03/27/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/HTML/"/>
      <url>/2018/03/27/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/HTML/</url>
      <content type="html"><![CDATA[<h2 id="1、-lt-img-gt-标签上title属性与alt属性的区别是什么？"><a href="#1、-lt-img-gt-标签上title属性与alt属性的区别是什么？" class="headerlink" title="1、 &lt; img &gt;标签上title属性与alt属性的区别是什么？"></a>1、 &lt; img &gt;标签上title属性与alt属性的区别是什么？</h2><ul><li>alt属性：是为了给那些不能看到你文档中图像的浏览者提供文字说明的。且长度必须少于100个英文字符或者用户必须保证替换文字尽可能的短。这包括那些使用本来就不支持图像显示或者图像显示被关闭的浏览器的用户，视觉障碍的用户和使用屏幕阅读器的用户等。</li><li>title属性：为设置该属性的元素提供建议性的信息。使用title属性提供非本质的额外信息。</li></ul><h2 id="2、-请写出至少5个-HTML5-新增的标签，并说明其语义和应用场景。"><a href="#2、-请写出至少5个-HTML5-新增的标签，并说明其语义和应用场景。" class="headerlink" title="2、 请写出至少5个 HTML5 新增的标签，并说明其语义和应用场景。"></a>2、 请写出至少5个 HTML5 新增的标签，并说明其语义和应用场景。</h2><ul><li>section：定义文档中的一个章节</li><li>nav：定义只包含导航链接的章节</li><li>header：定义页面或章节的头部。它经常包含 logo、页面标题和导航性的目录。</li><li>footer：定义页面或章节的尾部。它经常包含版权信息、法律信息链接和反馈建议用的地址。</li><li>aside：定义和页面内容关联度较低的内容——如果被删除，剩下的内容仍然很合理。</li></ul><h2 id="3、-请说说你对标签语义化的理解？"><a href="#3、-请说说你对标签语义化的理解？" class="headerlink" title="3、 请说说你对标签语义化的理解？"></a>3、 请说说你对标签语义化的理解？</h2><h3 id="什么是-HTML-语义化？"><a href="#什么是-HTML-语义化？" class="headerlink" title="什么是 HTML 语义化？"></a>什么是 HTML 语义化？</h3><p>根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。</p><h3 id="为什么要语义化？"><a href="#为什么要语义化？" class="headerlink" title="为什么要语义化？"></a>为什么要语义化？</h3><ul><li>为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构 ;</li><li>用户体验：例如title、 alt 用于解释名词或解释图片信息、 label 标签的活用；</li><li>有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；</li><li>方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；</li><li>便于团队开发和维护，语义化更具可读性，是下一步网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</li></ul><h3 id="语义化标签有哪些？"><a href="#语义化标签有哪些？" class="headerlink" title="语义化标签有哪些？"></a>语义化标签有哪些？</h3><ul><li>&lt; header&gt;&lt;/ header&gt;</li><li>&lt; footer&gt;&lt;/ footer&gt;</li><li>&lt; nav&gt;&lt; /nav&gt;</li><li>&lt; section&gt;&lt;/ section&gt;</li><li>&lt; article&gt;&lt;/ article&gt; SM:用来在页面中表示一套结构完整且独立的内容部分</li><li>&lt; aside&gt;&lt;/ aside&gt; SM:主题的附属信息 ( 用途很广，主要就是一个附属内容 ) ，如果 article 里面为一篇文章的话，那么文章的作者以及信息内容就是这篇文章的附属内容了</li><li>&lt; figure&gt;&lt;/ figure&gt; SM:媒体元素，比如一些视频，图片啊等等</li><li>&lt; datalist&gt;&lt;/ datalist&gt; SM:选项列表，与 input 元素配合使用，来定义 input 可能的值</li><li>&lt; details&gt;&lt;/ details&gt; SM:用于描述文档或者文档某个部分的细节 ~ 默认属性为 open~ ps:配合 summary 一起使用</li></ul><h2 id="4、-Doctype作用-严格模式与混杂模式如何区分？它们有何意义"><a href="#4、-Doctype作用-严格模式与混杂模式如何区分？它们有何意义" class="headerlink" title="4、 Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?"></a>4、 Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</h2><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><ul><li>&lt;!DOCTYPE&gt; 声明位于文档中的最前面，告知浏览器的解析器使用哪种文档类型来解析文档。</li><li>该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的HTML 文档。</li></ul><h3 id="区分："><a href="#区分：" class="headerlink" title="区分："></a>区分：</h3><ul><li>严格模式的排版 和 JS 运作模式 是以该浏览器支持的最高标准运行。</li><li>混杂模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。DOCTYPE 不存在 或 格式不正确 会导致文档以混杂模式呈现。</li></ul><blockquote><p>DOCTYPE 声明——标准模式与怪异模式的区别</p></blockquote><h2 id="5、-你知道多少种Doctype文档类型？"><a href="#5、-你知道多少种Doctype文档类型？" class="headerlink" title="5、 你知道多少种Doctype文档类型？"></a>5、 你知道多少种Doctype文档类型？</h2><p>标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。</p><ul><li>HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。</li><li>XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。</li><li>Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页， 浏览器按 W3C 标准解析执行代码</li><li>Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。</li></ul><h2 id="6、HTML与XHTML——二者有什么区别。"><a href="#6、HTML与XHTML——二者有什么区别。" class="headerlink" title="6、HTML与XHTML——二者有什么区别。"></a>6、HTML与XHTML——二者有什么区别。</h2><p>HTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的置标语言</p><ul><li>XHTML 元素必须被正确地嵌套</li><li>XHTML 元素必须被关闭，空标签也必须被关闭，如<br>必须写成 <br></li><li>XHTML 标签名必须用小写字母</li><li>XHTML 文档要求给所有属性赋一个值</li><li>XHTML 要求所有的属性必须用引号””括起来</li><li>XHTML 文档需要把所有 &lt; 、&gt;、&amp; 等特殊符号用编码表示</li><li>XHTML 文档不要在注释内容中使“–”</li><li>XHTML 图片必须有说明文字</li><li>XHTML 文档中用id属性代替name属性</li></ul><h2 id="7、-HTML5-有哪些新特性、移除了哪些元素？"><a href="#7、-HTML5-有哪些新特性、移除了哪些元素？" class="headerlink" title="7、 HTML5 有哪些新特性、移除了哪些元素？"></a>7、 HTML5 有哪些新特性、移除了哪些元素？</h2><p>HTML5 新增了 27 个元素，废弃了 16 个元素。<br>根据现有的标准规范，把  HTML5  的元素按优先级定义为结构性属性、级块性元素、行内语义性元素和交互性元素 4 大类。</p><h3 id="元素新特性"><a href="#元素新特性" class="headerlink" title="元素新特性"></a>元素新特性</h3><ol><li>结构性元素主要负责web上下文结构的定义。</li></ol><ul><li>section：在 web 页面应用中，该元素也可以用于区域的章节描述。</li><li>header：页面主体上的头部， header 元素往往在一对 body 元素中。</li><li>footer：页面的底部（页脚），通常会标出网站的相关信息。</li><li>nav：专门用于菜单导航、链接导航的元素，是 navigator 的缩写。</li><li>article：用于表现一篇文章的主体内容，一般为文字集中显示的区域。</li></ul><ol start="2"><li>级块性元素主要完成web页面区域的划分，确保内容的有效分割。</li></ol><ul><li>aside：用于表达注记、贴士、侧栏、摘要、插入的引用等作为补充主体的内容。</li><li>figure：是对多个元素进行组合并展示的元素，通常与 ficaption 联合使用。</li><li>code：表示一段代码块。</li><li>dialog：用于表达人与人之间的对话，该元素包含 dt 和 dd 这两个组合元素， dt 用于表示说话者，而 dd 用来表示说话内容。</li></ul><ol start="3"><li>行内语义性元素主要完成web页面具体内容的引用和描述，是丰富内容展示的基础。</li></ol><ul><li>meter：表示特定范围内的数值，可用于工资、数量、百分比等。</li><li>time：表示时间值。</li><li>progress：用来表示进度条，可通过对其 max 、 min 、 step 等属性进行控制，完成对进度的表示和监事。</li><li>video：视频元素，用于支持和实现视频文件的直接播放，支持缓冲预载和多种视频媒体格式。</li><li>audio：音频元素，用于支持和实现音频文件的直接播放，支持缓冲预载和多种音频媒体格式。</li></ul><ol start="4"><li>交互性元素主要用于功能性的内容表达，会有一定的内容和数据的关联，是各种事件的基础。</li></ol><ul><li>details：用来表示一段具体的内容，但是内容默认可能不显示，通过某种手段（如单击）与 legend 交互才会显示出来。</li><li>datagrid：用来控制客户端数据与显示，可以由动态脚本及时更新。</li><li>menu：主要用于交互菜单（曾被废弃又被重新启用的元素）。</li><li>command：用来处理命令按钮。</li></ul><h3 id="API新特性："><a href="#API新特性：" class="headerlink" title="API新特性："></a>API新特性：</h3><ol><li>HTML5  现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</li><li>语义化更好的内容标签（ header ,nav,footer,aside,article,section）</li><li>音频、视频API(audio,video)</li><li>画布( canvas ) API</li><li>地理(Geolocation) API</li><li>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失</li><li>sessionStorage 的数据在页面会话结束时会被清除</li><li>表单控件，calendar、date、time、email、url、search</li><li>新的技术 web worker, web socket 等<ul><li>web socket 一种协议，可以让我们建立客户端到服务器端的全双工通信，这就意味着服务器端可以主动推送数据到客户端。</li><li>web worker 运行在浏览器后台的js程序，他不影响主程序的运行，是另开的一个js线程，可以用这个线程执行复杂的数据操作，然后把操作结果通过postMessage传递给主线程，这样在进行复杂且耗时的操作时就不会阻塞主线程了。</li></ul></li><li>拖拽释放(Drag and drop) API<h3 id="移除元素："><a href="#移除元素：" class="headerlink" title="移除元素："></a>移除元素：</h3></li><li>纯表现的元素：<ul><li>&lt; basefont&gt; 默认字体，不设置字体，以此渲染</li><li>&lt; font&gt; 字体标签</li><li>&lt; center&gt; 水平居中</li><li>&lt; u&gt; 下划线</li><li>&lt; big&gt; 大字体</li><li>&lt; strike&gt; 中横线</li><li>&lt; tt&gt; 文本等宽</li></ul></li><li>框架集：frame，frameset，noframes；</li></ol><h2 id="8、-Quirks模式是什么？它和Standards模式有什么区别？"><a href="#8、-Quirks模式是什么？它和Standards模式有什么区别？" class="headerlink" title="8、 Quirks模式是什么？它和Standards模式有什么区别？"></a>8、 Quirks模式是什么？它和Standards模式有什么区别？</h2><h3 id="Quirks模式（怪癖模式，诡异模式，怪异模式）"><a href="#Quirks模式（怪癖模式，诡异模式，怪异模式）" class="headerlink" title="Quirks模式（怪癖模式，诡异模式，怪异模式）"></a>Quirks模式（怪癖模式，诡异模式，怪异模式）</h3><p>在写程序时我们也会经常遇到这样的问题，如何保证原来的接口不变，又提供更强大的功能，尤其是新功能不兼容旧功能时。IE6以前的页面大家都不会去写DTD，所以IE6就假定 如果写了DTD，就意味着这个页面将采用对CSS支持更好的布局，而如果没有，则采用兼容之前的布局方式(Quirks模式)。</p><h3 id="区别：总体有布局、样式解析和脚本执行三个方面的区别。"><a href="#区别：总体有布局、样式解析和脚本执行三个方面的区别。" class="headerlink" title="区别：总体有布局、样式解析和脚本执行三个方面的区别。"></a>区别：总体有布局、样式解析和脚本执行三个方面的区别。</h3><ol><li>盒模型：在W3C标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在Quirks 模式下，IE的宽度和高度还包含了padding和border。</li><li>设置行内元素的高宽：在Standards模式下，给<span>等行内元素设置wdith和height都不会生效，而在quirks模式下，则会生效。</span></li><li>设置百分比的高度：在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置百分比的高度，子元素设置一个百分比的高度是无效的用</li><li>设置水平居中：使用margin:0 auto在standards模式下可以使元素水平居中，但在quirks模式下却会失效。</li></ol><h2 id="9、-请阐述-table-表格布局的缺点。"><a href="#9、-请阐述-table-表格布局的缺点。" class="headerlink" title="9、 请阐述 table 表格布局的缺点。"></a>9、 请阐述 table 表格布局的缺点。</h2><ol><li>太深的嵌套，比如 table &gt; tr &gt; td &gt; h3，会导致搜索引擎读取困难，而且，最直接的损失就是大大增加了冗余代码量。</li><li>灵活性差，比如要将 tr 设置 border 等属性，是不行的，得通过 td</li><li>代码臃肿，当在 table 中套用 table 的时候，阅读代码会显得异常混乱</li><li>混乱的 colspan 与 rowspan，用来布局时，频繁使用他们会造成整个文档顺序混乱。</li><li>table 需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。</li><li>不够语义</li></ol><h2 id="10、-简述一下-src-与-href-的区别。"><a href="#10、-简述一下-src-与-href-的区别。" class="headerlink" title="10、 简述一下 src 与 href 的区别。"></a>10、 简述一下 src 与 href 的区别。</h2><p>src 用于替换当前元素，href 用于在当前文档和引用资源之间确立联系。</p><ul><li>href 是指向 网络资源 所在位置，建立 引用资源 和 当前元素（锚点）/当前文档（链接） 之间的链接。</li><li>src 是指向 外部资源 的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本，img 图片和 frame 等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。</li></ul>]]></content>
      
      <categories>
          
          <category> 前端面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ECMAScript数据类型</title>
      <link href="/2018/03/27/LearnES5/ECMAScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/03/27/LearnES5/ECMAScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>ECMAScirpt 5.1 中定义了6种数据类型，其中有5中简单数据类型（基本数据类型）:</p><ol><li><strong>Undefined：</strong>只有一个值，为undefined，意味着“空值(no value)”，适用于所有数据类型。</li><li><strong>Null：</strong>只有一个值，为null，意味着“空对象(no object)”，只适用于对象类型。（literal）</li><li><strong>Boolean：</strong>有两个值，为true与false </li><li><strong>Number：</strong>值遵循IEEE 754标准的64位浮点数的集合，没有整型数据结构。此外还包含三个特殊的值：NaN、Infinity、Infinity</li><li><strong>String：</strong>值是有穷个Unicode字符的集合。必须用’或”括起来。</li><li>还有一种复杂数据类型： <strong>Object</strong></li><li>最新的ECMAScript 6 又加了一种类型：<strong>Symbol</strong> (ECMAScript 6 新定义)</li></ol><hr><h2 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h2><p>用来检测给定变量的数据类型。<br>对一个值使用typeof操作符可能返回下列某个字符：</p><ol><li>“undefined”值未定义 </li><li>“boolean”布尔值 </li><li>“string”字符串 </li><li>“number”数值 </li><li>“object”对象或null</li><li>“function”函数</li></ol><p>使用：typeof 操作数  /  typeof(操作数)  ——&gt;圆括号不是必须的，因为typeof不是函数</p><hr><h2 id="Undefine类型"><a href="#Undefine类型" class="headerlink" title="Undefine类型"></a>Undefine类型</h2><p>首字母大写的Undefined表示的是一种数据类型，小写的undefined表示的是属于这种数据类型的唯一的一个值。<br>使用var声明变量但未进行初始化时，这个变量的值就是undefined，例如：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">message</span>;</span><br><span class="line">alert(<span class="keyword">message</span> == undefined); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>一个未初始化的变量的值为undefined，一个没有传入实参的形参变量的值为undefined，如果一个函数什么都不返回，则该函数默认返回undefined。</p><blockquote><p>注意： 对未声明的变量执行typeof操作符同样会返回undefined。</p></blockquote><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message; <span class="comment">//这个变量声明之后默认为undefined</span></span><br><span class="line"><span class="comment">// 下面这个变量未声明</span></span><br><span class="line"><span class="comment">// var age</span></span><br><span class="line">alert(<span class="keyword">typeof</span> message); <span class="comment">// "undefined"</span></span><br><span class="line">alert(<span class="keyword">typeof</span> age); <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure><hr><h2 id="Null类型"><a href="#Null类型" class="headerlink" title="Null类型"></a>Null类型</h2><p>首字母大写的Null表示的是一种数据类型，小写的null表示的是属于这种数据类型的唯一的一个值。<br>null值表示一个空对象指针：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> car = <span class="literal">null</span>;</span><br><span class="line">alert(<span class="keyword">typeof</span> car); <span class="comment">//"object"</span></span><br></pre></td></tr></table></figure><p>如果定义的变量准备用于保存对象，那么最好将该变量初始化为null。</p><p>undefined 值派生自 null，因此规定相等性测试返回 true。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span>  <span class="string">==</span> <span class="string">undefined</span> <span class="string">//</span> <span class="literal">true</span></span><br><span class="line"><span class="literal">null</span> <span class="string">===</span> <span class="string">undefined</span> <span class="string">//</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>null 是一个字面量 (而不是全局对象的一个属性，undefined 是 )</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span>);             <span class="regexp">//</span><span class="literal">null</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span>);        <span class="regexp">//</span><span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.<span class="literal">null</span>);      <span class="regexp">//</span><span class="literal">undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.<span class="literal">undefined</span>); <span class="regexp">//</span><span class="literal">undefined</span></span><br></pre></td></tr></table></figure><p><strong>null与undefined的区别</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foot); <span class="comment">// Uncaught ReferenceError: foot is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="built_in">console</span>.log(foo);  <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(bar);  <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>        <span class="comment">// object (bug in ECMAScript, should be null)</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>   <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><hr><h2 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h2><p>1、如果 Boolean 构造函数的参数不是一个布尔值，则该参数会被转换成一个布尔值。<br>2、<strong>转换规则:</strong></p><table><thead><tr><th>数据类型</th><th>true</th><th>false</th></tr></thead><tbody><tr><td>Boolean</td><td>true</td><td>false</td></tr><tr><td>String</td><td>任何非空字符串</td><td>“”（空字符串）</td></tr><tr><td>Number</td><td>任何非零数字值（包括无穷大）</td><td>0 和 NaN</td></tr><tr><td>Object</td><td>任何对象</td><td>null</td></tr><tr><td>Undefined</td><td>（不适用）</td><td>undefined</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化的时候</span></span><br><span class="line"><span class="comment">//false</span></span><br><span class="line"><span class="keyword">var</span> bfalse = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">var</span> bEmptyString = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="string">""</span>);</span><br><span class="line"><span class="keyword">var</span> bZero = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> bNaN = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">NaN</span>);</span><br><span class="line"><span class="keyword">var</span> bNull = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">var</span> bNoParam = <span class="keyword">new</span> <span class="built_in">Boolean</span>(); <span class="comment">//相当于传入undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="keyword">var</span> btrue = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">var</span> btrueString = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="string">"true"</span>);</span><br><span class="line"><span class="keyword">var</span> bfalseString = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="string">"false"</span>);</span><br><span class="line"><span class="keyword">var</span> bSuLin = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="string">"Su Lin"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>不要通过新建 Boolean 对象的方法来将一个非布尔值转化成布尔值。 直接使用 Boolean 函数才是正确的</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="built_in">Boolean</span>(expression);     <span class="comment">// 这样用</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="built_in">Boolean</span>(expression); <span class="comment">// 而不要这样!</span></span><br></pre></td></tr></table></figure><h2 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h2><p>根据 ECMAScript 标准，JavaScript 中只有一种数字类型：基于 IEEE 754 标准的双精度 64 位二进制格式的值（-(253 -1) 到 253 -1）。它并没有为整数给出一种特定的类型。除了能够表示浮点数外，还有一些带符号的值：+Infinity，-Infinity 和 NaN (非数值，Not-a-Number)</p><h3 id="1-数值字面量格式："><a href="#1-数值字面量格式：" class="headerlink" title="1.数值字面量格式："></a>1.数值字面量格式：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intNum = <span class="number">55</span>; <span class="comment">//十进制整数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> octalNum1 = <span class="number">070</span>; <span class="comment">//八进制 56</span></span><br><span class="line"><span class="keyword">var</span> octalNum1 = <span class="number">079</span>; <span class="comment">//无效，解析为79</span></span><br><span class="line"><span class="keyword">var</span> octalNum1 = <span class="number">08</span>;  <span class="comment">//无效，解析为8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hexNum1 = <span class="number">0xA</span>;  <span class="comment">//十六进制 10</span></span><br><span class="line"><span class="keyword">var</span> hexNum1 = <span class="number">0x1f</span>; <span class="comment">//十六进制31</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> floatNum1 = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">var</span> floatNum2 = <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">var</span> floatNum3 = <span class="number">.1</span>; <span class="comment">//有效但不推荐</span></span><br><span class="line"><span class="keyword">var</span> floatNum4 = <span class="number">1.0</span>; <span class="comment">//小数点后面没有数字，转换为整数 解析为1</span></span><br><span class="line"><span class="keyword">var</span> floatNum5 = <span class="number">10.0</span>; <span class="comment">//整数 解析为10</span></span><br><span class="line"><span class="keyword">var</span> floatNum6 = <span class="number">3.125e7</span>; <span class="comment">//等于31250000</span></span><br></pre></td></tr></table></figure><p>数字类型只有一个整数，它有两种表示方法： 0 可表示为 -0 和 +0（”0” 是 +0 的简写）。 在实践中，这也几乎没有影响。 例如 +0 === -0 为真。 但是，你可能要注意除以0的时候：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">42 </span>/ +<span class="number">0</span>; // Infinity</span><br><span class="line"><span class="symbol">42 </span>/ -<span class="number">0</span>; // -Infinity</span><br></pre></td></tr></table></figure><h3 id="2-数值范围"><a href="#2-数值范围" class="headerlink" title="2.数值范围"></a>2.数值范围</h3><table><thead><tr><th>表示</th><th>描述</th></tr></thead><tbody><tr><td>Number.MIN_VALUE</td><td>最小数值，一般为5e-324</td></tr><tr><td>Number.MAX_VALUE</td><td>最大数值，一般为1.7976931348623157e+308</td></tr><tr><td>Infinity</td><td>正无穷，是不能参与计算的数值</td></tr><tr><td>-Infinity</td><td>负无穷，是不能参与计算的数值</td></tr></tbody></table><h3 id="3-NAN"><a href="#3-NAN" class="headerlink" title="3.NAN"></a>3.NAN</h3><p>如果参数无法被转换为数字，则返回 NaN。</p><ul><li>任何涉及NaN的操作（例如NaN/10）都会返回NaN。</li><li>NaN与任何值都不相等，包括NaN本身。</li></ul><p>ECMAScript定义了isNaN()函数来确定某个参数是否“不是数值”。isNaN()在接收到一个值之后，会尝试将这个值转换为数值。某些不是数值的值会直接转换为数值，而任何不能被转换为数值的值都会导致这个函数返回true。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>);        <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="built_in">Number</span>.NaN); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">0</span> / <span class="number">0</span>)       <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// e.g. these would have been true with global isNaN()</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">"NaN"</span>);      <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">undefined</span>);  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(&#123;&#125;);         <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">"blabla"</span>);   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// These all return false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">37</span>);</span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">"37"</span>);</span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">"37.37"</span>);</span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">""</span>);</span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">" "</span>);</span><br></pre></td></tr></table></figure><p>将非数值转换为数值：Number()、parseInt()、parseFloat()</p><p><strong>Number() 可用于任何数据类型</strong></p><h3 id="转换规则："><a href="#转换规则：" class="headerlink" title="转换规则："></a>转换规则：</h3><ul><li>Boolean值：true false分别转换为1 0</li><li>数字值：简单的传入和返回</li><li>null值：0</li><li>undefined值：返回NaN</li><li>字符串：<ul><li>只包含数字（包括前面带正、负号）则转换为十进制数值</li><li>包含有效的浮点格式，如“1.1”，则转换为对应的浮点数</li><li>包含有效的十六进制格式，如“0xf”，则转换为相同大小的十进制整数</li><li>字符串为空，则转换为0</li><li>字符串中包含除上述格式之外的字符，则转换为NaN</li></ul></li><li>若为对象，则调用对象的valueof()方法，然后依照前面的规则转换返回值。若转换的结果是NaN，则调用对象的toString()方法，然后再次依照前面的规则转换返回值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">Number</span>(<span class="string">"hello world!"</span>); <span class="comment">//NaN</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">Number</span>(<span class="string">""</span>);             <span class="comment">//0</span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">Number</span>(<span class="string">"000011"</span>);       <span class="comment">//11</span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">Number</span>(<span class="literal">true</span>);           <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//处理整数常用parseInt()函数</span></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseInt</span>(<span class="string">"1234blue"</span>); <span class="comment">//1234</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">""</span>);         <span class="comment">//NaN</span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseInt</span>(<span class="string">"0xA"</span>);      <span class="comment">//10</span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseInt</span>(<span class="number">22.5</span>);       <span class="comment">//22</span></span><br><span class="line"><span class="keyword">var</span> num5 = <span class="built_in">parseInt</span>(<span class="string">"070"</span>);      <span class="comment">//ECMAScript 3 认为是56 八进制，ECMAScript 5 认为是70 十进制</span></span><br><span class="line"><span class="keyword">var</span> num6 = <span class="built_in">parseInt</span>(<span class="string">"70"</span>);       <span class="comment">//70 十进制</span></span><br><span class="line"><span class="keyword">var</span> num7 = <span class="built_in">parseInt</span>(<span class="string">"0xf"</span>);      <span class="comment">//15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//处理浮点数常用parseFloat()函数</span></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseFloat</span>(<span class="string">"1234blue"</span>); <span class="comment">//1234</span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseFloat</span>(<span class="string">"0xA"</span>);      <span class="comment">//0</span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseFloat</span>(<span class="string">"22.5"</span>);     <span class="comment">//22.5</span></span><br><span class="line"><span class="keyword">var</span> num5 = <span class="built_in">parseFloat</span>(<span class="string">"22.34.5"</span>);  <span class="comment">//22.34</span></span><br><span class="line"><span class="keyword">var</span> num6 = <span class="built_in">parseFloat</span>(<span class="string">"0908.5"</span>);   <span class="comment">//908.5</span></span><br><span class="line"><span class="keyword">var</span> num7 = <span class="built_in">parseFloat</span>(<span class="string">"3.125e7"</span>);  <span class="comment">//31250000</span></span><br></pre></td></tr></table></figure><hr><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>1、JavaScript的字符串类型用于表示文本数据。它是一组16位的无符号整数值的“元素”。<br>2、在字符串中的每个元素占据了字符串的位置。第一个元素的索引为0，下一个是索引1，依此类推。字符串的长度是它的元素的数量<br>3、与 C 语言不同，JavaScript 中字符串是不可变的（译注：如，JavaScript 中对字符串的操作一定返回了一个新字符串，原始字符串并没有被改变）<br>Javascript中一切都是object-based。</p><h3 id="创建string，也有两种类型"><a href="#创建string，也有两种类型" class="headerlink" title="创建string，也有两种类型"></a>创建string，也有两种类型</h3><ol><li>使用字面量方式创建的字符串，为基本类型的 string              <ul><li>实际上保存就是的值，是一个基本类型 </li></ul></li><li>使用String()创建的字符串，为基本类型的 string     </li><li>使用构造函数 new String()的方式创建的字符串，为对象类型的 string  <ul><li>实际上保存的是一个指向字符串对象的指针</li></ul></li></ol><h3 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h3><ul><li>第一种方法：toString() 返回相应值的字符串表现（null与undefined值没有这个方法）</li><li>第二种方法：在不知道转换的值是不是null或undefined情况下，可以用转型函数String()，能将任何类型的值转换为字符串。</li></ul><hr><h2 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h2><p>数据和功能的集合。是所有对象的基础，所有对象都具有Object的基本属性和方法。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>; <span class="comment">// 有效，但不推荐省略圆括号</span></span><br></pre></td></tr></table></figure><h3 id="①constructor属性"><a href="#①constructor属性" class="headerlink" title="①constructor属性"></a>①constructor属性</h3><p>构造函数属性,可确定当前对象的构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">console</span>.log(o.constructor == <span class="built_in">Object</span>);<span class="comment">//true</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="built_in">console</span>.log(arr.constructor == <span class="built_in">Array</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="②hasOwnProperty-propertyName"><a href="#②hasOwnProperty-propertyName" class="headerlink" title="②hasOwnProperty(propertyName)"></a>②hasOwnProperty(propertyName)</h3><p>判断属性是否存在于当前对象实例中（而不是在实例的原型中）。</p><h3 id="③isPrototypeOf-object"><a href="#③isPrototypeOf-object" class="headerlink" title="③isPrototypeOf(object)"></a>③isPrototypeOf(object)</h3><p>判断传入的对象是否是当前对象的原型</p><h3 id="④propertyIsEnumerable-propertyName"><a href="#④propertyIsEnumerable-propertyName" class="headerlink" title="④propertyIsEnumerable(propertyName)"></a>④propertyIsEnumerable(propertyName)</h3><p>判断给定的属性是否能使用for-in语句来枚举</p><h3 id="⑤toLocaleString"><a href="#⑤toLocaleString" class="headerlink" title="⑤toLocaleString()"></a>⑤toLocaleString()</h3><p>返回对象的字符串表示，该字符串与执行环境的地区对应</p><h3 id="⑥toString"><a href="#⑥toString" class="headerlink" title="⑥toString()"></a>⑥toString()</h3><p>返回对象的字符串表示</p><h3 id="⑦valueOf"><a href="#⑦valueOf" class="headerlink" title="⑦valueOf()"></a>⑦valueOf()</h3><p>返回对象的字符串、数值或布尔值表示</p><hr><h2 id="Symbol类型"><a href="#Symbol类型" class="headerlink" title="Symbol类型"></a>Symbol类型</h2><p>ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。 可以从根本上防止属性名的冲突。</p><p>Symbol值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">typeof</span> s            <span class="comment">// "symbol"</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量s就是一个独一无二的值。typeof运算符的结果，表明变量s是 Symbol 数据类型，而不是字符串之类的其他类型。</p><blockquote><p>注意， Symbol 函数前不能使用 new 命令，否则会报错。这是因为生成的  Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol  值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p></blockquote><p>Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);</span><br><span class="line">s1 <span class="comment">// Symbol(foo)</span></span><br><span class="line">s2 <span class="comment">// Symbol(bar)</span></span><br><span class="line">s1.toString() <span class="comment">// "Symbol(foo)"</span></span><br><span class="line">s2.toString() <span class="comment">// "Symbol(bar)"</span></span><br></pre></td></tr></table></figure><p>上面代码中，s1和s2是两个 Symbol 值。如果不加参数，它们在控制台的输出都是Symbol()，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。</p><blockquote><p>注意，Symbol 函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的 Symbol 函数的返回值是不相等的。</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  没有参数的情况</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>();</span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  有参数的情况</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，s1和s2都是Symbol函数的返回值，而且参数相同，但是它们是不相等的。</p><p>由于每一个Symbol值都是不相等的，这意味着Symbol值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。Symbol值作为对象属性名时，不能用点运算符。在对象的内部，使用Symbol值定义属性时，Symbol值必须放在方括号之中。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mySymbol = Symbol();</span><br><span class="line"><span class="comment">//  第一种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">'Hello!'</span>;</span><br><span class="line"><span class="comment">//  第二种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">[<span class="meta">mySymbol</span>]: <span class="string">'Hello!'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//  第三种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">Object.defineProperty(a, mySymbol, &#123; <span class="keyword">value</span>: <span class="string">'Hello!'</span> &#125;);</span><br><span class="line"><span class="comment">//  以上写法都得到同样结果</span></span><br><span class="line">a[mySymbol] <span class="comment">// "Hello!"</span></span><br></pre></td></tr></table></figure><p><strong>Symbol 值不能与其他类型的值进行运算，会报错。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym = <span class="built_in">Symbol</span>(<span class="string">'My symbol'</span>);</span><br><span class="line"><span class="string">"your symbol is "</span> + sym</span><br><span class="line"><span class="comment">// TypeError: can't convert symbol to string</span></span><br><span class="line"><span class="string">`your symbol is <span class="subst">$&#123;sym&#125;</span>`</span></span><br><span class="line"><span class="comment">// TypeError: can't convert symbol to string</span></span><br></pre></td></tr></table></figure><p>但是， Symbol 值可以显式转为字符串。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym = <span class="built_in">Symbol</span>(<span class="string">'My symbol'</span>);</span><br><span class="line"><span class="built_in">String</span>(sym) <span class="comment">// 'Symbol(My symbol)'</span></span><br><span class="line">sym.toString() <span class="comment">// 'Symbol(My symbol)'</span></span><br></pre></td></tr></table></figure><h3 id="Symbol-for-，-Symbol-keyFor"><a href="#Symbol-for-，-Symbol-keyFor" class="headerlink" title="Symbol.for() ， Symbol.keyFor()"></a>Symbol.for() ， Symbol.keyFor()</h3><p>有时，我们希望重新使用同一个 Symbol 值，Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'foo'</span>);</span><br><span class="line">s1 === s2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中， s1 和 s2 都是 Symbol 值，但是它们都是同样参数的Symbol.for方法生成的，所以实际上是同一个值。</p><p>Symbol.for()与Symbol()这两种写法，都会生成新的 Symbol 。<br><strong>区别：</strong><br>前者会被登记在全局环境中供搜索，后者不会。</p><ul><li>Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的 key 是否已经存在，如果不存在才会新建一个值。比如，如果你调用</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">"cat"</span>) <span class="number">30</span>次，每次都会返回同一个 <span class="built_in">Symbol</span> 值，但是调用<span class="built_in">Symbol</span>(<span class="string">"cat"</span>) <span class="number">30</span> 次，会返回 <span class="number">30</span> 个不同的 <span class="built_in">Symbol</span> 值。</span><br><span class="line"><span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">"bar"</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>(<span class="string">"bar"</span>)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，由于Symbol()写法没有登记机制，所以每次调用都会返回一个不同的值。</p><ul><li>Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key 。</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1) <span class="comment">// "foo"</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量s2属于未登记的 Symbol 值，所以返回undefined。</p><blockquote><p>需要注意的是，Symbol.for为 Symbol 值登记的名字，是全局环境的，可以在不同的 iframe 或 service worker中取到同一个值。</p></blockquote>]]></content>
      
      <categories>
          
          <category> LearnES5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>博客和域名连接后,博客的重新开始</title>
      <link href="/2018/03/27/%E7%94%9F%E6%B4%BB/%E5%8D%9A%E5%AE%A2%E5%92%8C%E5%9F%9F%E5%90%8D%E8%BF%9E%E6%8E%A5%E5%90%8E-%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B/"/>
      <url>/2018/03/27/%E7%94%9F%E6%B4%BB/%E5%8D%9A%E5%AE%A2%E5%92%8C%E5%9F%9F%E5%90%8D%E8%BF%9E%E6%8E%A5%E5%90%8E-%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B/</url>
      <content type="html"><![CDATA[<p>早很久前就想将原来的博客重新更换一下，想换一个更好的主题，能够让我将我需要的知识保存并更方便查看。也是早很久前就想买个属于自己的域名。<br>腾讯来华科进行技术宣讲，现在我很庆幸我当时去了。<br>在宣讲会上可能能获取到的知识不多，但是我领到了一张腾讯云的100元优惠券。O(∩_∩)O 用那张优惠券，免费买了三年的域名使用权~<br>于是，现在我又重新开始在这里写博客啦！</p>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
  
  
    
  
</search>
