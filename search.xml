<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>列表渲染</title>
      <link href="/2018/03/31/Vue%E5%AD%A6%E4%B9%A0/%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/"/>
      <url>/2018/03/31/Vue%E5%AD%A6%E4%B9%A0/%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/</url>
      <content type="html"><![CDATA[<h2 id="一个数组的-v-for"><a href="#一个数组的-v-for" class="headerlink" title="一个数组的 v-for"></a>一个数组的 v-for</h2><p>用 <code>v-for</code> 指令根据一组数组的选项列表进行渲染。</p><p>（1）<code>v-for</code> 指令需要使用 <code>item in items</code> 形式的特殊语法，<code>items</code> 是源数据数组并且 <code>item</code> 是数组元素迭代的别名。<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"example-1"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;&#123;item.message&#125;&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var example1 = new Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-1'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [</span><br><span class="line">      &#123; message: <span class="string">'Foo'</span> &#125;,</span><br><span class="line">      &#123; message: <span class="string">'Bar'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>结果：<br><img src="/2018/03/31/Vue学习/列表渲染/./1.png" alt="Alt text"></p><p>（2）v-for 还支持一个可选的第二个参数为当前项的索引。</p><blockquote><p>在 v-for 块中，我们拥有对父作用域属性的完全访问权限。</p></blockquote><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"example-2"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in items"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;&#123; parentMessage &#125;&#125;</span><span class="xml"> - </span><span class="template-variable">&#123;&#123; index &#125;&#125;</span><span class="xml"> - </span><span class="template-variable">&#123;&#123; item.message &#125;&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var example2 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="keyword">e</span><span class="variable">l:</span> <span class="string">'#example-2'</span>,</span><br><span class="line">  dat<span class="variable">a:</span> &#123;</span><br><span class="line">    parentMessage: <span class="string">'Parent'</span>,</span><br><span class="line">    item<span class="variable">s:</span> [</span><br><span class="line">      &#123; message: <span class="string">'Foo'</span> &#125;,</span><br><span class="line">      &#123; message: <span class="string">'Bar'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="/2018/03/31/Vue学习/列表渲染/./2.png" alt="Alt text"></p><p>（3）也可以用 of 替代 in 作为分隔符，因为它是最接近 JavaScript 迭代器的语法：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> v-<span class="keyword">for</span>=<span class="string">"item of items"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p><h2 id="一个对象的-v-for"><a href="#一个对象的-v-for" class="headerlink" title="一个对象的 v-for"></a>一个对象的 v-for</h2><p>（1）可以用 v-for 通过一个对象的属性来迭代。<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"v-for-object"</span> <span class="attr">class</span>=<span class="string">"demo"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"value in object"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;&#123;value&#125;&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">new</span> <span class="selector-tag">Vue</span>(&#123;</span><br><span class="line">  <span class="attribute">el</span>: <span class="string">'#v-for-object'</span>,</span><br><span class="line">  <span class="attribute">data</span>: &#123;</span><br><span class="line">    <span class="attribute">object</span>: &#123;</span><br><span class="line">      <span class="attribute">firstName</span>: <span class="string">'John'</span>,</span><br><span class="line">      <span class="attribute">lastName</span>: <span class="string">'Doe'</span>,</span><br><span class="line">      <span class="attribute">age</span>: <span class="number">30</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>结果：<br><img src="/2018/03/31/Vue学习/列表渲染/./3.png" alt="Alt text"></p><p>（2）可以提供第二个的参数为键名：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(value, key) in object"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="template-variable">&#123;&#123; key &#125;&#125;</span><span class="xml">: </span><span class="template-variable">&#123;&#123; value &#125;&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p><img src="/2018/03/31/Vue学习/列表渲染/./4.png" alt="Alt text"></p><p>（3）可以提供第三个参数为索引：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-for=<span class="string">"(value, key, index) in object"</span>&gt;</span><br><span class="line">  &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/2018/03/31/Vue学习/列表渲染/./5.png" alt="Alt text"></p><blockquote><p>在遍历对象时，是按 Object.keys() 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下是一致的。</p></blockquote><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>当 Vue.js 用 <code>v-for</code> 正在更新已渲染过的元素列表时，它默认用“<strong>就地复用</strong>”策略。<br>如果数据项的顺序被改变，Vue 将<strong>不会移动 DOM 元素</strong>来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。</p><p>这个默认的模式是高效的，但是只适用于<strong>不依赖子组件状态</strong>或<strong>临时 DOM 状态</strong> (例如：表单输入值) 的列表渲染输出。</p><p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 <code>key</code> 属性。理想的 <code>key</code> 值是每项都有的且唯一的 <code>id</code>。它的工作方式类似于一个属性，所以你需要用 <code>v-bind</code> 来绑定动态值 (在这里使用简写)：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> v-<span class="keyword">for</span>=<span class="string">"item in items"</span> :key=<span class="string">"item.id"</span>&gt;</span><br><span class="line">&#123;&#123;<span class="built_in">item</span>&#125;&#125;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p>建议尽可能在使用 <code>v-for</code> 时提供 <code>key</code>，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。</p></blockquote><h2 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h2><h3 id="变异方法"><a href="#变异方法" class="headerlink" title="变异方法"></a>变异方法</h3><p>变异方法 (mutation method)：改变被这些方法调用的原始数组。</p><p>Vue 包含一组观察数组的变异方法，它们会触发视图更新。这些方法如下：</p><ul><li><code>push()</code></li><li><code>pop()</code></li><li><code>shift()</code></li><li><code>unshift()</code></li><li><code>splice()</code></li><li><code>sort()</code></li><li><code>reverse()</code></li></ul><h3 id="替换数组"><a href="#替换数组" class="headerlink" title="替换数组"></a>替换数组</h3><p>非变异方法 (non-mutating method)：不会改变原始数组，但总是返回一个新数组。例如：<code>filter(), concat()</code>和<code>slice()</code> 。</p><p>当使用非变异方法时，可以用新数组替换旧数组：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">example1.items = example1.items.filter(<span class="keyword">function</span> <span class="title"></span>(item) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">item.message.match(/Foo/)</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的、启发式的方法，所以用一个<strong>含有相同元素的数组</strong>去替换原来的数组是非常高效的操作。</p></blockquote><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>由于 JavaScript 的限制，Vue 不能检测通过以下方法变动的数组：</p><ol><li>利用索引直接设置一个项，例如：<code>vm.items[indexOfItem] = newValue</code></li><li>修改数组的长度，例如：<code>vm.items.length = newLength</code></li></ol><p>举个例子：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="type">Vue</span>(&#123;</span><br><span class="line">  data: <span class="type"></span>&#123;</span><br><span class="line">    items: <span class="type"></span>[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">vm.items[<span class="number">1</span>] = <span class="string">'x'</span>; <span class="comment">// 不是响应性的</span></span><br><span class="line">vm.items.length = <span class="number">2</span>; <span class="comment">// 不是响应性的</span></span><br></pre></td></tr></table></figure></p><h4 id="解决第一类问题"><a href="#解决第一类问题" class="headerlink" title="解决第一类问题"></a>解决第一类问题</h4><p>以下两种方式可以实现和 <code>vm.items[indexOfItem] = newValue</code> 相同的效果，同时也将触发状态更新：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue.set</span></span><br><span class="line">Vue.<span class="keyword">set</span>(vm.items, indexOfItem, <span class="keyword">new</span><span class="type">Value</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用 `vm.$set` 实例方法，该方法是全局方法 `Vue.set` 的一个别名：</span></span><br><span class="line">vm.$<span class="keyword">set</span>(vm.items, indexOfItem, <span class="keyword">new</span><span class="type">Value</span>);</span><br></pre></td></tr></table></figure></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array.prototype.splice</span></span><br><span class="line">vm.items.splice(indexOfItem, <span class="number">1</span>, <span class="keyword">new</span><span class="type">Value</span>);</span><br></pre></td></tr></table></figure><h4 id="解决第二类问题"><a href="#解决第二类问题" class="headerlink" title="解决第二类问题"></a>解决第二类问题</h4><p>使用 <code>splice</code>：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">vm</span><span class="selector-class">.items</span><span class="selector-class">.splice</span>(<span class="selector-tag">newLength</span>);</span><br></pre></td></tr></table></figure></p><h2 id="对象更新检测"><a href="#对象更新检测" class="headerlink" title="对象更新检测"></a>对象更新检测</h2><h4 id="问题一："><a href="#问题一：" class="headerlink" title="问题一："></a>问题一：</h4><p>由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="type">Vue</span>(&#123;</span><br><span class="line">  data: <span class="type"></span>&#123;</span><br><span class="line">    a: <span class="type">1</span></span><br><span class="line"><span class="type">  </span>&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// `vm.a` 现在是响应式的</span></span><br><span class="line"></span><br><span class="line">vm.b = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// `vm.b` 不是响应式的</span></span><br></pre></td></tr></table></figure></p><blockquote><p>对于已经创建的实例，Vue 不能动态添加根级别的响应式属性。</p></blockquote><p><strong>解决方案：</strong><br>使用 <code>Vue.set(object, key, value)</code> 方法向嵌套对象添加响应式属性。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> vm = <span class="literal">new</span> Vue(&#123;</span><br><span class="line">  <span class="built_in">data</span>: &#123;</span><br><span class="line">    userProfile: &#123;</span><br><span class="line">      name: <span class="string">'Anika'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加一个新的 age 属性到嵌套的 userProfile 对象：</span></span><br><span class="line">Vue.<span class="built_in">set</span>(vm.userProfile, <span class="string">'age'</span>, <span class="number">27</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//还可以使用 vm.$set 实例方法，它只是全局 Vue.set 的别名：</span></span><br><span class="line">vm.$set(vm.userProfile, <span class="string">'age'</span>, <span class="number">27</span>);</span><br></pre></td></tr></table></figure></p><h4 id="问题二："><a href="#问题二：" class="headerlink" title="问题二："></a>问题二：</h4><p>为已有对象赋予多个新属性，比如使用 <code>Object.assign()</code> 或 <code>_.extend()</code>。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Object</span><span class="selector-class">.assign</span>(vm.userProfile, &#123;</span><br><span class="line">  <span class="attribute">age</span>: <span class="number">27</span>,</span><br><span class="line">  <span class="attribute">favoriteColor</span>: <span class="string">'Vue Green'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//不起作用</span></span><br></pre></td></tr></table></figure></p><p><strong>解决方案：</strong><br>应该用两个对象的属性创建一个新的对象。<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vm.userProfile = Object.assign(&#123;&#125;, vm.userProfile, &#123;</span><br><span class="line">  age: <span class="number">27</span>,</span><br><span class="line">  favoriteColor: <span class="string">'Vue Green'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="显示过滤-排序结果"><a href="#显示过滤-排序结果" class="headerlink" title="显示过滤/排序结果"></a>显示过滤/排序结果</h2><p><strong>目的：</strong><br>显示一个数组的过滤或排序副本，而不实际改变或重置原始数据。</p><p><strong>解决方案一：</strong><br>创建返回过滤或排序数组的计算属性。</p><p>例如：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"n in evenNumbers"</span>&gt;</span></span><span class="template-variable">&#123;&#123; n &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">data</span>: &#123;</span><br><span class="line">  <span class="attribute">numbers</span>: [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="selector-tag">computed</span>: &#123;</span><br><span class="line">  <span class="attribute">evenNumbers</span>: function () &#123;</span><br><span class="line">    return this.numbers.<span class="built_in">filter</span>(function (number) &#123;</span><br><span class="line">      return number % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方案二：</strong><br>在计算属性不适用的情况下 (例如，在嵌套 <code>v-for</code> 循环中) 使用 <code>method</code> 方<br>法。<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"n in even(numbers)"</span>&gt;</span></span><span class="template-variable">&#123;&#123; n &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">data</span>: &#123;</span><br><span class="line">  <span class="attribute">numbers</span>: [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="selector-tag">methods</span>: &#123;</span><br><span class="line">  <span class="attribute">even</span>: function (numbers) &#123;</span><br><span class="line">    return numbers.<span class="built_in">filter</span>(function (number) &#123;</span><br><span class="line">      return number % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一段取值范围的-v-for"><a href="#一段取值范围的-v-for" class="headerlink" title="一段取值范围的 v-for"></a>一段取值范围的 v-for</h2><p>v-for 也可以取整数。在这种情况下，它将重复多次模板。<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">"n in 10"</span>&gt;</span></span><span class="template-variable">&#123;&#123; n &#125;&#125;</span><span class="xml"> <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p><strong>结果：</strong><br><img src="/2018/03/31/Vue学习/列表渲染/./6.png" alt="Alt text"></p><h2 id="使用-lt-template-gt-的-v-for"><a href="#使用-lt-template-gt-的-v-for" class="headerlink" title="使用 &lt;template&gt; 的 v-for"></a>使用 &lt;template&gt; 的 v-for</h2><p>可以利用带有 <code>v-fo</code>r 的 <code>&lt;template&gt;</code> 渲染多个元素。<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><span class="template-variable">&#123;&#123; item.msg &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"divider"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><h2 id="在-v-for-中使用-v-if"><a href="#在-v-for-中使用-v-if" class="headerlink" title="在 v-for 中使用 v-if"></a>在 v-for 中使用 v-if</h2><p>处于同一节点时，<code>v-for</code> 的优先级比 <code>v-if</code> 更高，这意味着 <code>v-if</code> 将分别重复运行于每个 <code>v-for</code> 循环中。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">li</span> v-<span class="keyword">for</span>=<span class="string">"todo in todos"</span> v-<span class="keyword">if</span>=<span class="string">"!todo.isComplete"</span>&gt;</span><br><span class="line">  &#123;&#123; todo &#125;&#125;</span><br><span class="line">&lt;/<span class="built_in">li</span>&gt;</span><br></pre></td></tr></table></figure></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>想要有条件地跳过循环的执行。</p><p><strong>解决方案：</strong><br>将 <code>v-if</code> 置于外层元素 (或 <code>&lt;template&gt;</code>)上。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">ul</span> v-<span class="keyword">if</span>=<span class="string">"todos.length"</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">li</span> v-<span class="keyword">for</span>=<span class="string">"todo in todos"</span>&gt;</span><br><span class="line">    &#123;&#123; todo &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;<span class="selector-tag">p</span> v-<span class="keyword">else</span>&gt;No todos <span class="attribute">left</span>!&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><h2 id="在组件中使用-v-for"><a href="#在组件中使用-v-for" class="headerlink" title="在组件中使用 v-for"></a>在组件中使用 v-for</h2><p>在自定义组件里，可以像任何普通元素一样用 <code>v-for</code> 。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">my</span>-component v-<span class="keyword">for</span>=<span class="string">"item in items"</span> :key=<span class="string">"item.id"</span>&gt; &lt;/<span class="keyword">my</span>-component&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p>2.2.0+ 的版本里，当在组件中使用 <code>v-for</code> 时，<code>key</code> 是必须的。</p></blockquote><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>任何数据都不会被自动传递到组件里，因为组件有自己独立的作用域。</p><p><strong>原因：</strong><br>不自动将 数据 注入到组件里的原因是，这会使得组件与 <code>v-for</code> 的运作紧密耦合。明确组件数据的来源能够使组件在其他场合重复使用。</p><p><strong>解决方案：</strong><br>用 <code>props</code> 把迭代数据传递到组件里。<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">my</span>-component</span><br><span class="line">  v-<span class="keyword">for</span>=<span class="string">"(item, index) in items"</span></span><br><span class="line">  v-<span class="keyword">bind</span>:item=<span class="string">"item"</span></span><br><span class="line">  v-<span class="keyword">bind</span>:<span class="keyword">index</span>=<span class="string">"index"</span></span><br><span class="line">  v-<span class="keyword">bind</span>:key=<span class="string">"item.id"</span></span><br><span class="line">&gt; &lt;<span class="regexp">/my-component&gt;</span></span><br></pre></td></tr></table></figure></p><p>下面是一个简单的 todo list 的<a href="https://codepen.io/Wonder233/pen/WzJNob" target="_blank" rel="noopener">完整例子</a>：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"todo-list-example"</span>&gt;</span><br><span class="line">  &lt;input</span><br><span class="line">    v-model=<span class="string">"newTodoText"</span></span><br><span class="line">    v-<span class="keyword">on</span>:keyup.enter=<span class="string">"addNewTodo"</span></span><br><span class="line">    placeholder=<span class="string">"Add a todo"</span></span><br><span class="line">  &gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li</span><br><span class="line">      <span class="keyword">is</span>=<span class="string">"todo-item"</span></span><br><span class="line">      v-<span class="keyword">for</span>=<span class="string">"(todo, index) in todos"</span></span><br><span class="line">      v-bind:key=<span class="string">"todo.id"</span></span><br><span class="line">      v-bind:title=<span class="string">"todo.title"</span></span><br><span class="line">      v-<span class="keyword">on</span>:remove=<span class="string">"todos.splice(index, 1)"</span></span><br><span class="line">    &gt;&lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p>注意这里的 <code>is=&quot;todo-item&quot;</code> 属性。这种做法在使用 DOM 模板时是十分必要的。<br><strong>原因：</strong><br>在 <code>&lt;ul&gt;</code> 元素内只有 <code>&lt;li&gt;</code> 元素会被看作有效内容。这样做实现的效果与 <code>&lt;todo-item&gt;</code> 相同，但是可以避开一些潜在的浏览器解析错误。<br>查看 <a href="https://cn.vuejs.org/v2/guide/components.html#DOM-%E6%A8%A1%E6%9D%BF%E8%A7%A3%E6%9E%90%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" target="_blank" rel="noopener">DOM 模板解析说明</a> 来了解更多信息。</p></blockquote><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'todo-item'</span>, &#123;</span><br><span class="line">  <span class="attribute">template</span>: <span class="string">'\</span></span><br><span class="line"><span class="string">    &lt;li&gt;\</span></span><br><span class="line"><span class="string">      &#123;&#123; title &#125;&#125;\</span></span><br><span class="line"><span class="string">      &lt;button v-on:click="$emit(\'remove\')"&gt;X&lt;/button&gt;\</span></span><br><span class="line"><span class="string">    &lt;/li&gt;\</span></span><br><span class="line"><span class="string">  '</span>,</span><br><span class="line">  <span class="attribute">props</span>: [<span class="string">'title'</span>]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attribute">el</span>: <span class="string">'#todo-list-example'</span>,</span><br><span class="line">  <span class="attribute">data</span>: &#123;</span><br><span class="line">    <span class="attribute">newTodoText</span>: <span class="string">''</span>,</span><br><span class="line">    <span class="attribute">todos</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attribute">id:</span><span class="string"> 1,</span></span><br><span class="line"><span class="string">        title</span>: <span class="string">'Do the dishes'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attribute">id:</span><span class="string"> 2,</span></span><br><span class="line"><span class="string">        title</span>: <span class="string">'Take out the trash'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attribute">id:</span><span class="string"> 3,</span></span><br><span class="line"><span class="string">        title</span>: <span class="string">'Mow the lawn'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attribute">nextTodoId</span>: <span class="number">4</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attribute">methods</span>: &#123;</span><br><span class="line">    <span class="attribute">addNewTodo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.todos.push(&#123;</span><br><span class="line">        <span class="attribute">id:</span><span class="string"> this.nextTodoId</span>++,</span><br><span class="line">        <span class="attribute">title</span>: <span class="keyword">this</span>.newTodoText</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">this</span>.newTodoText = <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Vue学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>条件渲染</title>
      <link href="/2018/03/31/Vue%E5%AD%A6%E4%B9%A0/%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/"/>
      <url>/2018/03/31/Vue%E5%AD%A6%E4%B9%A0/%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/</url>
      <content type="html"><![CDATA[<h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">h1</span> v-<span class="keyword">if</span>=<span class="string">"ok"</span>&gt;Yes&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>也可以用 <code>v-else</code> 添加一个“else 块”：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">h1</span> v-<span class="keyword">if</span>=<span class="string">"ok"</span>&gt;Yes&lt;/h1&gt;</span><br><span class="line">&lt;<span class="selector-tag">h1</span> v-<span class="keyword">else</span>&gt;No&lt;/h1&gt;</span><br></pre></td></tr></table></figure></p><h3 id="在-lt-template-gt-元素上使用-v-if-条件渲染分组"><a href="#在-lt-template-gt-元素上使用-v-if-条件渲染分组" class="headerlink" title="在 &lt; template &gt; 元素上使用 v-if 条件渲染分组"></a>在 &lt; template &gt; 元素上使用 <code>v-if</code> 条件渲染分组</h3><blockquote><p><code>v-if</code> 是一个指令，必须将它添加到一个元素上。</p></blockquote><p>可以把一个 <code>&lt;template&gt;</code> 元素当做不可见的包裹元素，并在上面使用 <code>v-if</code>。最终的渲染结果将不包含 <code>&lt;template&gt;</code> 元素。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"ok"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a>v-else</h3><p>使用 <code>v-else</code> 指令来表示 <code>v-if</code> 的“else 块”：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> v-<span class="keyword">if</span>=<span class="string">"Math.random() &gt; 0.5"</span>&gt;</span><br><span class="line">  Now you see <span class="keyword">me</span></span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;<span class="keyword">div</span> v-<span class="keyword">else</span>&gt;</span><br><span class="line">  Now you don't</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p><code>v-else</code> 元素必须紧跟在带 <code>v-if</code> 或者 <code>v-else-if</code> 的元素的后面，否则它将不会被识别。</p></blockquote><h3 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a>v-else-if</h3><blockquote><p>2.1.0 新增</p></blockquote><p><code>v-else-if</code>，充当 <code>v-if</code> 的“else-if 块”，可以连续使用：<br><figure class="highlight cal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> v-<span class="keyword">if</span>=<span class="string">"type === 'A'"</span>&gt;</span><br><span class="line">  A</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;<span class="keyword">div</span> v-<span class="keyword">else</span>-<span class="keyword">if</span>=<span class="string">"type === 'B'"</span>&gt;</span><br><span class="line">  B</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;<span class="keyword">div</span> v-<span class="keyword">else</span>-<span class="keyword">if</span>=<span class="string">"type === 'C'"</span>&gt;</span><br><span class="line">  C</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;<span class="keyword">div</span> v-<span class="keyword">else</span>&gt;</span><br><span class="line">  <span class="keyword">Not</span> A/B/C</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p><code>v-else-if</code> 必须紧跟在带 <code>v-if</code> 或者 <code>v-else-if</code> 的元素之后。</p></blockquote><h3 id="用-key-管理可复用的元素"><a href="#用-key-管理可复用的元素" class="headerlink" title="用 key 管理可复用的元素"></a>用 <code>key</code> 管理可复用的元素</h3><p>Vue 会尽可能高效地渲染元素，通常会<strong>复用已有元素</strong>而不是从头开始渲染。</p><p>例如，如果你允许用户在不同的登录方式之间切换：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-<span class="keyword">if</span>=<span class="string">"loginType === 'username'"</span>&gt;</span><br><span class="line">  &lt;label&gt;Username&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">  &lt;input placeholder="Enter your username"&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;template v-<span class="keyword">else</span>&gt;</span><br><span class="line">  &lt;label&gt;Email&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">  &lt;input placeholder="Enter your email address"&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br></pre></td></tr></table></figure></p><p>那么在上面的代码中切换 <code>loginType</code> 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，<code>&lt;input&gt;</code> 不会被替换掉——仅仅是替换了它的 <code>placeholder</code>。</p><p>如果不想有这种复用的效果，只需添加一个具有唯一值的 <code>key</code> 属性即可：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-<span class="keyword">if</span>=<span class="string">"loginType === 'username'"</span>&gt;</span><br><span class="line">  &lt;label&gt;Username&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">  &lt;input placeholder="Enter your username" key="username-input"&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;template v-<span class="keyword">else</span>&gt;</span><br><span class="line">  &lt;label&gt;Email&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">  &lt;input placeholder="Enter your email address" key="email-input"&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br></pre></td></tr></table></figure></p><p>现在，每次切换时，输入框都将被重新渲染。</p><blockquote><p>注意，<code>&lt;label&gt;</code> 元素仍然会被高效地复用，因为它们没有添加 <code>key</code> 属性。</p></blockquote><h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">"ok"</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>带有 <code>v-show</code> 的元素<strong>始终会被渲染并保留在 DOM</strong> 中。<code>v-show</code> 只是简单地切换元素的 CSS 属性 <code>display</code>。</p><blockquote><p>注意，<code>v-show</code> 不支持 <code>&lt;template&gt;</code> 元素，也不支持 <code>v-else</code>。</p></blockquote><h2 id="v-if-vs-v-show"><a href="#v-if-vs-v-show" class="headerlink" title="v-if vs v-show"></a><code>v-if</code> vs <code>v-show</code></h2><p><code>v-if</code> ：</p><ul><li>是“真正”的条件渲染：它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</li><li>“惰性的”：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</li></ul><p><code>v-show</code> ：不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p><blockquote><p>v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。<br>因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。</p></blockquote><h2 id="v-if-与-v-for-一起使用"><a href="#v-if-与-v-for-一起使用" class="headerlink" title="v-if 与 v-for 一起使用"></a><code>v-if</code> 与 <code>v-for</code> 一起使用</h2><p>当 <code>v-if</code> 与 <code>v-for</code> 一起使用时，<code>v-for</code> 具有比 <code>v-if</code> 更高的优先级。</p>]]></content>
      
      <categories>
          
          <category> Vue学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Class与Style绑定</title>
      <link href="/2018/03/31/Vue%E5%AD%A6%E4%B9%A0/Class%E4%B8%8EStyle%E7%BB%91%E5%AE%9A/"/>
      <url>/2018/03/31/Vue%E5%AD%A6%E4%B9%A0/Class%E4%B8%8EStyle%E7%BB%91%E5%AE%9A/</url>
      <content type="html"><![CDATA[<h2 id="绑定-HTML-Class"><a href="#绑定-HTML-Class" class="headerlink" title="绑定 HTML Class"></a>绑定 HTML Class</h2><h3 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h3><p>（1）<strong>内联</strong>传给 <code>v-bind:class</code>一个对象，以动态地切换 <code>class</code>：<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"</span></span></span><span class="template-variable">&#123; active: isActive &#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- active 这个 class 存在与否取决于变量 isActive 为 truthy(真值) --&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"static"</span> <span class="attr">v-bind:class</span>=<span class="string">"</span></span></span><span class="template-variable">&#123; active: isActive, 'text-danger': hasError &#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">data:</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">  isActive:</span> <span class="literal">false</span><span class="string">,</span></span><br><span class="line"><span class="attr">  hasError:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>结果渲染为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"static text-danger"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>（2）给 <code>v-bind:class</code>绑定一个<strong>数据对象</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"classObject"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">data:</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">  classObject:</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    active:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">    'text-danger':</span> <span class="literal">false</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>（3）给 <code>v-bind:class</code>绑定一个<strong>返回对象的计算属性</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"classObject"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span>: &#123;</span><br><span class="line">  isActive: <span class="literal">true</span>,</span><br><span class="line">  error: <span class="literal">null</span></span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  classObject: function () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      active: <span class="keyword">this</span>.isActive &amp;&amp; !<span class="keyword">this</span>.error,</span><br><span class="line">      <span class="string">'text-danger'</span>: <span class="keyword">this</span>.error &amp;&amp; <span class="keyword">this</span>.error.type === <span class="string">'fatal'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a>数组语法</h3><p>（1）把一个数组传给 <code>v-bind:class</code>，以应用一个 <code>class</code> 列表：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"[activeClass, errorClass]"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">data</span>: &#123;</span><br><span class="line">  <span class="attribute">activeClass</span>: <span class="string">'active'</span>,</span><br><span class="line">  errorClass: <span class="string">'text-danger'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"active text-danger"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>（2）用<strong>三元表达式</strong>根据条件切换列表中的 <code>class</code>：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[isActive ? activeClass : '', errorClass]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 将始终添加 errorClass，只有在 isActive 为 truthy(真值) 时才添加 activeClass。 --&gt;</span></span><br></pre></td></tr></table></figure></p><p>（3）在数组语法中使用对象语法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"[&#123; active: isActive &#125;, errorClass]"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><h3 id="用在组件上"><a href="#用在组件上" class="headerlink" title="用在组件上"></a>用在组件上</h3><p>当在一个自定义组件上使用 <code>class</code> 属性时：</p><ol><li>这些类将被添加到该组件的根元素上面。</li><li>这个元素上已经存在的类不会被覆盖。</li></ol><p>例如，如果你声明了这个组件：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Vue</span>.component(<span class="symbol">'my</span>-component', &#123;</span><br><span class="line">  template: '&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"foo bar"</span>&gt;<span class="type">Hi</span>&lt;/p&gt;'</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>然后在使用它的时候添加一些 <code>class</code>：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">my</span>-component <span class="built_in">class</span>=<span class="string">"baz boo"</span>&gt;&lt;/<span class="keyword">my</span>-component&gt;</span><br></pre></td></tr></table></figure></p><p>HTML 将被渲染为：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"foo bar baz boo"</span>&gt;</span>Hi<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>对于带数据绑定 class 也同样适用：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">my</span>-component v-bind:<span class="built_in">class</span>=<span class="string">"&#123; active: isActive &#125;"</span>&gt;&lt;/<span class="keyword">my</span>-component&gt;</span><br></pre></td></tr></table></figure></p><p>当 <code>isActive</code> 为 <code>true</code> 时，HTML 将被渲染成为：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"foo bar active"</span>&gt;</span>Hi<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="绑定内联样式"><a href="#绑定内联样式" class="headerlink" title="绑定内联样式"></a>绑定内联样式</h2><h3 id="对象语法-1"><a href="#对象语法-1" class="headerlink" title="对象语法"></a>对象语法</h3><p>（1）<strong>内联</strong>传给 <code>v-bind:style</code>一个 JavaScript 对象，以动态地切换 <code>style</code>：</p><p>CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用单引号括起来) 来命名：<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"</span></span></span><span class="template-variable">&#123; color: activeColor, fontSize: fontSize + 'px' &#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">data</span>: &#123;</span><br><span class="line">  <span class="attribute">activeColor</span>: <span class="string">'red'</span>,</span><br><span class="line">  fontSize: <span class="number">30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）给 <code>v-bind:style</code>绑定一个<strong>样式对象</strong>：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> v-<span class="keyword">bind</span>:style=<span class="string">"styleObject"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">data</span>: &#123;</span><br><span class="line">  <span class="attribute">styleObject</span>: &#123;</span><br><span class="line">    color: <span class="string">'red'</span>,</span><br><span class="line">    fontSize: <span class="string">'13px'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）给 <code>v-bind:class</code> 绑定一个<strong>返回对象的计算属性</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"classObject"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span>: &#123;</span><br><span class="line">  color: <span class="string">'red'</span>,</span><br><span class="line">  size1: <span class="number">8</span>,</span><br><span class="line">  size2: <span class="number">5</span></span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  classObject: function () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      color: <span class="keyword">this</span>.color,</span><br><span class="line">      fontSize: <span class="keyword">this</span>.size1 + <span class="keyword">this</span>.size2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组语法-1"><a href="#数组语法-1" class="headerlink" title="数组语法"></a>数组语法</h3><p>将多个样式对象应用到同一个元素上：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> v-<span class="keyword">bind</span>:style=<span class="string">"[baseStyles, overridingStyles]"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">data</span>: &#123;</span><br><span class="line">  <span class="attribute">baseStyles</span>: &#123;</span><br><span class="line">  background: <span class="string">'red'</span>,</span><br><span class="line">      border:<span class="string">'1px solid'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="selector-tag">overridingStyles</span>: &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="string">'100px'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动添加前缀"><a href="#自动添加前缀" class="headerlink" title="自动添加前缀"></a>自动添加前缀</h3><p>当 <code>v-bind:style</code> 使用需要添加<strong>浏览器引擎前缀</strong>的 CSS 属性时，如 <code>transform</code>，Vue.js 会自动侦测并添加相应的前缀。</p><h3 id="多重值"><a href="#多重值" class="headerlink" title="多重值"></a>多重值</h3><blockquote><p>2.3.0+</p></blockquote><p>从 2.3.0 起你可以为 style 绑定中的属性提供一个包含多个值的数组，常用于提供多个带前缀的值，例如：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="symbol">:style=<span class="string">"&#123; display: ['-webkit-box', '-ms-flexbox', 'flex'] &#125;"</span>&gt;&lt;/div&gt;</span></span><br></pre></td></tr></table></figure></p><p>这样写只会渲染数组中最后一个被浏览器支持的值。在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 display: flex。</p><p>[1] truthy 不是 true，详见 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy" target="_blank" rel="noopener">MDN</a> 的解释。</p>]]></content>
      
      <categories>
          
          <category> Vue学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>模板语法</title>
      <link href="/2018/03/30/Vue%E5%AD%A6%E4%B9%A0/%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/"/>
      <url>/2018/03/30/Vue%E5%AD%A6%E4%B9%A0/%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>Vue.js 使用了<strong>基于 HTML 的模板语法</strong>，允许开发者声明式地<strong>将 DOM 绑定至底层 Vue 实例的数据</strong>。所有 Vue.js 的模板都是合法的 HTML ，所以能被遵循规范的浏览器和 HTML 解析器解析。</p><hr><p>在底层的实现上，Vue 将模板编译成<strong>虚拟 DOM 渲染函数</strong>。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。</p><h2 id="插值——数据绑定"><a href="#插值——数据绑定" class="headerlink" title="插值——数据绑定"></a>插值——数据绑定</h2><h3 id="文本-——双大括号-123-123-125-125"><a href="#文本-——双大括号-123-123-125-125" class="headerlink" title="文本 ——双大括号&#123;&#123;&#125;&#125;"></a>文本 ——双大括号&#123;&#123;&#125;&#125;</h3><ol><li>数据绑定最常见的形式就是使用<strong>“Mustache”语法 (双大括号)</strong> 的文本插值：<figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Message: </span><span class="template-variable">&#123;&#123; msg &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ol><p>Mustache 标签将会被替代为对应数据对象上 msg 属性的值。无论何时，绑定的数据对象上 msg 属性发生了改变，插值处的内容都会更新。</p><ol start="2"><li>通过使用 <strong>v-once</strong> 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定：<figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-once</span>&gt;</span>这个将不会改变: </span><span class="template-variable">&#123;&#123; msg &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ol><h3 id="原始-HTML——v-html"><a href="#原始-HTML——v-html" class="headerlink" title="原始 HTML——v-html"></a>原始 HTML——v-html</h3><p>双大括号会将数据解释为普通文本，而非 HTML 代码。<br>为了输出真正的 HTML，你需要使用 v-html 指令：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using mustaches: </span><span class="template-variable">&#123;&#123; rawHtml &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using v-html directive: <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">"rawHtml"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p><img src="/2018/03/30/Vue学习/模板语法/./1.png" alt="Alt text"><br>这个 span 的内容将会被替换成为属性值 rawHtml，直接作为 HTML——<strong>会忽略解析属性值中的数据绑定</strong>。</p><blockquote><p>不能使用 v-html 来复合局部模板，因为 Vue 不是基于字符串的模板引擎。</p></blockquote><h3 id="绑定-HTML-属性——v-bind"><a href="#绑定-HTML-属性——v-bind" class="headerlink" title="绑定 HTML 属性——v-bind"></a>绑定 HTML 属性——v-bind</h3><p>双大括号语法&#123;&#123;&#125;&#125;不能作用在 HTML 特性上，此时应该使用 v-bind 指令：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> v-bind:<span class="built_in">id</span>=<span class="string">"dynamicId"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p><blockquote><p>注意：上面的 dynamicId 是一个变量。</p></blockquote><p>在布尔特性的情况下，它们的存在即暗示为 true，v-bind 工作起来略有不同：<br><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">button</span> v-bind:disabled=<span class="string">"isButtonDisabled"</span>&gt;<span class="keyword">Button</span>&lt;/<span class="keyword">button</span>&gt;</span><br></pre></td></tr></table></figure></p><p>如果 isButtonDisabled 的值是 null、undefined 或 false，则 disabled 特性甚至不会被包含在渲染出来的 &lt; button &gt; 元素中。</p><h3 id="使用-JavaScript-表达式"><a href="#使用-JavaScript-表达式" class="headerlink" title="使用 JavaScript 表达式"></a>使用 JavaScript 表达式</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; number + <span class="number">1</span> &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; ok ? <span class="string">'YES'</span> : <span class="string">'NO'</span> &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>) &#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;div v-bind:id=<span class="string">"'list-' + id"</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。</p><p><strong>限制：</strong><br>每个绑定都只能包含<strong>单个表达式</strong>。<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- 以下例子都将不会生效 --&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 这是语句，不是表达式 --&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-variable">&#123;&#123; var a = 1 &#125;</span><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-variable">&#123;&#123; <span class="keyword">if</span> (ok) &#123; return message &#125;</span><span class="xml"> &#125;&#125;</span></span><br></pre></td></tr></table></figure></p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><ol><li>指令 (Directives) 是带有 v- 前缀的特殊属性。</li><li>指令属性的值预期是单个 JavaScript 表达式（v-for 是例外情况）。</li><li>指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。</li></ol><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>一些指令能够接收一个“参数”，在指令名称之后以冒号表示。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- v-bind 指令可以用于响应式地更新 HTML 属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- v-on 指令用于监听 DOM 事件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">"doSomething"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>修饰符 (Modifiers) 是以<strong>半角句号 .</strong> 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- .prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault() --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"onSubmit"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h2><p>Vue.js 为 v-bind 和 v-on 这两个最常用的指令，提供了特定简写：</p><h3 id="v-bind-缩写"><a href="#v-bind-缩写" class="headerlink" title="v-bind 缩写"></a>v-bind 缩写</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-on-缩写"><a href="#v-on-缩写" class="headerlink" title="v-on 缩写"></a>v-on 缩写</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">"doSomething"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">"doSomething"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Vue学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算属性和侦听器</title>
      <link href="/2018/03/30/Vue%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%99%A8/"/>
      <url>/2018/03/30/Vue%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%99%A8/</url>
      <content type="html"><![CDATA[<h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>对于任何复杂逻辑，应当使用计算属性。</p><h3 id="基础例子"><a href="#基础例子" class="headerlink" title="基础例子"></a>基础例子</h3><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Original message: "</span><span class="template-variable">&#123;&#123; message &#125;&#125;</span><span class="xml">"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Computed reversed message: "</span><span class="template-variable">&#123;&#123; reversedMessage &#125;&#125;</span><span class="xml">"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="keyword">e</span><span class="variable">l:</span> <span class="string">'#example'</span>,</span><br><span class="line">  dat<span class="variable">a:</span> &#123;</span><br><span class="line">    message: <span class="string">'Hello'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    // 计算属性的 getter</span><br><span class="line">    reversedMessage: <span class="function"><span class="keyword">function</span> <span class="params">()</span> &#123;</span></span><br><span class="line">      // `this` 指向 <span class="keyword">vm</span> 实例</span><br><span class="line">      <span class="keyword">return</span> this.message.<span class="keyword">split</span>(<span class="string">''</span>).<span class="built_in">reverse</span>().<span class="keyword">join</span>(<span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>结果：</strong><br>Original message: “Hello”<br>Computed reversed message: “olleH”</p><p>这里声明了一个计算属性 reversedMessage。提供的函数将用作属性 vm.reversedMessage 的 getter 函数：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="keyword">vm</span>.reversedMessage) // =&gt; <span class="string">'olleH'</span></span><br><span class="line"><span class="keyword">vm</span>.message = <span class="string">'Goodbye'</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">vm</span>.reversedMessage) // =&gt; <span class="string">'eybdooG'</span></span><br></pre></td></tr></table></figure></p><p>Vue 知道 vm.reversedMessage 依赖于 vm.message，因此当 vm.message 发生改变时，所有依赖 vm.reversedMessage 的绑定也会更新。</p><blockquote><p>可以像绑定普通属性一样在模板中绑定计算属性。</p></blockquote><h3 id="计算属性缓存-vs-方法"><a href="#计算属性缓存-vs-方法" class="headerlink" title="计算属性缓存 vs 方法"></a>计算属性缓存 vs 方法</h3><p>上面的例子可以通过在表达式中调用方法来达到同样的效果：<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Reversed message: "</span><span class="template-variable">&#123;&#123; reversedMessage() &#125;&#125;</span><span class="xml">"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 在组件中</span><br><span class="line">method<span class="variable">s:</span> &#123;</span><br><span class="line">  reversedMessage: <span class="function"><span class="keyword">function</span> <span class="params">()</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> this.message.<span class="keyword">split</span>(<span class="string">''</span>).<span class="built_in">reverse</span>().<span class="keyword">join</span>(<span class="string">''</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>相同点：</strong><br>可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。<br><strong>不同点：</strong><br>计算属性是<strong>基于它们的依赖进行缓存的</strong>。计算属性只有在它的相关依赖发生改变时才会重新求值。</p><ul><li>这意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。</li><li>而每当触发重新渲染时，调用方法将总会再次执行函数。</li></ul><h3 id="计算属性-vs-侦听属性"><a href="#计算属性-vs-侦听属性" class="headerlink" title="计算属性 vs 侦听属性"></a>计算属性 vs 侦听属性</h3><p>Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：<strong>侦听属性。</strong></p><p>当你有一些数据需要随着其它数据变动而变动时，通常更好的做法是使用计算属性而不是命令式的 watch 回调。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"demo"</span>&gt;&#123;&#123; fullName &#125;&#125;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = new Vue(&#123;</span><br><span class="line">  el: <span class="string">'#demo'</span>,</span><br><span class="line">  <span class="keyword">data</span>: &#123;</span><br><span class="line">    firstName: <span class="string">'Foo'</span>,</span><br><span class="line">    lastName: <span class="string">'Bar'</span>,</span><br><span class="line">    fullName: <span class="string">'Foo Bar'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    firstName: function (<span class="keyword">val</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.fullName = <span class="keyword">val</span> + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    lastName: function (<span class="keyword">val</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.fullName = <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">val</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码是命令式且重复的。将它与计算属性的版本进行比较：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#demo'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Foo'</span>,</span><br><span class="line">    lastName: <span class="string">'Bar'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    fullName: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="计算属性的-setter"><a href="#计算属性的-setter" class="headerlink" title="计算属性的 setter"></a>计算属性的 setter</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    <span class="keyword">get</span>: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    <span class="keyword">set</span>: <span class="function"><span class="keyword">function</span> <span class="params">(newValue)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> names = newValue.split(<span class="string">' '</span>)</span><br><span class="line">      <span class="keyword">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>运行 vm.fullName = ‘John Doe’ 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。</p><h2 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h2><p>当需要在数据变化时执行<strong>异步或开销较大的操作</strong>时，Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。<br><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"watch-example"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    Ask a yes/no question:</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"question"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="template-variable">&#123;&#123; answer &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> watchExampleVM = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">  el: <span class="string">'#watch-example'</span>,</span></span><br><span class="line"><span class="undefined">  data: &#123;</span></span><br><span class="line"><span class="actionscript">    question: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">    answer: <span class="string">'I cannot give you an answer until you ask a question!'</span></span></span><br><span class="line"><span class="undefined">  &#125;,</span></span><br><span class="line"><span class="undefined">  watch: &#123;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 如果 `question` 发生改变，这个函数就会运行</span></span></span><br><span class="line"><span class="actionscript">    question: <span class="function"><span class="keyword">function</span> <span class="params">(newQuestion, oldQuestion)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.answer = <span class="string">'Waiting for you to stop typing...'</span></span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.getAnswer()</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;,</span></span><br><span class="line"><span class="undefined">  methods: &#123;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// `_.debounce` 是一个通过 Lodash 限制操作频率的函数。</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// AJAX 请求直到用户输入完毕才会发出。想要了解更多关于</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 请参考：https://lodash.com/docs#debounce</span></span></span><br><span class="line"><span class="undefined">    getAnswer: _.debounce(</span></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">if</span> (<span class="keyword">this</span>.question.indexOf(<span class="string">'?'</span>) === <span class="number">-1</span>) &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.answer = <span class="string">'Questions usually contain a question mark. ;-)'</span></span></span><br><span class="line"><span class="actionscript">          <span class="keyword">return</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.answer = <span class="string">'Thinking...'</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> vm = <span class="keyword">this</span></span></span><br><span class="line"><span class="actionscript">        axios.get(<span class="string">'https://yesno.wtf/api'</span>)</span></span><br><span class="line"><span class="actionscript">          .then(<span class="function"><span class="keyword">function</span> <span class="params">(response)</span> </span>&#123;</span></span><br><span class="line"><span class="undefined">            vm.answer = _.capitalize(response.data.answer)</span></span><br><span class="line"><span class="undefined">          &#125;)</span></span><br><span class="line"><span class="actionscript">          .catch(<span class="function"><span class="keyword">function</span> <span class="params">(error)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            vm.answer = <span class="string">'Error! Could not reach the API. '</span> + error</span></span><br><span class="line"><span class="undefined">          &#125;)</span></span><br><span class="line"><span class="undefined">      &#125;,</span></span><br><span class="line"><span class="actionscript">      <span class="comment">// 这是我们为判定用户停止输入等待的毫秒数</span></span></span><br><span class="line"><span class="undefined">      500</span></span><br><span class="line"><span class="undefined">    )</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>结果：</strong><br><img src="/2018/03/30/Vue学习/计算属性和侦听器/./1.png" alt="Alt text"></p><p>使用 watch 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p><p>除了 watch 选项之外，还可以使用命令式的 <a href="https://cn.vuejs.org/v2/api/#vm-watch" target="_blank" rel="noopener">vm.$watch API</a>。</p>]]></content>
      
      <categories>
          
          <category> Vue学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTTPS 介绍</title>
      <link href="/2018/03/30/HTTP/HTTPS-%E4%BB%8B%E7%BB%8D/"/>
      <url>/2018/03/30/HTTP/HTTPS-%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h2 id="HTTPS-概述"><a href="#HTTPS-概述" class="headerlink" title="HTTPS 概述"></a>HTTPS 概述</h2><p>HTTPS 由两部分组成：HTTP + SSL / TLS，即在 HTTP 上又加了一层处理加密信息的模块。<br>服务端和客户端的信息传输都会通过 TLS 进行加密，所以传输的数据都是加密后的数据。</p><p><img src="/2018/03/30/HTTP/HTTPS-介绍/./1.png" alt="HTTP 与 HTTPS 对比"><br>HTTP 安全层通过 SSL 及其现代替代协议 TLS 实现的。</p><h2 id="HTTPS-原理"><a href="#HTTPS-原理" class="headerlink" title="HTTPS 原理"></a>HTTPS 原理</h2><h3 id="1-客户端发起HTTPS请求"><a href="#1-客户端发起HTTPS请求" class="headerlink" title="1. 客户端发起HTTPS请求"></a>1. 客户端发起HTTPS请求</h3><p>客户端首先建立一条到 Web 服务器端口 443 的连接。（进行TCP 三次握手）</p><h3 id="2-服务端的配置"><a href="#2-服务端的配置" class="headerlink" title="2. 服务端的配置"></a>2. 服务端的配置</h3><p>采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。<br><strong>区别：</strong></p><ul><li>自己颁发的证书需要客户端验证通过，才可以继续访问，</li><li>使用受信任的公司申请的证书则不会弹出提示页面。</li></ul><blockquote><p>这套证书其实是一对公钥和私钥。<br><strong>理解：</strong><br>可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</p></blockquote><h3 id="3-传送证书"><a href="#3-传送证书" class="headerlink" title="3. 传送证书"></a>3. 传送证书</h3><p>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。</p><h3 id="4-客户端解析证书"><a href="#4-客户端解析证书" class="headerlink" title="4. 客户端解析证书"></a>4. 客户端解析证书</h3><p>由客户端的 TLS 来完成：</p><ul><li>首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。</li><li>如果证书没有问题，那么就生成一个随即值。然后用证书对该随机值进行加密。</li></ul><h3 id="5-传送加密信息"><a href="#5-传送加密信息" class="headerlink" title="5. 传送加密信息"></a>5. 传送加密信息</h3><p>客户端传输用证书加密后的随机值。<br><strong>目的：</strong></p><ul><li>让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</li></ul><h3 id="6-服务端解密信息"><a href="#6-服务端解密信息" class="headerlink" title="6. 服务端解密信息"></a>6. 服务端解密信息</h3><p>服务端用私钥解密后，得到了客户端传过来的随机值（私钥），然后把内容通过该值进行对称加密。</p><blockquote><p><strong>对称加密：</strong><br>将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</p></blockquote><h3 id="7-传输加密后的信息"><a href="#7-传输加密后的信息" class="headerlink" title="7. 传输加密后的信息"></a>7. 传输加密后的信息</h3><p>服务端传输用私钥加密后的信息，可以在客户端被还原。</p><h3 id="8-客户端解密信息"><a href="#8-客户端解密信息" class="headerlink" title="8. 客户端解密信息"></a>8. 客户端解密信息</h3><p>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。</p><h2 id="HTTPS的优点"><a href="#HTTPS的优点" class="headerlink" title="HTTPS的优点"></a>HTTPS的优点</h2><h3 id="1-SEO方面"><a href="#1-SEO方面" class="headerlink" title="1.SEO方面"></a>1.SEO方面</h3><p>谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</p><h3 id="2-安全性"><a href="#2-安全性" class="headerlink" title="2.安全性"></a>2.安全性</h3><p>尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处：</p><ol><li><p>使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</p></li><li><p>HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</p></li><li><p>HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p></li></ol><h2 id="HTTPS的缺点"><a href="#HTTPS的缺点" class="headerlink" title="HTTPS的缺点"></a>HTTPS的缺点</h2><h3 id="1-SEO方面-1"><a href="#1-SEO方面-1" class="headerlink" title="1.SEO方面"></a>1.SEO方面</h3><ol><li><p>加载时间延长，耗电增加</p><blockquote><p>据ACM CoNEXT数据显示，使用 HTTPS 协议会使页面的加载时间延长近 50%，增加 10% 到 20% 的耗电。</p></blockquote></li><li><p>影响缓存，增加数据开销和功耗。</p></li><li><p>加密范围也比较有限</p><blockquote><p>在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。</p></blockquote></li><li><p>SSL证书的信用链体系并不安全。</p><blockquote><p>特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</p></blockquote></li></ol><h3 id="2-经济方面"><a href="#2-经济方面" class="headerlink" title="2.经济方面"></a>2.经济方面</h3><ol><li><p>SSL 证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</p></li><li><p>SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗（SSL 有扩展可以部分解决这个问题，但是比较麻烦，而且要求浏览器、操作系统支持，Windows XP 就不支持这个扩展，考虑到 XP 的装机量，这个特性几乎没用）。</p></li><li><p>HTTPS 连接缓存不如 HTTP 高效，大流量网站如非必要也不会采用，流量成本太高。</p></li><li><p>HTTPS 连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本，如果全部采用 HTTPS，基于大部分计算资源闲置的假设的 VPS 的平均成本会上去。</p></li><li><p>HTTPS 协议握手阶段比较费时，对网站的相应速度有负面影响，如非必要，没有理由牺牲用户体验。</p></li></ol><h2 id="HTTPS和HTTP的区别"><a href="#HTTPS和HTTP的区别" class="headerlink" title="HTTPS和HTTP的区别"></a>HTTPS和HTTP的区别</h2><ol><li>HTTPS 协议需要申请证书，一般免费证书较少，因而需要一定费用。</li><li>HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。</li><li>HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>HTTP 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</li></ol>]]></content>
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第一章 块级绑定</title>
      <link href="/2018/03/30/LearnES6/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%9D%97%E7%BA%A7%E7%BB%91%E5%AE%9A/"/>
      <url>/2018/03/30/LearnES6/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%9D%97%E7%BA%A7%E7%BB%91%E5%AE%9A/</url>
      <content type="html"><![CDATA[<h2 id="var-声明与变量提升"><a href="#var-声明与变量提升" class="headerlink" title="var 声明与变量提升"></a>var 声明与变量提升</h2><p><strong>变量提升（ hoisting ）：</strong>使用 var 关键字声明的变量，无论其实际声明位置在何处，都会被视为声明于所在函数的顶部（如果声明不在任意函数内，则视为在全局作用域的顶部）。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span><span class="params">(condition)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line"><span class="keyword">var</span> value = <span class="string">"blue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// value 在此处可访问，值为 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// value 在此处可访问，值为 undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>JS 引擎会将 getValue 函数调整为如下形式：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">getValue</span>(<span class="params">condition</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        <span class="keyword">value</span> = <span class="string">"blue"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其他代码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="块级声明"><a href="#块级声明" class="headerlink" title="块级声明"></a>块级声明</h2><p><strong>块级声明</strong>：让所声明的变量在指定块的作用域外无法被访问。</p><p>块级作用域（又被称为词法作用域）在如下情况被创建：</p><ol><li>在一个函数内部</li><li>在一个由一对花括号包裹的代码块内部</li></ol><h3 id="let-声明"><a href="#let-声明" class="headerlink" title="let 声明"></a>let 声明</h3><p>大体上可以直接用 let 代替 var 进行变量声明，但会将变量的作用域限制在当前代码块中。</p><blockquote><p>由于 let 声明并不会被提升，因此若想让变量在整个代码块内部可用，需要手动将 let 声明放置到代码块顶部。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">getValue</span>(<span class="params">condition</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">value</span> = <span class="string">"blue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// value 在此处不可用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// value 在此处不可用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>在 condition 的值为 false 时，该变量永远不会被声明并初始化。</p><h4 id="禁止重复声明"><a href="#禁止重复声明" class="headerlink" title="禁止重复声明"></a>禁止重复声明</h4><p>如果一个标识符已经在代码块内部被定义，那么在此代码块内使用同一个标识符进行 let 声明就会导致错误。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法错误</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">count</span> = <span class="number">40</span>;</span><br></pre></td></tr></table></figure></p><p>在嵌套的作用域内使用 let 声明一个同名新变量，就不会有问题。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不会抛出错误</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">count</span> = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>原因：</strong><br>不是在同一作用域级别再次创建 count 变量，而是在 if 语句内部创建新变量。在 if 代码块内部，这个新变量会屏蔽全局的 count 变量，从而在局部阻止对于后者的访问。</p><h3 id="常量声明"><a href="#常量声明" class="headerlink" title="常量声明"></a>常量声明</h3><p>使用 const 声明的变量会被认为是常量（ constant ），值在被设置完成后就不允许再被更改。</p><blockquote><p>所有的 const 变量都需要在声明时进行初始化。<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有效的常量</span></span><br><span class="line"><span class="keyword">const</span> maxItems = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法错误：未进行初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="常量声明与-let-声明对比"><a href="#常量声明与-let-声明对比" class="headerlink" title="常量声明与 let 声明对比"></a>常量声明与 let 声明对比</h4><p><strong>相似点：</strong></p><ol><li><p>常量声明与 let 声明一样，都是块级声明。常量在声明它们的语句块之外是无法被访问的，并且声明也不会被提升。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line"><span class="keyword">const</span> maxItems = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// maxItems 在此处无法访问</span></span><br></pre></td></tr></table></figure></li><li><p>在同一作用域内定义一个已有变量时会抛出错误，无论是在全局还是函数作用域，无论该变量此前是用 var 声明的，还是用 let 声明的。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">"Hello!"</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二者均会抛出错误</span></span><br><span class="line"><span class="keyword">const</span> message = <span class="string">"Goodbye!"</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">30</span>;</span><br></pre></td></tr></table></figure></li></ol><p><strong>本质区别：</strong><br>试图对 const 声明的常量再次赋值会抛出错误，无论是否运行在严格模式下：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const maxItems = <span class="number">5</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">maxItems</span> = <span class="number">6</span><span class="comment">;      // 抛出错误</span></span><br></pre></td></tr></table></figure></p><h4 id="使用-const-声明对象"><a href="#使用-const-声明对象" class="headerlink" title="使用 const 声明对象"></a>使用 const 声明对象</h4><p>const 声明会阻止对于<strong>变量绑定与变量自身值</strong>的修改，但不会阻止对<strong>变量成员</strong>的修改。<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">    <span class="built_in">name</span>: <span class="string">"Nicholas"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工作正常</span></span><br><span class="line">person.<span class="built_in">name</span> = <span class="string">"Greg"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line">person = &#123;</span><br><span class="line">    <span class="built_in">name</span>: <span class="string">"Greg"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>使用 let 或 const 声明的变量，在达到声明位置之前都是无法访问的，试图访问会导致一个引用错误。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    console.log(<span class="keyword">typeof</span> <span class="keyword">value</span>);  <span class="comment">// 引用错误</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">value</span> = <span class="string">"blue"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>原因：</strong><br>因为 value 位于被 JS 社区称为<strong>暂时性死区（ temporal dead zone ， TDZ ）</strong>的区域内。</p><p>当 JS 引擎扫描接下来的代码块并发现变量声明时：</p><ul><li>在处理 var 时将声明提升到函数或全局作用域的顶部；</li><li>处理 let 或 const 时，则会将声明放入暂时性死区。</li></ul><p>任何在暂时性死区内访问变量的企图都会导致“运行时”错误（runtime error）。只有执行到变量的声明语句时，该变量才会从暂时性死区内被移除，才可以安全使用。</p><blockquote><p>可以在变量被定义的代码块之外对该变量使用 typeof。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.log(<span class="keyword">typeof</span> <span class="keyword">value</span>);     <span class="comment">// "undefined"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">value</span> = <span class="string">"blue"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>typeof 运算符被用于 value 变量被定义的代码块外部，此时 value 并未在暂时性死区内。因为 value 变量绑定尚不存在，而 typeof 仅会单纯返回 “undefined” 。</p></blockquote><h2 id="循环中的块级绑定"><a href="#循环中的块级绑定" class="headerlink" title="循环中的块级绑定"></a>循环中的块级绑定</h2><h3 id="循环内的-var-声明"><a href="#循环内的-var-声明" class="headerlink" title="循环内的 var 声明"></a>循环内的 var 声明</h3><p>在 JS 中，由于 var 声明导致了变量提升，循环结束后 i 仍然可被访问，于是在循环内创建函数就会产生问题。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(i); &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    func();     <span class="comment">// 输出数值 "10" 十次</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><strong>解决方案：</strong><br>在循环内使用立即调用函数表达式（IIFEs），以便在每次迭代中强制创建变量的一个新副本：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    funcs.push((<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(i)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    func();     <span class="comment">// 从 0 到 9 依次输出</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="循环内的-let-声明"><a href="#循环内的-let-声明" class="headerlink" title="循环内的 let 声明"></a>循环内的 let 声明</h3><p>使用 let 声明，在每次迭代中，都会创建一个新的同名变量并对其进行初始化。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    func();     <span class="comment">// 从 0 到 9 依次输出</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>这种方式在 for-in 和 for-of 循环中同样适用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [],</span><br><span class="line">    object = &#123;</span><br><span class="line">        a: <span class="literal">true</span>,</span><br><span class="line">        b: <span class="literal">true</span>,</span><br><span class="line">        c: <span class="literal">true</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(key);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    func();     <span class="comment">// 依次输出 "a"、 "b"、 "c"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>let 声明在循环内部的行为是在规范中特别定义的，与不提升变量声明的特征没有必然联系。</p></blockquote><h3 id="循环内的常量声明"><a href="#循环内的常量声明" class="headerlink" title="循环内的常量声明"></a>循环内的常量声明</h3><p>ES6 规范没有明确禁止在循环中使用 const 声明，然而它会根据不同循环方式而有不同行为。</p><h4 id="常规-for-循环"><a href="#常规-for-循环" class="headerlink" title="常规 for 循环"></a>常规 for 循环</h4><p>可以在初始化时使用 const ，但循环会在试图改变该变量的值时抛出错误。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在一次迭代后抛出错误</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="for-in-或-for-of-循环"><a href="#for-in-或-for-of-循环" class="headerlink" title="for-in 或 for-of 循环"></a>for-in 或 for-of 循环</h4><p>const 变量在 for-in 或 for-of 循环中使用时，与 let 变量效果相同。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [],</span><br><span class="line">    object = &#123;</span><br><span class="line">        a: <span class="literal">true</span>,</span><br><span class="line">        b: <span class="literal">true</span>,</span><br><span class="line">        c: <span class="literal">true</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不会导致错误</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(key);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    func();     <span class="comment">// 依次输出 "a"、 "b"、 "c"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><strong>原因：</strong><br>因为for-in 与 for-of 循环为每次迭代创建了一个新的变量绑定，而不是像 for 循环那样试图去修改已绑定的变量的值。</p><h2 id="全局块级绑定"><a href="#全局块级绑定" class="headerlink" title="全局块级绑定"></a>全局块级绑定</h2><h3 id="使用-var-声明"><a href="#使用-var-声明" class="headerlink" title="使用 var 声明"></a>使用 var 声明</h3><p>在全局作用域上使用 var 时，会创建一个新的全局变量，并成为全局对象（在浏览器中是 window ）的一个属性。</p><blockquote><p>使用 var 可能会无意中覆盖一个已有的全局属性。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：浏览器中才有 window 属性</span></span><br><span class="line"><span class="comment">// 在浏览器中</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.RegExp);     <span class="comment">//function RegExp()&#123;&#125;</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">RegExp</span> = <span class="string">"Hello!"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.RegExp);     <span class="comment">// "Hello!"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ncz = <span class="string">"Hi!"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.ncz);        <span class="comment">// "Hi!"</span></span><br></pre></td></tr></table></figure><h3 id="使用-let-或-const-声明"><a href="#使用-let-或-const-声明" class="headerlink" title="使用 let 或 const 声明"></a>使用 let 或 const 声明</h3><p>在全局作用域上使用 let 或 const 声明时，会创建新的绑定，但不会有任何属性被添加到全局对象上。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在浏览器中</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">RegExp</span> = <span class="string">"Hello!"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>);                    <span class="comment">// "Hello!"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.RegExp === <span class="built_in">RegExp</span>);  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ncz = <span class="string">"Hi!"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(ncz);                       <span class="comment">// "Hi!"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"ncz"</span> <span class="keyword">in</span> <span class="built_in">window</span>);           <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><blockquote><p>若想让代码能从全局对象中被访问，仍然需要使用 var 。这种做法常见于在浏览器中跨越帧或窗口去访问代码的场合。</p></blockquote>]]></content>
      
      <categories>
          
          <category> LearnES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用 ES5 实现一个简单的Promise</title>
      <link href="/2018/03/29/LearnES5/%E7%94%A8ES5-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Promise/"/>
      <url>/2018/03/29/LearnES5/%E7%94%A8ES5-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Promise/</url>
      <content type="html"><![CDATA[<h2 id="Promise使用"><a href="#Promise使用" class="headerlink" title="Promise使用"></a>Promise使用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'步骤一：执行'</span>);</span><br><span class="line">        resolve(<span class="string">'1'</span>);</span><br><span class="line">    &#125;,<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'步骤二：执行'</span>);</span><br><span class="line">        resolve(<span class="string">'2'</span>);</span><br><span class="line">    &#125;,<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(fn1).then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(fn2);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">33</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Promise-标准解读"><a href="#Promise-标准解读" class="headerlink" title="Promise 标准解读"></a>Promise 标准解读</h2><p><a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promises/A+标准：</a></p><ol><li>只有一个then方法，没有catch，race，all等方法，甚至没有构造函数。<ul><li>Promise 标准中仅指定了 Promise 对象的 then 方法的行为，其它一切我们常见的方法/函数都并没有指定，包括 catch，race，all 等常用方法，甚至也没有指定该如何构造出一个 Promise 对象，另外 then 也没有一般实现中（Q, $q等）所支持的第三个参数，一般称 onProgress。</li></ul></li><li><p>then 方法返回一个新的 Promise。</p><ul><li>Promise的then方法返回一个新的Promise，而不是返回this。<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">promise2</span> = promise1.<span class="keyword">then</span>(alert)</span><br><span class="line">promise2 != promise1 // <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>不同Promise的实现需要可以相互调用 (interoperable)。</p></li><li>Promise 的初始状态为 pending，它可以由此状态转换为 fulfilled（本文为了一致把此状态叫做 resolved）或者 rejected，一旦状态确定，就不可以再次转换为其它状态，状态确定的过程称为 settle。</li></ol><p>首先看一下原生 ES6 中Promise 的使用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise构造函数接收一个 executor（执行） 函数。</span></span><br><span class="line"><span class="comment">// executor函数执行完同步或异步操作后，调用它的两个参数resolve和reject</span></span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//如果操作成功，调用resolve并传入value</span></span><br><span class="line"><span class="comment">//如果操作失败，调用reject并传入reason</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="实现构造函数的框架："><a href="#实现构造函数的框架：" class="headerlink" title="实现构造函数的框架："></a>实现构造函数的框架：</h2><p>先实现构造函数的框架如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function myPromise(executor) &#123;</span><br><span class="line"><span class="selector-tag">var</span> self = this；</span><br><span class="line">self<span class="selector-class">.status</span> = <span class="string">'pending'</span>； <span class="comment">// Promise当前的状态</span></span><br><span class="line">self<span class="selector-class">.data</span> = undefined；  <span class="comment">// Promise的值</span></span><br><span class="line"><span class="comment">// Promise resolve时的回调函数集，因为在Promise结束之前有可能有多个回调添加到它上面</span></span><br><span class="line">self<span class="selector-class">.onResolvedCallback</span> = []； </span><br><span class="line"><span class="comment">// Promise reject时的回调函数集，因为在Promise结束之前有可能有多个回调添加到它上面</span></span><br><span class="line">self<span class="selector-class">.onRejectedCallback</span> = []； </span><br><span class="line"></span><br><span class="line">executor(resolve, reject)； <span class="comment">// 执行executor并传入相应的参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码基本实现了Promise构造函数的主体，但目前还有两个问题：</p><ol><li>我们给executor函数传了两个参数：resolve 和 reject，这两个参数目前还没有定义。</li><li>executor 有可能会出错（throw），类似下面这样，而如果 executor 出错，Promise 应该被其 throw 出值 reject：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="number">2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>所以我们需要在构造函数里定义resolve和reject这两个函数：</p><h2 id="定义-resolve-和-reject-两个函数："><a href="#定义-resolve-和-reject-两个函数：" class="headerlink" title="定义 resolve 和 reject 两个函数："></a>定义 resolve 和 reject 两个函数：</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPromise</span><span class="params">(executor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">self</span> = this;</span><br><span class="line"><span class="keyword">self</span>.status = <span class="string">'pending'</span>; <span class="comment">// Promise当前的状态</span></span><br><span class="line"><span class="keyword">self</span>.data = undefined;  <span class="comment">// Promise的值</span></span><br><span class="line"><span class="keyword">self</span>.onResolvedCallback = []; <span class="comment">// Promise resolve时的回调函数集，因为在Promise结束之前有可能有多个回调添加到它上面</span></span><br><span class="line"><span class="keyword">self</span>.onRejectedCallback = []; <span class="comment">// Promise reject时的回调函数集，因为在Promise结束之前有可能有多个回调添加到它上面</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span><span class="params">(value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reject</span><span class="params">(reason)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 考虑到执行executor的过程中有可能出错，所以我们用try/catch块给包起来，并且在出错后以catch到的值reject掉这个Promise</span></span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">executor(resolve, reject); <span class="comment">// 执行executor</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">reject(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>resolve和reject这两个函数能不能不定义在构造函数里？</strong><br>考虑到我们在 executor 函数里是以 resolve(value)，reject(reason) 的形式调用的这两个函数，而不是以 resolve.call(promise, value)，reject.call(promise, reason) 这种形式调用的，所以这两个函数在调用时的内部也必然有一个隐含的 this ，也就是说，要么这两个函数是经过 bind 后传给了executor，要么它们定义在构造函数的内部，使用 self 来访问所属的Promise对象。<br>所以如果我们想把这两个函数定义在构造函数的外部，确实是可以这么写的：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPromise</span><span class="params">(executor)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    executor(resolve.bind(<span class="keyword">this</span>), reject.bind(<span class="keyword">this</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    reject.bind(<span class="keyword">this</span>)(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>但是众所周知，bind 会返回一个新的函数，这么一来还是相当于每个 Promise 对象都有一对属于自己的 resolve 和 reject 函数，就跟写在构造函数内部没什么区别了，所以我们就直接把这两个函数定义在构造函数里面了。<br>另外，这里的实现并没有考虑隐藏 this 上的变量，这使得这个 Promise 的状态可以在 executor 函数外部被改变，在一个靠谱的实现里，构造出的 Promise 对象的状态和最终结果应当是无法从外部更改的。</p></blockquote><p>接下来，实现resolve和reject这两个函数。</p><h2 id="实现-resolve-和-reject："><a href="#实现-resolve-和-reject：" class="headerlink" title="实现 resolve 和 reject："></a>实现 resolve 和 reject：</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPromise</span><span class="params">(executor)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span><span class="params">(value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line"><span class="keyword">self</span>.status = <span class="string">'resolved'</span>;</span><br><span class="line"><span class="keyword">self</span>.data = value;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i in <span class="keyword">self</span>.onResolvedCallback)&#123;</span><br><span class="line"><span class="keyword">self</span>.onResolvedCallback[i](value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reject</span><span class="params">(reason)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line"><span class="keyword">self</span>.status = <span class="string">'rejected'</span>;</span><br><span class="line"><span class="keyword">self</span>.data = reason;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i in <span class="keyword">self</span>.onRejectedCallback)&#123;</span><br><span class="line"><span class="keyword">self</span>.onRejectedCallback[i](reason);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本上就是在判断状态为pending之后把状态改为相应的值，并把对应的value和reason存在self的data属性上面，之后执行相应的回调函数。</p><h2 id="实现then方法"><a href="#实现then方法" class="headerlink" title="实现then方法"></a>实现then方法</h2><h3 id="解析-then-方法"><a href="#解析-then-方法" class="headerlink" title="解析 then 方法"></a>解析 then 方法</h3><p>Promise 对象有一个 then 方法，用来注册在这个 Promise 状态确定后的回调，很明显，then 方法需要写在原型链上。<br>then 方法会返回一个 Promise，关于这一点，Promise/A+ 标准并没有要求返回的这个 Promise 是一个新的对象，但在 Promise/A 标准中，明确规定了 then 要返回一个新的对象，目前的 Promise 实现中 then 几乎都是返回一个新的 Promise (<a href="https://promisesaplus.com/differences-from-promises-a#point-5" target="_blank" rel="noopener">详情</a>) 对象，所以在我们的实现中，也让 then 返回一个新的 Promise 对象。</p><p>每个 Promise 对象都可以在其上多次调用 then 方法，而每次调用 then 返回的 Promise 的状态取决于那一次调用 then 时传入参数的返回值，所以 then 不能返回 this，因为 then 每次返回的 Promise 的结果都有可能不同。</p><h3 id="实现then方法-1"><a href="#实现then方法-1" class="headerlink" title="实现then方法"></a>实现then方法</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// then方法接收两个参数，onResolved，onRejected，分别为Promise成功或失败后的回调</span></span><br><span class="line">myPromise.prototype.then = <span class="function"><span class="keyword">function</span><span class="params">(onResolved, onRejected)</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">self</span> = this;</span><br><span class="line"><span class="keyword">var</span> promise2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据标准，如果then的参数不是function，则我们需要忽略它，此处以如下方式处理：</span></span><br><span class="line">    <span class="comment">// 如果想要把then的实参留空且让值可以穿透到后面，</span></span><br><span class="line">    <span class="comment">// 意味着then的两个参数的默认值分别为function(value) &#123;return value&#125;，function(reason) &#123;throw reason&#125;。</span></span><br><span class="line">    onResolved = typeof onResolved === <span class="string">'function'</span> ? onResolved : <span class="function"><span class="keyword">function</span> <span class="params">(value)</span> </span>&#123; <span class="keyword">return</span> value;&#125;;</span><br><span class="line">    onRejected = typeof onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="keyword">function</span> <span class="params">(reason)</span> </span>&#123; <span class="keyword">throw</span> reason;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.status === <span class="string">'resolved'</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> promise2 = <span class="keyword">new</span> myPromise(<span class="function"><span class="keyword">function</span><span class="params">(resolve, reject)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.status === <span class="string">'rejected'</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> promise2 = <span class="keyword">new</span> myPromise(<span class="function"><span class="keyword">function</span><span class="params">(resolve, reject)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> promise2 = <span class="keyword">new</span> myPromise(<span class="function"><span class="keyword">function</span><span class="params">(resolve, reject)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Promise总共有三种可能的状态，我们分三个 if 块来处理，在里面分别都返回一个 new Promise。</p><p>根据标准，我们知道，对于如下代码，promise2 的值取决于 then 里面函数的返回值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise2 = promise1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'sth went wrong'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果 promise1 被 resolve 了，promise2 的将被 4 resolve，如果 promise1 被 reject 了，promise2 将被 new Error(‘sth went wrong’) reject。</p><p>所以，我们需要在 then 里面执行 onResolved 或者 onRejected，并根据返回值(标准中记为 x )来确定 promise2 的结果，并且，如果 onResolved/onRejected 返回的是一个 Promise，promise2 将直接取这个 Promise 的结果：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// then方法接收两个参数，onResolved，onRejected，分别为Promise成功或失败后的回调</span></span><br><span class="line">myPromise.prototype.then = <span class="function"><span class="keyword">function</span><span class="params">(onResolved, onRejected)</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">self</span> = this;</span><br><span class="line"><span class="keyword">var</span> promise2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据标准，如果then的参数不是function，则我们需要忽略它，此处以如下方式处理：</span></span><br><span class="line">onResolved = typeof onResolved === <span class="string">'function'</span> ? onResolved : <span class="function"><span class="keyword">function</span><span class="params">(value)</span> </span>&#123;&#125;;</span><br><span class="line">onRejected = typeof onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="keyword">function</span><span class="params">(reject)</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.status === <span class="string">'resolved'</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果promise1(此处即为this/self)的状态已经确定并且是resolved，我们调用onResolved</span></span><br><span class="line">    <span class="comment">// 因为考虑到有可能throw，所以我们将其包在try/catch块里</span></span><br><span class="line"><span class="keyword">return</span> promise2 = <span class="keyword">new</span> myPromise(<span class="function"><span class="keyword">function</span><span class="params">(resolve, reject)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> x = onResolved(<span class="keyword">self</span>.data);</span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> myPromise) &#123; <span class="comment">// 如果onResolved的返回值是一个Promise对象，直接取它的结果做为promise2的结果</span></span><br><span class="line">        x.then(resolve, reject);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 否则，以它的返回值做为promise2的结果</span></span><br><span class="line">        resolve(x); </span><br><span class="line">        &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">reject(e); <span class="comment">// 如果出错，以捕获到的错误做为promise2的结果</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处与前一个if块的逻辑几乎相同，区别在于所调用的是onRejected函数，就不再做过多解释</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.status === <span class="string">'rejected'</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> promise2 = <span class="keyword">new</span> myPromise(<span class="function"><span class="keyword">function</span><span class="params">(resolve, reject)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> x = onRejected(<span class="keyword">self</span>.data);</span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> myPromise) &#123; </span><br><span class="line">        x.then(resolve, reject);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    resolve(x);</span><br><span class="line">                &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">reject(e); <span class="comment">// 如果出错，以捕获到的错误做为promise2的结果</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line"><span class="comment">// 如果当前的Promise还处于pending状态，我们并不能确定调用onResolved还是onRejected，</span></span><br><span class="line"><span class="comment">// 只能等到Promise的状态确定后，才能确实如何处理。</span></span><br><span class="line"><span class="comment">// 所以我们需要把我们的 两种情况 的处理逻辑做为callback放入promise1(此处即this/self)的回调数组里</span></span><br><span class="line"><span class="comment">// 逻辑本身跟第一个if块内的几乎一致，此处不做过多解释</span></span><br><span class="line"><span class="keyword">return</span> promise2 = <span class="keyword">new</span> myPromise(<span class="function"><span class="keyword">function</span><span class="params">(resolve, reject)</span> </span>&#123;</span><br><span class="line"><span class="keyword">self</span>.onResolvedCallback.push(<span class="function"><span class="keyword">function</span><span class="params">(value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> x = onResolved(<span class="keyword">self</span>.data);</span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> myPromise) &#123; </span><br><span class="line">        x.then(resolve, reject);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    resolve(x);</span><br><span class="line">                &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">reject(e); </span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">self</span>.onRejectedCallback.push(<span class="function"><span class="keyword">function</span><span class="params">(value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> x = onRejected(<span class="keyword">self</span>.data);</span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> myPromise) &#123; </span><br><span class="line">        x.then(resolve, reject);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    resolve(x);</span><br><span class="line">                &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">reject(e); </span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺便实现一个catch方法</span></span><br><span class="line">myPromise.prototype.<span class="keyword">catch</span> = <span class="function"><span class="keyword">function</span><span class="params">(onRejected)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> this.then(<span class="keyword">null</span>, onRejected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们就实现了一个的 Promise。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPromise</span><span class="params">(executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">self</span> = this;</span><br><span class="line">    <span class="keyword">self</span>.state = <span class="string">'pending'</span>; <span class="comment">// Promise当前的状态</span></span><br><span class="line">    <span class="keyword">self</span>.data = undefined; <span class="comment">// Promise当前的值</span></span><br><span class="line">    <span class="keyword">self</span>.onResolvedCallback = []; <span class="comment">// Promise resolve时的回调函数集，因为在Promise结束之前有可能有多个回调添加到它上面</span></span><br><span class="line">    <span class="keyword">self</span>.onRejectedCallback = []; <span class="comment">// Promise reject时的回调函数集，因为在Promise结束之前有可能有多个回调添加到它上面</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span><span class="params">(value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">self</span>.state == <span class="string">'pending'</span>)&#123;</span><br><span class="line">            <span class="keyword">self</span>.state = <span class="string">'resolved'</span>;</span><br><span class="line">            <span class="keyword">self</span>.data = value;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i in <span class="keyword">self</span>.onResolvedCallback)&#123;</span><br><span class="line">                <span class="keyword">self</span>.onResolvedCallback[i](value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span><span class="params">(reason)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">self</span>.state == <span class="string">'pending'</span>)&#123;</span><br><span class="line">            <span class="keyword">self</span>.state = <span class="string">'rejected'</span>;</span><br><span class="line">            <span class="keyword">self</span>.data = reason;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i in <span class="keyword">self</span>.onRejectedCallback)&#123;</span><br><span class="line">                <span class="keyword">self</span>.onRejectedCallback[i](reason);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 考虑到执行executor的过程中有可能出错，所以我们用try/catch块给包起来，</span></span><br><span class="line">    <span class="comment">// 并且在出错后以catch到的值reject掉这个Promise</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        executor(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">myPromise.prototype.constructor = <span class="string">"myPromise"</span>;</span><br><span class="line">myPromise.prototype.then = <span class="function"><span class="keyword">function</span> <span class="params">(onResolved,onRejected)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">self</span> = this;</span><br><span class="line">    <span class="keyword">var</span> promise2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据标准，如果then的参数不是function，则我们需要忽略它，此处以如下方式处理：</span></span><br><span class="line">    <span class="comment">// 如果想要把then的实参留空且让值可以穿透到后面，</span></span><br><span class="line">    <span class="comment">// 意味着then的两个参数的默认值分别为function(value) &#123;return value&#125;，function(reason) &#123;throw reason&#125;。</span></span><br><span class="line">    onResolved = typeof onResolved === <span class="string">'function'</span> ? onResolved : <span class="function"><span class="keyword">function</span> <span class="params">(value)</span> </span>&#123; <span class="keyword">return</span> value;&#125;;</span><br><span class="line">    onRejected = typeof onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="keyword">function</span> <span class="params">(reason)</span> </span>&#123; <span class="keyword">throw</span> reason;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span>.state == <span class="string">'resolved'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> promise2 = <span class="keyword">new</span> myPromise(<span class="function"><span class="keyword">function</span> <span class="params">(resolve,reject)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">var</span> x = onResolved(<span class="keyword">self</span>.data);</span><br><span class="line">                <span class="keyword">if</span>(x <span class="keyword">instanceof</span> myPromise)&#123;</span><br><span class="line">                    x.then(resolve,reject);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    resolve(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (e)&#123;</span><br><span class="line">                reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span>.state == <span class="string">'rejected'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> promise2 = <span class="keyword">new</span> myPromise(<span class="function"><span class="keyword">function</span> <span class="params">(resolve,reject)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">var</span> x = onRejected(<span class="keyword">self</span>.data);</span><br><span class="line">                <span class="keyword">if</span>(x <span class="keyword">instanceof</span> myPromise)&#123;</span><br><span class="line">                    x.then(resolve,reject);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    resolve(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (e)&#123;</span><br><span class="line">                reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">self</span>.state == <span class="string">'pending'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> promise2 = <span class="keyword">new</span> myPromise(<span class="function"><span class="keyword">function</span> <span class="params">(resolve,reject)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">self</span>.onResolvedCallback.push(<span class="function"><span class="keyword">function</span><span class="params">(value)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">var</span> x = onResolved(<span class="keyword">self</span>.data);</span><br><span class="line">                    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> myPromise) &#123;</span><br><span class="line">                        x.then(resolve, reject);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        resolve(x);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">self</span>.onRejectedCallback.push(<span class="function"><span class="keyword">function</span><span class="params">(value)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">var</span> x = onRejected(<span class="keyword">self</span>.data);</span><br><span class="line">                    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> myPromise) &#123;</span><br><span class="line">                        x.then(resolve, reject);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        resolve(x);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myPromise.prototype.<span class="keyword">catch</span> = <span class="function"><span class="keyword">function</span><span class="params">(onRejected)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> this.then(<span class="keyword">null</span>, onRejected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文献：<br><a href="https://zhuanlan.zhihu.com/p/21834559" target="_blank" rel="noopener">【1】史上最易读懂的 Promise/A+ 完全实现</a><br><a href="https://www.cnblogs.com/huansky/p/6064402.html" target="_blank" rel="noopener">【2】手把手教你实现一个完整的 Promise</a></p>]]></content>
      
      <categories>
          
          <category> LearnES5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript异步编程</title>
      <link href="/2018/03/29/LearnES5/JavaScript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
      <url>/2018/03/29/LearnES5/JavaScript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><ol><li>JavaScript语言执行环境是单线程的，单线程在程序执行时，所走的程序路径按照连续顺序排下来，前面的必须处理好，后面的才会执行。</li><li>在某个特定的时刻只有特定的代码能够被执行，且会阻塞其它的代码。</li></ol><p>基于JavaScript的单线程语言执行环境及其不足，提出了JavaScript的同步与异步编程方式：</p><ol><li>同步，即任务一步一步执行，当前代码执行完毕后才能继续执行后续代码，程序的执行顺序与任务的排列顺序是一致的、同步的；</li><li>异步，每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。</li></ol><p>JavaScript异步编程实现主要归为三类：<strong>回调函数、事件监听、发布订阅、Promise对象</strong></p><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>假定有三个函数 f1 、 f2 和 f3，f2 等待 f1 的执行结果。</p><pre><code>f1();f2();f3();</code></pre><p>如果 f1 是一个很耗时的任务，则可以改写 f1，把 f2 写成 f1 的回调函数。</p><pre><code>function f1(callback) {    setTimeout(function() {        // f1 的任务代码        callback();    }, 1000);}</code></pre><p>则执行代码就编程这样：</p><pre><code>f1(f2);f3();</code></pre><p>这样把同步操作变成了异步操作，f1 不会堵塞后面的程序例如 f3 的运行，相当于先执行程序的主要逻辑，将耗时的操作推迟执行。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>简单、容易理解和部署。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。</p><h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><p>采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生。<br>为f1绑定一个事件（这里采用的jQuery的写法）。</p><pre><code>f1.on(&apos;done&apos;, f2);</code></pre><p>当 f1 发生 done 事件，就执行 f2。<br>对f1进行改写：</p><pre><code>function f1(){    setTimeout(function () {    　　// f1的任务代码    　　f1.trigger(&apos;done&apos;);    }, 1000);}</code></pre><p>f1.trigger(‘done’)表示，执行完成后，立即触发done事件，从而开始执行f2。</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合”（Decoupling），有利于实现模块化。</p><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>整个程序都要变成事件驱动型，运行流程会变得很不清晰。</p><h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><p>假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”（publish-subscribe pattern），又称”观察者模式”（observer pattern）。</p><p>PubSub，发布、订阅模式， 用以分发事件。常见的有jQuery的自定义事件监听、Node的EventEmitter对象等。</p><h3 id="jQuery事件监听"><a href="#jQuery事件监听" class="headerlink" title="jQuery事件监听"></a>jQuery事件监听</h3><pre><code>$(&apos;#btn&apos;).on(&apos;myEvent&apos;, function(e) {    console.log(&apos;There is my Event&apos;);});$(&apos;#btn&apos;).trigger(&apos;myEvent&apos;); //触发 myEvent 事件</code></pre><h3 id="PubSub"><a href="#PubSub" class="headerlink" title="PubSub"></a>PubSub</h3><pre><code>var PubSub = function(){    this.handlers = {}; };// 订阅事件PubSub.prototype.subscribe = function(eventType, handler) {    // 如果操作中心没有这个事件类型，则将该事件初始化    if (!(eventType in this.handlers)) {         this.handlers[eventType] = [];    }    this.handlers[eventType].push(handler); //添加事件监听器    return this;//返回上下文环境以实现链式调用};// 发布事件PubSub.prototype.publish = function(eventType) {    // 获取除事件类型之外的其他参数    var _args = Array.prototype.slice.call(arguments, 1);    for (var i = 0, _handlers = this.handlers[eventType]; i &lt; _handlers.length; i++) {        _handlers[i].apply(this, _args);//遍历事件监听器    }    return this;};var event = new PubSub;//构造PubSub实例// 订阅一个事件event.subscribe(&apos;list&apos;, function(msg) {     console.log(msg);});// 发布这个事件event.publish(&apos;list&apos;, {data: [&apos;one,&apos;, &apos;two&apos;]});//Object {data: Array[2]}</code></pre><h2 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h2><p>Promises对象是CommonJS工作组提出的一种规范，目的是为异步编程提供统一接口。</p><h3 id="Promise-的生命周期"><a href="#Promise-的生命周期" class="headerlink" title="Promise 的生命周期"></a>Promise 的生命周期</h3><ol><li>一个promise可能有三种状态：等待（pending）、已完成（fulfilled）、已拒绝（rejected）;</li><li>一个promise的状态只可能从“等待”转到“完成”态或者“拒绝”态，不能逆向转换，同时“完成”态和“拒绝”态不能相互转换；</li><li>promise 必须实现 then 方法（可以说，then就是promise的核心），而且 then 必须返回一个 promise，同一个 promise 的 then 可以调用多次，并且回调的执行顺序跟它们被定义时的顺序一致；</li><li>then 方法接受两个参数，第一个参数是 Promise 被完成时要调用的函数，在 promise 由“等待”态转换到“完成”态时调用；另一个是 Promise 被拒绝时的回调，在 promise 由“等待”态转换到“拒绝”态时调用。</li><li>同时，then 可以接受另一个 promise 传入，也接受一个“类 then ”的对象或方法，即 thenable 对象。（thenable 是一个包含了then方法的对象或函数。）</li></ol><pre><code>let promise = readFile(&quot;example.txt);promise.then(function(contents){    //完成    console.log(contents);},function(err){    //拒绝    console.error(err.message);});</code></pre><p>也可以写成：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let promise = readFile("example.txt);</span><br><span class="line"></span><br><span class="line">promise.then(function(contents)&#123;</span><br><span class="line"><span class="comment">//完成</span></span><br><span class="line">console.<span class="built_in">log</span>(contents);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.catch(function(<span class="keyword">err</span>)&#123;</span><br><span class="line"><span class="comment">//拒绝</span></span><br><span class="line">console.<span class="keyword">error</span>(<span class="keyword">err</span>.message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在Node.js中也是使用 Promise 实现上面的 readFile() 函数。</span></span><br><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line"><span class="comment">//触发异步操作：Node.js原生的异步调用包在一个 Promise 中。</span></span><br><span class="line">fs.readFile(filename,&#123;<span class="attr">encoding</span>:<span class="string">"utf8"</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,contents</span>)</span>&#123;</span><br><span class="line"><span class="comment">//检查错误</span></span><br><span class="line"><span class="keyword">if</span>(err)&#123;</span><br><span class="line">reject(err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读取成功</span></span><br><span class="line">resolve(contents);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LearnES5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>书籍整理</title>
      <link href="/2018/03/29/%E7%94%9F%E6%B4%BB/%E4%B9%A6%E7%B1%8D%E6%95%B4%E7%90%86/"/>
      <url>/2018/03/29/%E7%94%9F%E6%B4%BB/%E4%B9%A6%E7%B1%8D%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="正在看"><a href="#正在看" class="headerlink" title="正在看"></a>正在看</h2><h3 id="《你不知道的-JavaScript-上卷》"><a href="#《你不知道的-JavaScript-上卷》" class="headerlink" title="《你不知道的 JavaScript 上卷》"></a><a href="https://book.douban.com/subject/26351021/" target="_blank" rel="noopener">《你不知道的 JavaScript 上卷》</a></h3><p><img src="/2018/03/29/生活/书籍整理/1_1.jpg" alt="《你不知道的 JavaScript 上卷》"></p><h3 id="《HTTP-权威指南》"><a href="#《HTTP-权威指南》" class="headerlink" title="《HTTP 权威指南》"></a><a href="https://book.douban.com/subject/10746113/" target="_blank" rel="noopener">《HTTP 权威指南》</a></h3><p><img src="/2018/03/29/生活/书籍整理/1_2.jpg" alt="《HTTP 权威指南》"></p><h3 id="《ES6-标准入门》"><a href="#《ES6-标准入门》" class="headerlink" title="《ES6 标准入门》"></a><a href="https://book.douban.com/subject/27127030/" target="_blank" rel="noopener">《ES6 标准入门》</a></h3><p><img src="/2018/03/29/生活/书籍整理/1_3.jpg" alt="《ES6 标准入门》"></p><h3 id="《深入理解-ES6-》"><a href="#《深入理解-ES6-》" class="headerlink" title="《深入理解 ES6 》"></a><a href="https://book.douban.com/subject/27072230/" target="_blank" rel="noopener">《深入理解 ES6 》</a></h3><p><img src="/2018/03/29/生活/书籍整理/1_4.jpg" alt="《深入理解 ES6》"></p><h2 id="已看完"><a href="#已看完" class="headerlink" title="已看完"></a>已看完</h2><h3 id="《Head-First-HTML-与-CSS（第2版）》"><a href="#《Head-First-HTML-与-CSS（第2版）》" class="headerlink" title="《Head First HTML 与 CSS（第2版）》"></a><a href="https://book.douban.com/subject/25752357/" target="_blank" rel="noopener">《Head First HTML 与 CSS（第2版）》</a></h3><p><img src="/2018/03/29/生活/书籍整理/2_1.jpg" alt="《Head First HTML 与 CSS（第2版）》"></p><h3 id="《HTML-5-CSS-3-从入门到精通》"><a href="#《HTML-5-CSS-3-从入门到精通》" class="headerlink" title="《HTML 5 + CSS 3 从入门到精通》"></a><a href="https://book.douban.com/subject/24708139/" target="_blank" rel="noopener">《HTML 5 + CSS 3 从入门到精通》</a></h3><p><img src="/2018/03/29/生活/书籍整理/2_2.jpg" alt="《HTML 5 + CSS 3 从入门到精通》"></p><h3 id="《JavaScript-高级程序设计（第3版）》"><a href="#《JavaScript-高级程序设计（第3版）》" class="headerlink" title="《JavaScript 高级程序设计（第3版）》"></a><a href="https://book.douban.com/subject/10546125/" target="_blank" rel="noopener">《JavaScript 高级程序设计（第3版）》</a></h3><p><img src="/2018/03/29/生活/书籍整理/2_3.jpg" alt="《JavaScript 高级程序设计（第3版）》"></p><h3 id="《JavaScript-语言精粹》"><a href="#《JavaScript-语言精粹》" class="headerlink" title="《JavaScript 语言精粹》"></a><a href="https://book.douban.com/subject/11874748/" target="_blank" rel="noopener">《JavaScript 语言精粹》</a></h3><p><img src="/2018/03/29/生活/书籍整理/2_4.jpg" alt="《JavaScript 语言精粹》"></p><h3 id="《CSS-权威指南》"><a href="#《CSS-权威指南》" class="headerlink" title="《CSS 权威指南》"></a><a href="https://book.douban.com/subject/2308234/" target="_blank" rel="noopener">《CSS 权威指南》</a></h3><p><img src="/2018/03/29/生活/书籍整理/2_5.jpg" alt="《CSS 权威指南》"></p><h3 id="《大话数据结构》"><a href="#《大话数据结构》" class="headerlink" title="《大话数据结构》"></a><a href="https://book.douban.com/subject/6424904/" target="_blank" rel="noopener">《大话数据结构》</a></h3><p><img src="/2018/03/29/生活/书籍整理/2_6.jpg" alt="《大话数据结构》"></p><h2 id="准备看"><a href="#准备看" class="headerlink" title="准备看"></a>准备看</h2><h3 id="《JavaScript-DOM-编程艺术（第2版）》"><a href="#《JavaScript-DOM-编程艺术（第2版）》" class="headerlink" title="《JavaScript DOM 编程艺术（第2版）》"></a><a href="https://book.douban.com/subject/6038371/" target="_blank" rel="noopener">《JavaScript DOM 编程艺术（第2版）》</a></h3><p><img src="/2018/03/29/生活/书籍整理/3_1.jpg" alt="《JavaScript DOM 编程艺术（第2版）》"></p><h3 id="《高性能-JavaScript》"><a href="#《高性能-JavaScript》" class="headerlink" title="《高性能 JavaScript》"></a><a href="https://book.douban.com/subject/26599677/" target="_blank" rel="noopener">《高性能 JavaScript》</a></h3><p><img src="/2018/03/29/生活/书籍整理/3_2.jpg" alt="《高性能 JavaScript》"></p><h3 id="《Effective-JavaScript-编写高质量-JavaScript-代码的-68-个有效方法》"><a href="#《Effective-JavaScript-编写高质量-JavaScript-代码的-68-个有效方法》" class="headerlink" title="《Effective JavaScript 编写高质量 JavaScript 代码的 68 个有效方法》"></a><a href="https://book.douban.com/subject/25786138/" target="_blank" rel="noopener">《Effective JavaScript 编写高质量 JavaScript 代码的 68 个有效方法》</a></h3><p><img src="/2018/03/29/生活/书籍整理/3_3.jpg" alt="《Effective JavaScript 编写高质量 JavaScript 代码的 68 个有效方法》"></p><h3 id="《你不知道的-JavaScript-中卷》"><a href="#《你不知道的-JavaScript-中卷》" class="headerlink" title="《你不知道的 JavaScript 中卷》"></a><a href="https://book.douban.com/subject/26854244/" target="_blank" rel="noopener">《你不知道的 JavaScript 中卷》</a></h3><p><img src="/2018/03/29/生活/书籍整理/3_4.jpg" alt="《你不知道的 JavaScript 中卷》"></p><h3 id="《你不知道的-JavaScript-下卷》"><a href="#《你不知道的-JavaScript-下卷》" class="headerlink" title="《你不知道的 JavaScript 下卷》"></a><a href="https://book.douban.com/subject/27620408/" target="_blank" rel="noopener">《你不知道的 JavaScript 下卷》</a></h3><p><img src="/2018/03/29/生活/书籍整理/3_5.jpg" alt="《你不知道的 JavaScript 下卷》"></p>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>js代码判断浏览器种类</title>
      <link href="/2018/03/28/LearnES5/js%E4%BB%A3%E7%A0%81%E5%88%A4%E6%96%AD%E6%B5%8F%E8%A7%88%E5%99%A8%E7%A7%8D%E7%B1%BB/"/>
      <url>/2018/03/28/LearnES5/js%E4%BB%A3%E7%A0%81%E5%88%A4%E6%96%AD%E6%B5%8F%E8%A7%88%E5%99%A8%E7%A7%8D%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h2 id="只区分浏览器，不考虑版本"><a href="#只区分浏览器，不考虑版本" class="headerlink" title="只区分浏览器，不考虑版本"></a>只区分浏览器，不考虑版本</h2><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var browserVersions = function()&#123;</span><br><span class="line">    var u = navigator.userAgent;</span><br><span class="line">    var app = navigator.appVersion;</span><br><span class="line">    <span class="class">return </span>&#123;</span><br><span class="line"><span class="symbol">    trident:</span> u.indexOf(‘Trident’) &gt; <span class="number">-1</span>, <span class="comment">//IE内核</span></span><br><span class="line"><span class="symbol">    presto:</span> u.indexOf(‘Presto’) &gt; <span class="number">-1</span>, <span class="comment">//opera内核</span></span><br><span class="line"><span class="symbol">    webKit:</span> u.indexOf(‘AppleWebKit’) &gt; <span class="number">-1</span>, <span class="comment">//苹果、谷歌内核</span></span><br><span class="line"><span class="symbol">    gecko:</span> u.indexOf(‘Gecko’) &gt; <span class="number">-1</span> &amp;&amp; u.indexOf(‘KHTML’) == <span class="number">-1</span>, <span class="comment">//火狐内核</span></span><br><span class="line"><span class="symbol">    mobile:</span> !!u.match(/AppleWebKit.*Mobile.*/)||!!u.match(/AppleWebKit/), <span class="comment">//是否为移动终端</span></span><br><span class="line"><span class="symbol">    ios:</span> !!u.match(/(i[^;]+;( U;)? CPU.+Mac OS X/), <span class="comment">//ios终端</span></span><br><span class="line"><span class="symbol">    android:</span> u.indexOf(‘Android’) &gt; <span class="number">-1</span> || u.indexOf(‘Linux’) &gt; <span class="number">-1</span>, <span class="comment">//android终端或者uc浏览器</span></span><br><span class="line"><span class="symbol">    iPhone:</span> u.indexOf(‘iPhone’) &gt; <span class="number">-1</span> || u.indexOf(‘Mac’) &gt; <span class="number">-1</span>, <span class="comment">//是否为iPhone或者QQHD浏览器</span></span><br><span class="line"><span class="symbol">    iPad:</span> u.indexOf(‘iPad’) &gt; <span class="number">-1</span>, <span class="comment">//是否iPad</span></span><br><span class="line"><span class="symbol">    webApp:</span> u.indexOf(‘Safari’) == <span class="number">-1</span> <span class="comment">//是否web应该程序，没有头部与底部</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LearnES5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>华为笔试题</title>
      <link href="/2018/03/28/Programming/%E5%8D%8E%E4%B8%BA%E7%AC%94%E8%AF%95%E9%A2%98/"/>
      <url>/2018/03/28/Programming/%E5%8D%8E%E4%B8%BA%E7%AC%94%E8%AF%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>华为笔试题，前面两道题非常简单就不进行记录了。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入是一个整型数组，数组里的整形数可以是正数，也可以是负数。子数组指的是数组中连续的一个或多个元素的集合，求这些子数组中，求和后最大值是多少。</p><p><strong>输入描述：</strong></p><blockquote><p>一个整型数组</p></blockquote><p><strong>输出描述：</strong></p><blockquote><p>最大连续子数组的和。</p></blockquote><h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><pre><code>function GreatSum(arr){    var sum = 0;    var result = 0;    for(var i in arr){        sum += arr[i];        if(sum &lt; 0){            sum = 0;        }        if(sum &gt; result){            result = sum;        }        if(result == 0){            for(var j in arr){                if(result == 0){                    result = arr[j];                } else if (result &lt; arr[j]){                    result = arr[j];                }            }        }    }    return result;}</code></pre>]]></content>
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网易互娱一面</title>
      <link href="/2018/03/28/%E7%94%9F%E6%B4%BB/%E7%BD%91%E6%98%93%E4%BA%92%E5%A8%B1%E4%B8%80%E9%9D%A2/"/>
      <url>/2018/03/28/%E7%94%9F%E6%B4%BB/%E7%BD%91%E6%98%93%E4%BA%92%E5%A8%B1%E4%B8%80%E9%9D%A2/</url>
      <content type="html"><![CDATA[<p>邮件通知我今天下午网易互娱一面视频面试，我当时心里是很紧张的。担心出现像之前今日头条视频面一样的情况，在公司的会议室面试结果老大来视察，差点被抓到暗地找实习，所以这次我背着电脑回寝室面。</p><p>中午怎么也睡不好觉，一点风吹草动就被惊醒，直接导致面试的时候思路不是很清晰。</p><p>但是，其实最郁闷的是面试，面试官先让我介绍一下我自己。我就说本科怎么怎么样，然后现在研究生怎么怎么blabla说了一堆。介绍完之后，他也不问我基础，让我说一下我最熟练的项目。我就说我现在正在重构的视频侦查作战平台，基于angularjs1做的，然后介绍了一堆。然后面试官问我知不知道前端框架，用前端框架会轻松得很多，你知不知道vue。我说我看过一些文档，但因为公司项目基于angularjs1，所以没有上手实战过。</p><p>看得出来他对我所知道的知识也不是很感兴趣，所以也没有怎么针对我所了解的知识进行深问。然后没问多少东西就结束了。最后的最后他给我提了一些意见：对前端的兴趣是有的，但热情不够= =。。。让我多去看github上人家写的源码。</p><p>本来我以为会像头条那样把基础问得很深，问得特别难，没想到会被技术刷人了。</p><p>结论：果然我要去上手实战一下 Vue 么！</p><p>后来佳静回来了，说了一番话让我没那么感觉郁闷了。她说不仅是前端团队在选择你，其实你也要选择前端团队。其实框架是互通的，如果他们并不知道angularjs也是前端框架的话，那说明这个团队其实知识面也是局限的，可能在这个团队学到的东西也很有限。嗯，我觉得也有道理。</p>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>HTML</title>
      <link href="/2018/03/27/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/HTML/"/>
      <url>/2018/03/27/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/HTML/</url>
      <content type="html"><![CDATA[<h2 id="1、-lt-img-gt-标签上title属性与alt属性的区别是什么？"><a href="#1、-lt-img-gt-标签上title属性与alt属性的区别是什么？" class="headerlink" title="1、 &lt; img &gt;标签上title属性与alt属性的区别是什么？"></a>1、 &lt; img &gt;标签上title属性与alt属性的区别是什么？</h2><ul><li>alt属性：是为了给那些不能看到你文档中图像的浏览者提供文字说明的。且长度必须少于100个英文字符或者用户必须保证替换文字尽可能的短。这包括那些使用本来就不支持图像显示或者图像显示被关闭的浏览器的用户，视觉障碍的用户和使用屏幕阅读器的用户等。</li><li>title属性：为设置该属性的元素提供建议性的信息。使用title属性提供非本质的额外信息。</li></ul><h2 id="2、-请写出至少5个-HTML5-新增的标签，并说明其语义和应用场景。"><a href="#2、-请写出至少5个-HTML5-新增的标签，并说明其语义和应用场景。" class="headerlink" title="2、 请写出至少5个 HTML5 新增的标签，并说明其语义和应用场景。"></a>2、 请写出至少5个 HTML5 新增的标签，并说明其语义和应用场景。</h2><ul><li>section：定义文档中的一个章节</li><li>nav：定义只包含导航链接的章节</li><li>header：定义页面或章节的头部。它经常包含 logo、页面标题和导航性的目录。</li><li>footer：定义页面或章节的尾部。它经常包含版权信息、法律信息链接和反馈建议用的地址。</li><li>aside：定义和页面内容关联度较低的内容——如果被删除，剩下的内容仍然很合理。</li></ul><h2 id="3、-请说说你对标签语义化的理解？"><a href="#3、-请说说你对标签语义化的理解？" class="headerlink" title="3、 请说说你对标签语义化的理解？"></a>3、 请说说你对标签语义化的理解？</h2><h3 id="什么是-HTML-语义化？"><a href="#什么是-HTML-语义化？" class="headerlink" title="什么是 HTML 语义化？"></a>什么是 HTML 语义化？</h3><p>根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。</p><h3 id="为什么要语义化？"><a href="#为什么要语义化？" class="headerlink" title="为什么要语义化？"></a>为什么要语义化？</h3><ul><li>为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构 ;</li><li>用户体验：例如title、 alt 用于解释名词或解释图片信息、 label 标签的活用；</li><li>有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；</li><li>方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；</li><li>便于团队开发和维护，语义化更具可读性，是下一步网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</li></ul><h3 id="语义化标签有哪些？"><a href="#语义化标签有哪些？" class="headerlink" title="语义化标签有哪些？"></a>语义化标签有哪些？</h3><ul><li>&lt; header&gt;&lt;/ header&gt;</li><li>&lt; footer&gt;&lt;/ footer&gt;</li><li>&lt; nav&gt;&lt; /nav&gt;</li><li>&lt; section&gt;&lt;/ section&gt;</li><li>&lt; article&gt;&lt;/ article&gt; SM:用来在页面中表示一套结构完整且独立的内容部分</li><li>&lt; aside&gt;&lt;/ aside&gt; SM:主题的附属信息 ( 用途很广，主要就是一个附属内容 ) ，如果 article 里面为一篇文章的话，那么文章的作者以及信息内容就是这篇文章的附属内容了</li><li>&lt; figure&gt;&lt;/ figure&gt; SM:媒体元素，比如一些视频，图片啊等等</li><li>&lt; datalist&gt;&lt;/ datalist&gt; SM:选项列表，与 input 元素配合使用，来定义 input 可能的值</li><li>&lt; details&gt;&lt;/ details&gt; SM:用于描述文档或者文档某个部分的细节 ~ 默认属性为 open~ ps:配合 summary 一起使用</li></ul><h2 id="4、-Doctype作用-严格模式与混杂模式如何区分？它们有何意义"><a href="#4、-Doctype作用-严格模式与混杂模式如何区分？它们有何意义" class="headerlink" title="4、 Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?"></a>4、 Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</h2><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><ul><li>&lt;!DOCTYPE&gt; 声明位于文档中的最前面，告知浏览器的解析器使用哪种文档类型来解析文档。</li><li>该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的HTML 文档。</li></ul><h3 id="区分："><a href="#区分：" class="headerlink" title="区分："></a>区分：</h3><ul><li>严格模式的排版 和 JS 运作模式 是以该浏览器支持的最高标准运行。</li><li>混杂模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。DOCTYPE 不存在 或 格式不正确 会导致文档以混杂模式呈现。</li></ul><blockquote><p>DOCTYPE 声明——标准模式与怪异模式的区别</p></blockquote><h2 id="5、-你知道多少种Doctype文档类型？"><a href="#5、-你知道多少种Doctype文档类型？" class="headerlink" title="5、 你知道多少种Doctype文档类型？"></a>5、 你知道多少种Doctype文档类型？</h2><p>标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。</p><ul><li>HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。</li><li>XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。</li><li>Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页， 浏览器按 W3C 标准解析执行代码</li><li>Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。</li></ul><h2 id="6、HTML与XHTML——二者有什么区别。"><a href="#6、HTML与XHTML——二者有什么区别。" class="headerlink" title="6、HTML与XHTML——二者有什么区别。"></a>6、HTML与XHTML——二者有什么区别。</h2><p>HTML是一种基本的WEB网页设计语言，XHTML是一个基于XML的置标语言</p><ul><li>XHTML 元素必须被正确地嵌套</li><li>XHTML 元素必须被关闭，空标签也必须被关闭，如<br>必须写成 <br></li><li>XHTML 标签名必须用小写字母</li><li>XHTML 文档要求给所有属性赋一个值</li><li>XHTML 要求所有的属性必须用引号””括起来</li><li>XHTML 文档需要把所有 &lt; 、&gt;、&amp; 等特殊符号用编码表示</li><li>XHTML 文档不要在注释内容中使“–”</li><li>XHTML 图片必须有说明文字</li><li>XHTML 文档中用id属性代替name属性</li></ul><h2 id="7、-HTML5-有哪些新特性、移除了哪些元素？"><a href="#7、-HTML5-有哪些新特性、移除了哪些元素？" class="headerlink" title="7、 HTML5 有哪些新特性、移除了哪些元素？"></a>7、 HTML5 有哪些新特性、移除了哪些元素？</h2><p>HTML5 新增了 27 个元素，废弃了 16 个元素。<br>根据现有的标准规范，把  HTML5  的元素按优先级定义为结构性属性、级块性元素、行内语义性元素和交互性元素 4 大类。</p><h3 id="元素新特性"><a href="#元素新特性" class="headerlink" title="元素新特性"></a>元素新特性</h3><ol><li>结构性元素主要负责web上下文结构的定义。</li></ol><ul><li>section：在 web 页面应用中，该元素也可以用于区域的章节描述。</li><li>header：页面主体上的头部， header 元素往往在一对 body 元素中。</li><li>footer：页面的底部（页脚），通常会标出网站的相关信息。</li><li>nav：专门用于菜单导航、链接导航的元素，是 navigator 的缩写。</li><li>article：用于表现一篇文章的主体内容，一般为文字集中显示的区域。</li></ul><ol start="2"><li>级块性元素主要完成web页面区域的划分，确保内容的有效分割。</li></ol><ul><li>aside：用于表达注记、贴士、侧栏、摘要、插入的引用等作为补充主体的内容。</li><li>figure：是对多个元素进行组合并展示的元素，通常与 ficaption 联合使用。</li><li>code：表示一段代码块。</li><li>dialog：用于表达人与人之间的对话，该元素包含 dt 和 dd 这两个组合元素， dt 用于表示说话者，而 dd 用来表示说话内容。</li></ul><ol start="3"><li>行内语义性元素主要完成web页面具体内容的引用和描述，是丰富内容展示的基础。</li></ol><ul><li>meter：表示特定范围内的数值，可用于工资、数量、百分比等。</li><li>time：表示时间值。</li><li>progress：用来表示进度条，可通过对其 max 、 min 、 step 等属性进行控制，完成对进度的表示和监事。</li><li>video：视频元素，用于支持和实现视频文件的直接播放，支持缓冲预载和多种视频媒体格式。</li><li>audio：音频元素，用于支持和实现音频文件的直接播放，支持缓冲预载和多种音频媒体格式。</li></ul><ol start="4"><li>交互性元素主要用于功能性的内容表达，会有一定的内容和数据的关联，是各种事件的基础。</li></ol><ul><li>details：用来表示一段具体的内容，但是内容默认可能不显示，通过某种手段（如单击）与 legend 交互才会显示出来。</li><li>datagrid：用来控制客户端数据与显示，可以由动态脚本及时更新。</li><li>menu：主要用于交互菜单（曾被废弃又被重新启用的元素）。</li><li>command：用来处理命令按钮。</li></ul><h3 id="API新特性："><a href="#API新特性：" class="headerlink" title="API新特性："></a>API新特性：</h3><ol><li>HTML5  现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</li><li>语义化更好的内容标签（ header ,nav,footer,aside,article,section）</li><li>音频、视频API(audio,video)</li><li>画布( canvas ) API</li><li>地理(Geolocation) API</li><li>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失</li><li>sessionStorage 的数据在页面会话结束时会被清除</li><li>表单控件，calendar、date、time、email、url、search</li><li>新的技术 web worker, web socket 等<ul><li>web socket 一种协议，可以让我们建立客户端到服务器端的全双工通信，这就意味着服务器端可以主动推送数据到客户端。</li><li>web worker 运行在浏览器后台的js程序，他不影响主程序的运行，是另开的一个js线程，可以用这个线程执行复杂的数据操作，然后把操作结果通过postMessage传递给主线程，这样在进行复杂且耗时的操作时就不会阻塞主线程了。</li></ul></li><li>拖拽释放(Drag and drop) API<h3 id="移除元素："><a href="#移除元素：" class="headerlink" title="移除元素："></a>移除元素：</h3></li><li>纯表现的元素：<ul><li>&lt; basefont&gt; 默认字体，不设置字体，以此渲染</li><li>&lt; font&gt; 字体标签</li><li>&lt; center&gt; 水平居中</li><li>&lt; u&gt; 下划线</li><li>&lt; big&gt; 大字体</li><li>&lt; strike&gt; 中横线</li><li>&lt; tt&gt; 文本等宽</li></ul></li><li>框架集：frame，frameset，noframes；</li></ol><h2 id="8、-Quirks模式是什么？它和Standards模式有什么区别？"><a href="#8、-Quirks模式是什么？它和Standards模式有什么区别？" class="headerlink" title="8、 Quirks模式是什么？它和Standards模式有什么区别？"></a>8、 Quirks模式是什么？它和Standards模式有什么区别？</h2><h3 id="Quirks模式（怪癖模式，诡异模式，怪异模式）"><a href="#Quirks模式（怪癖模式，诡异模式，怪异模式）" class="headerlink" title="Quirks模式（怪癖模式，诡异模式，怪异模式）"></a>Quirks模式（怪癖模式，诡异模式，怪异模式）</h3><p>在写程序时我们也会经常遇到这样的问题，如何保证原来的接口不变，又提供更强大的功能，尤其是新功能不兼容旧功能时。IE6以前的页面大家都不会去写DTD，所以IE6就假定 如果写了DTD，就意味着这个页面将采用对CSS支持更好的布局，而如果没有，则采用兼容之前的布局方式(Quirks模式)。</p><h3 id="区别：总体有布局、样式解析和脚本执行三个方面的区别。"><a href="#区别：总体有布局、样式解析和脚本执行三个方面的区别。" class="headerlink" title="区别：总体有布局、样式解析和脚本执行三个方面的区别。"></a>区别：总体有布局、样式解析和脚本执行三个方面的区别。</h3><ol><li>盒模型：在W3C标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在Quirks 模式下，IE的宽度和高度还包含了padding和border。</li><li>设置行内元素的高宽：在Standards模式下，给<span>等行内元素设置wdith和height都不会生效，而在quirks模式下，则会生效。</span></li><li>设置百分比的高度：在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置百分比的高度，子元素设置一个百分比的高度是无效的用</li><li>设置水平居中：使用margin:0 auto在standards模式下可以使元素水平居中，但在quirks模式下却会失效。</li></ol><h2 id="9、-请阐述-table-表格布局的缺点。"><a href="#9、-请阐述-table-表格布局的缺点。" class="headerlink" title="9、 请阐述 table 表格布局的缺点。"></a>9、 请阐述 table 表格布局的缺点。</h2><ol><li>太深的嵌套，比如 table &gt; tr &gt; td &gt; h3，会导致搜索引擎读取困难，而且，最直接的损失就是大大增加了冗余代码量。</li><li>灵活性差，比如要将 tr 设置 border 等属性，是不行的，得通过 td</li><li>代码臃肿，当在 table 中套用 table 的时候，阅读代码会显得异常混乱</li><li>混乱的 colspan 与 rowspan，用来布局时，频繁使用他们会造成整个文档顺序混乱。</li><li>table 需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。</li><li>不够语义</li></ol><h2 id="10、-简述一下-src-与-href-的区别。"><a href="#10、-简述一下-src-与-href-的区别。" class="headerlink" title="10、 简述一下 src 与 href 的区别。"></a>10、 简述一下 src 与 href 的区别。</h2><p>src 用于替换当前元素，href 用于在当前文档和引用资源之间确立联系。</p><ul><li>href 是指向 网络资源 所在位置，建立 引用资源 和 当前元素（锚点）/当前文档（链接） 之间的链接。</li><li>src 是指向 外部资源 的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本，img 图片和 frame 等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。</li></ul>]]></content>
      
      <categories>
          
          <category> 前端面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>博客和域名连接后,博客的重新开始</title>
      <link href="/2018/03/27/%E7%94%9F%E6%B4%BB/%E5%8D%9A%E5%AE%A2%E5%92%8C%E5%9F%9F%E5%90%8D%E8%BF%9E%E6%8E%A5%E5%90%8E-%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B/"/>
      <url>/2018/03/27/%E7%94%9F%E6%B4%BB/%E5%8D%9A%E5%AE%A2%E5%92%8C%E5%9F%9F%E5%90%8D%E8%BF%9E%E6%8E%A5%E5%90%8E-%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B/</url>
      <content type="html"><![CDATA[<p>早很久前就想将原来的博客重新更换一下，想换一个更好的主题，能够让我将我需要的知识保存并更方便查看。也是早很久前就想买个属于自己的域名。<br>腾讯来华科进行技术宣讲，现在我很庆幸我当时去了。<br>在宣讲会上可能能获取到的知识不多，但是我领到了一张腾讯云的100元优惠券。O(∩_∩)O 用那张优惠券，免费买了三年的域名使用权~<br>于是，现在我又重新开始在这里写博客啦！</p>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>ECMAScript数据类型</title>
      <link href="/2018/03/27/LearnES5/ECMAScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/03/27/LearnES5/ECMAScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>ECMAScirpt 5.1 中定义了6种数据类型，其中有5中简单数据类型（基本数据类型）:</p><ol><li><strong>Undefined：</strong>只有一个值，为undefined，意味着“空值(no value)”，适用于所有数据类型。</li><li><strong>Null：</strong>只有一个值，为null，意味着“空对象(no object)”，只适用于对象类型。（literal）</li><li><strong>Boolean：</strong>有两个值，为true与false </li><li><strong>Number：</strong>值遵循IEEE 754标准的64位浮点数的集合，没有整型数据结构。此外还包含三个特殊的值：NaN、Infinity、Infinity</li><li><strong>String：</strong>值是有穷个Unicode字符的集合。必须用’或”括起来。</li><li>还有一种复杂数据类型： <strong>Object</strong></li><li>最新的ECMAScript 6 又加了一种类型：<strong>Symbol</strong> (ECMAScript 6 新定义)</li></ol><hr><h2 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h2><p>用来检测给定变量的数据类型。<br>对一个值使用typeof操作符可能返回下列某个字符：</p><ol><li>“undefined”值未定义 </li><li>“boolean”布尔值 </li><li>“string”字符串 </li><li>“number”数值 </li><li>“object”对象或null</li><li>“function”函数</li></ol><p>使用：typeof 操作数  /  typeof(操作数)  ——&gt;圆括号不是必须的，因为typeof不是函数</p><hr><h2 id="Undefine类型"><a href="#Undefine类型" class="headerlink" title="Undefine类型"></a>Undefine类型</h2><p>首字母大写的Undefined表示的是一种数据类型，小写的undefined表示的是属于这种数据类型的唯一的一个值。<br>使用var声明变量但未进行初始化时，这个变量的值就是undefined，例如：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">message</span>;</span><br><span class="line">alert(<span class="keyword">message</span> == undefined); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>一个未初始化的变量的值为undefined，一个没有传入实参的形参变量的值为undefined，如果一个函数什么都不返回，则该函数默认返回undefined。</p><blockquote><p>注意： 对未声明的变量执行typeof操作符同样会返回undefined。</p></blockquote><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message; <span class="comment">//这个变量声明之后默认为undefined</span></span><br><span class="line"><span class="comment">// 下面这个变量未声明</span></span><br><span class="line"><span class="comment">// var age</span></span><br><span class="line">alert(<span class="keyword">typeof</span> message); <span class="comment">// "undefined"</span></span><br><span class="line">alert(<span class="keyword">typeof</span> age); <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure><hr><h2 id="Null类型"><a href="#Null类型" class="headerlink" title="Null类型"></a>Null类型</h2><p>首字母大写的Null表示的是一种数据类型，小写的null表示的是属于这种数据类型的唯一的一个值。<br>null值表示一个空对象指针：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> car = <span class="literal">null</span>;</span><br><span class="line">alert(<span class="keyword">typeof</span> car); <span class="comment">//"object"</span></span><br></pre></td></tr></table></figure><p>如果定义的变量准备用于保存对象，那么最好将该变量初始化为null。</p><p>undefined 值派生自 null，因此规定相等性测试返回 true。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span>  <span class="string">==</span> <span class="string">undefined</span> <span class="string">//</span> <span class="literal">true</span></span><br><span class="line"><span class="literal">null</span> <span class="string">===</span> <span class="string">undefined</span> <span class="string">//</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>null 是一个字面量 (而不是全局对象的一个属性，undefined 是 )</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span>);             <span class="regexp">//</span><span class="literal">null</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span>);        <span class="regexp">//</span><span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.<span class="literal">null</span>);      <span class="regexp">//</span><span class="literal">undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.<span class="literal">undefined</span>); <span class="regexp">//</span><span class="literal">undefined</span></span><br></pre></td></tr></table></figure><p><strong>null与undefined的区别</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foot); <span class="comment">// Uncaught ReferenceError: foot is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="built_in">console</span>.log(foo);  <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(bar);  <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>        <span class="comment">// object (bug in ECMAScript, should be null)</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>   <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><hr><h2 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h2><p>1、如果 Boolean 构造函数的参数不是一个布尔值，则该参数会被转换成一个布尔值。<br>2、<strong>转换规则:</strong></p><table><thead><tr><th>数据类型</th><th>true</th><th>false</th></tr></thead><tbody><tr><td>Boolean</td><td>true</td><td>false</td></tr><tr><td>String</td><td>任何非空字符串</td><td>“”（空字符串）</td></tr><tr><td>Number</td><td>任何非零数字值（包括无穷大）</td><td>0 和 NaN</td></tr><tr><td>Object</td><td>任何对象</td><td>null</td></tr><tr><td>Undefined</td><td>（不适用）</td><td>undefined</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化的时候</span></span><br><span class="line"><span class="comment">//false</span></span><br><span class="line"><span class="keyword">var</span> bfalse = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">var</span> bEmptyString = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="string">""</span>);</span><br><span class="line"><span class="keyword">var</span> bZero = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> bNaN = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">NaN</span>);</span><br><span class="line"><span class="keyword">var</span> bNull = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">var</span> bNoParam = <span class="keyword">new</span> <span class="built_in">Boolean</span>(); <span class="comment">//相当于传入undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="keyword">var</span> btrue = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">var</span> btrueString = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="string">"true"</span>);</span><br><span class="line"><span class="keyword">var</span> bfalseString = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="string">"false"</span>);</span><br><span class="line"><span class="keyword">var</span> bSuLin = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="string">"Su Lin"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>不要通过新建 Boolean 对象的方法来将一个非布尔值转化成布尔值。 直接使用 Boolean 函数才是正确的</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="built_in">Boolean</span>(expression);     <span class="comment">// 这样用</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="built_in">Boolean</span>(expression); <span class="comment">// 而不要这样!</span></span><br></pre></td></tr></table></figure><h2 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h2><p>根据 ECMAScript 标准，JavaScript 中只有一种数字类型：基于 IEEE 754 标准的双精度 64 位二进制格式的值（-(253 -1) 到 253 -1）。它并没有为整数给出一种特定的类型。除了能够表示浮点数外，还有一些带符号的值：+Infinity，-Infinity 和 NaN (非数值，Not-a-Number)</p><h3 id="1-数值字面量格式："><a href="#1-数值字面量格式：" class="headerlink" title="1.数值字面量格式："></a>1.数值字面量格式：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intNum = <span class="number">55</span>; <span class="comment">//十进制整数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> octalNum1 = <span class="number">070</span>; <span class="comment">//八进制 56</span></span><br><span class="line"><span class="keyword">var</span> octalNum1 = <span class="number">079</span>; <span class="comment">//无效，解析为79</span></span><br><span class="line"><span class="keyword">var</span> octalNum1 = <span class="number">08</span>;  <span class="comment">//无效，解析为8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hexNum1 = <span class="number">0xA</span>;  <span class="comment">//十六进制 10</span></span><br><span class="line"><span class="keyword">var</span> hexNum1 = <span class="number">0x1f</span>; <span class="comment">//十六进制31</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> floatNum1 = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">var</span> floatNum2 = <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">var</span> floatNum3 = <span class="number">.1</span>; <span class="comment">//有效但不推荐</span></span><br><span class="line"><span class="keyword">var</span> floatNum4 = <span class="number">1.0</span>; <span class="comment">//小数点后面没有数字，转换为整数 解析为1</span></span><br><span class="line"><span class="keyword">var</span> floatNum5 = <span class="number">10.0</span>; <span class="comment">//整数 解析为10</span></span><br><span class="line"><span class="keyword">var</span> floatNum6 = <span class="number">3.125e7</span>; <span class="comment">//等于31250000</span></span><br></pre></td></tr></table></figure><p>数字类型只有一个整数，它有两种表示方法： 0 可表示为 -0 和 +0（”0” 是 +0 的简写）。 在实践中，这也几乎没有影响。 例如 +0 === -0 为真。 但是，你可能要注意除以0的时候：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">42 </span>/ +<span class="number">0</span>; // Infinity</span><br><span class="line"><span class="symbol">42 </span>/ -<span class="number">0</span>; // -Infinity</span><br></pre></td></tr></table></figure><h3 id="2-数值范围"><a href="#2-数值范围" class="headerlink" title="2.数值范围"></a>2.数值范围</h3><table><thead><tr><th>表示</th><th>描述</th></tr></thead><tbody><tr><td>Number.MIN_VALUE</td><td>最小数值，一般为5e-324</td></tr><tr><td>Number.MAX_VALUE</td><td>最大数值，一般为1.7976931348623157e+308</td></tr><tr><td>Infinity</td><td>正无穷，是不能参与计算的数值</td></tr><tr><td>-Infinity</td><td>负无穷，是不能参与计算的数值</td></tr></tbody></table><h3 id="3-NAN"><a href="#3-NAN" class="headerlink" title="3.NAN"></a>3.NAN</h3><p>如果参数无法被转换为数字，则返回 NaN。</p><ul><li>任何涉及NaN的操作（例如NaN/10）都会返回NaN。</li><li>NaN与任何值都不相等，包括NaN本身。</li></ul><p>ECMAScript定义了isNaN()函数来确定某个参数是否“不是数值”。isNaN()在接收到一个值之后，会尝试将这个值转换为数值。某些不是数值的值会直接转换为数值，而任何不能被转换为数值的值都会导致这个函数返回true。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>);        <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="built_in">Number</span>.NaN); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">0</span> / <span class="number">0</span>)       <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// e.g. these would have been true with global isNaN()</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">"NaN"</span>);      <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">undefined</span>);  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(&#123;&#125;);         <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">"blabla"</span>);   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// These all return false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">37</span>);</span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">"37"</span>);</span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">"37.37"</span>);</span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">""</span>);</span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">" "</span>);</span><br></pre></td></tr></table></figure><p>将非数值转换为数值：Number()、parseInt()、parseFloat()</p><p><strong>Number() 可用于任何数据类型</strong></p><h3 id="转换规则："><a href="#转换规则：" class="headerlink" title="转换规则："></a>转换规则：</h3><ul><li>Boolean值：true false分别转换为1 0</li><li>数字值：简单的传入和返回</li><li>null值：0</li><li>undefined值：返回NaN</li><li>字符串：<ul><li>只包含数字（包括前面带正、负号）则转换为十进制数值</li><li>包含有效的浮点格式，如“1.1”，则转换为对应的浮点数</li><li>包含有效的十六进制格式，如“0xf”，则转换为相同大小的十进制整数</li><li>字符串为空，则转换为0</li><li>字符串中包含除上述格式之外的字符，则转换为NaN</li></ul></li><li>若为对象，则调用对象的valueof()方法，然后依照前面的规则转换返回值。若转换的结果是NaN，则调用对象的toString()方法，然后再次依照前面的规则转换返回值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">Number</span>(<span class="string">"hello world!"</span>); <span class="comment">//NaN</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">Number</span>(<span class="string">""</span>);             <span class="comment">//0</span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">Number</span>(<span class="string">"000011"</span>);       <span class="comment">//11</span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">Number</span>(<span class="literal">true</span>);           <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//处理整数常用parseInt()函数</span></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseInt</span>(<span class="string">"1234blue"</span>); <span class="comment">//1234</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">""</span>);         <span class="comment">//NaN</span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseInt</span>(<span class="string">"0xA"</span>);      <span class="comment">//10</span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseInt</span>(<span class="number">22.5</span>);       <span class="comment">//22</span></span><br><span class="line"><span class="keyword">var</span> num5 = <span class="built_in">parseInt</span>(<span class="string">"070"</span>);      <span class="comment">//ECMAScript 3 认为是56 八进制，ECMAScript 5 认为是70 十进制</span></span><br><span class="line"><span class="keyword">var</span> num6 = <span class="built_in">parseInt</span>(<span class="string">"70"</span>);       <span class="comment">//70 十进制</span></span><br><span class="line"><span class="keyword">var</span> num7 = <span class="built_in">parseInt</span>(<span class="string">"0xf"</span>);      <span class="comment">//15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//处理浮点数常用parseFloat()函数</span></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseFloat</span>(<span class="string">"1234blue"</span>); <span class="comment">//1234</span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseFloat</span>(<span class="string">"0xA"</span>);      <span class="comment">//0</span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseFloat</span>(<span class="string">"22.5"</span>);     <span class="comment">//22.5</span></span><br><span class="line"><span class="keyword">var</span> num5 = <span class="built_in">parseFloat</span>(<span class="string">"22.34.5"</span>);  <span class="comment">//22.34</span></span><br><span class="line"><span class="keyword">var</span> num6 = <span class="built_in">parseFloat</span>(<span class="string">"0908.5"</span>);   <span class="comment">//908.5</span></span><br><span class="line"><span class="keyword">var</span> num7 = <span class="built_in">parseFloat</span>(<span class="string">"3.125e7"</span>);  <span class="comment">//31250000</span></span><br></pre></td></tr></table></figure><hr><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>1、JavaScript的字符串类型用于表示文本数据。它是一组16位的无符号整数值的“元素”。<br>2、在字符串中的每个元素占据了字符串的位置。第一个元素的索引为0，下一个是索引1，依此类推。字符串的长度是它的元素的数量<br>3、与 C 语言不同，JavaScript 中字符串是不可变的（译注：如，JavaScript 中对字符串的操作一定返回了一个新字符串，原始字符串并没有被改变）<br>Javascript中一切都是object-based。</p><h3 id="创建string，也有两种类型"><a href="#创建string，也有两种类型" class="headerlink" title="创建string，也有两种类型"></a>创建string，也有两种类型</h3><ol><li>使用字面量方式创建的字符串，为基本类型的 string              <ul><li>实际上保存就是的值，是一个基本类型 </li></ul></li><li>使用String()创建的字符串，为基本类型的 string     </li><li>使用构造函数 new String()的方式创建的字符串，为对象类型的 string  <ul><li>实际上保存的是一个指向字符串对象的指针</li></ul></li></ol><h3 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h3><ul><li>第一种方法：toString() 返回相应值的字符串表现（null与undefined值没有这个方法）</li><li>第二种方法：在不知道转换的值是不是null或undefined情况下，可以用转型函数String()，能将任何类型的值转换为字符串。</li></ul><hr><h2 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h2><p>数据和功能的集合。是所有对象的基础，所有对象都具有Object的基本属性和方法。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>; <span class="comment">// 有效，但不推荐省略圆括号</span></span><br></pre></td></tr></table></figure><h3 id="①constructor属性"><a href="#①constructor属性" class="headerlink" title="①constructor属性"></a>①constructor属性</h3><p>构造函数属性,可确定当前对象的构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">console</span>.log(o.constructor == <span class="built_in">Object</span>);<span class="comment">//true</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="built_in">console</span>.log(arr.constructor == <span class="built_in">Array</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="②hasOwnProperty-propertyName"><a href="#②hasOwnProperty-propertyName" class="headerlink" title="②hasOwnProperty(propertyName)"></a>②hasOwnProperty(propertyName)</h3><p>判断属性是否存在于当前对象实例中（而不是在实例的原型中）。</p><h3 id="③isPrototypeOf-object"><a href="#③isPrototypeOf-object" class="headerlink" title="③isPrototypeOf(object)"></a>③isPrototypeOf(object)</h3><p>判断传入的对象是否是当前对象的原型</p><h3 id="④propertyIsEnumerable-propertyName"><a href="#④propertyIsEnumerable-propertyName" class="headerlink" title="④propertyIsEnumerable(propertyName)"></a>④propertyIsEnumerable(propertyName)</h3><p>判断给定的属性是否能使用for-in语句来枚举</p><h3 id="⑤toLocaleString"><a href="#⑤toLocaleString" class="headerlink" title="⑤toLocaleString()"></a>⑤toLocaleString()</h3><p>返回对象的字符串表示，该字符串与执行环境的地区对应</p><h3 id="⑥toString"><a href="#⑥toString" class="headerlink" title="⑥toString()"></a>⑥toString()</h3><p>返回对象的字符串表示</p><h3 id="⑦valueOf"><a href="#⑦valueOf" class="headerlink" title="⑦valueOf()"></a>⑦valueOf()</h3><p>返回对象的字符串、数值或布尔值表示</p><hr><h2 id="Symbol类型"><a href="#Symbol类型" class="headerlink" title="Symbol类型"></a>Symbol类型</h2><p>ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。 可以从根本上防止属性名的冲突。</p><p>Symbol值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">typeof</span> s            <span class="comment">// "symbol"</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量s就是一个独一无二的值。typeof运算符的结果，表明变量s是 Symbol 数据类型，而不是字符串之类的其他类型。</p><blockquote><p>注意， Symbol 函数前不能使用 new 命令，否则会报错。这是因为生成的  Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol  值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p></blockquote><p>Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);</span><br><span class="line">s1 <span class="comment">// Symbol(foo)</span></span><br><span class="line">s2 <span class="comment">// Symbol(bar)</span></span><br><span class="line">s1.toString() <span class="comment">// "Symbol(foo)"</span></span><br><span class="line">s2.toString() <span class="comment">// "Symbol(bar)"</span></span><br></pre></td></tr></table></figure><p>上面代码中，s1和s2是两个 Symbol 值。如果不加参数，它们在控制台的输出都是Symbol()，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。</p><blockquote><p>注意，Symbol 函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的 Symbol 函数的返回值是不相等的。</p></blockquote><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  没有参数的情况</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>();</span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  有参数的情况</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，s1和s2都是Symbol函数的返回值，而且参数相同，但是它们是不相等的。</p><p>由于每一个Symbol值都是不相等的，这意味着Symbol值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。Symbol值作为对象属性名时，不能用点运算符。在对象的内部，使用Symbol值定义属性时，Symbol值必须放在方括号之中。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mySymbol = Symbol();</span><br><span class="line"><span class="comment">//  第一种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">'Hello!'</span>;</span><br><span class="line"><span class="comment">//  第二种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">[<span class="meta">mySymbol</span>]: <span class="string">'Hello!'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//  第三种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">Object.defineProperty(a, mySymbol, &#123; <span class="keyword">value</span>: <span class="string">'Hello!'</span> &#125;);</span><br><span class="line"><span class="comment">//  以上写法都得到同样结果</span></span><br><span class="line">a[mySymbol] <span class="comment">// "Hello!"</span></span><br></pre></td></tr></table></figure><p><strong>Symbol 值不能与其他类型的值进行运算，会报错。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym = <span class="built_in">Symbol</span>(<span class="string">'My symbol'</span>);</span><br><span class="line"><span class="string">"your symbol is "</span> + sym</span><br><span class="line"><span class="comment">// TypeError: can't convert symbol to string</span></span><br><span class="line"><span class="string">`your symbol is <span class="subst">$&#123;sym&#125;</span>`</span></span><br><span class="line"><span class="comment">// TypeError: can't convert symbol to string</span></span><br></pre></td></tr></table></figure><p>但是， Symbol 值可以显式转为字符串。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym = <span class="built_in">Symbol</span>(<span class="string">'My symbol'</span>);</span><br><span class="line"><span class="built_in">String</span>(sym) <span class="comment">// 'Symbol(My symbol)'</span></span><br><span class="line">sym.toString() <span class="comment">// 'Symbol(My symbol)'</span></span><br></pre></td></tr></table></figure><h3 id="Symbol-for-，-Symbol-keyFor"><a href="#Symbol-for-，-Symbol-keyFor" class="headerlink" title="Symbol.for() ， Symbol.keyFor()"></a>Symbol.for() ， Symbol.keyFor()</h3><p>有时，我们希望重新使用同一个 Symbol 值，Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'foo'</span>);</span><br><span class="line">s1 === s2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中， s1 和 s2 都是 Symbol 值，但是它们都是同样参数的Symbol.for方法生成的，所以实际上是同一个值。</p><p>Symbol.for()与Symbol()这两种写法，都会生成新的 Symbol 。<br><strong>区别：</strong><br>前者会被登记在全局环境中供搜索，后者不会。</p><ul><li>Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的 key 是否已经存在，如果不存在才会新建一个值。比如，如果你调用</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">"cat"</span>) <span class="number">30</span>次，每次都会返回同一个 <span class="built_in">Symbol</span> 值，但是调用<span class="built_in">Symbol</span>(<span class="string">"cat"</span>) <span class="number">30</span> 次，会返回 <span class="number">30</span> 个不同的 <span class="built_in">Symbol</span> 值。</span><br><span class="line"><span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">"bar"</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>(<span class="string">"bar"</span>)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，由于Symbol()写法没有登记机制，所以每次调用都会返回一个不同的值。</p><ul><li>Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key 。</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1) <span class="comment">// "foo"</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量s2属于未登记的 Symbol 值，所以返回undefined。</p><blockquote><p>需要注意的是，Symbol.for为 Symbol 值登记的名字，是全局环境的，可以在不同的 iframe 或 service worker中取到同一个值。</p></blockquote>]]></content>
      
      <categories>
          
          <category> LearnES5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
  
  
    
  
</search>
