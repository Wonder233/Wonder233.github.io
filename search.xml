<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>实习的那点事</title>
      <link href="/2018/05/16/%E7%94%9F%E6%B4%BB/%E5%AE%9E%E4%B9%A0%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B/"/>
      <url>/2018/05/16/%E7%94%9F%E6%B4%BB/%E5%AE%9E%E4%B9%A0%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B/</url>
      <content type="html"><![CDATA[<h2 id="一-实习批准拉锯战"><a href="#一-实习批准拉锯战" class="headerlink" title="一 实习批准拉锯战"></a>一 实习批准拉锯战</h2><p>今年实验室找实习感觉都找得挺不错的，总共五个人，三个拿到腾讯的 offer，一个拿到京东的，一个拿到某家证券公司的。<br>本以为今年的我们出来实习也会跟以前的师兄师姐一样，只需要跟导师说一下实习时间就行了，结果没想到突然 BOSS 在实验室群里放出了实验室规定，要求极其苛刻。。。后期把我派去公司干活，做跟研究无关的项目肯定是发不出论文的，于是我去找他商量。<br>。。。。（因为实习的事跟他交锋四次）<br>随着漫长的半个月的拉锯，我终于让导师同意放我出来实习了。</p><h2 id="二-准备工作"><a href="#二-准备工作" class="headerlink" title="二 准备工作"></a>二 准备工作</h2><p>为了出来实习我答应了 BOSS 的一些条件，其中有一个就是给实验室和公司做一个提交周报的小项目。本来我慢吞吞的做的，一下子跟打了鸡血一样，周末也在公司加班加点做。于是，为期不到三天就大致做出来了。</p><h2 id="三-去深圳"><a href="#三-去深圳" class="headerlink" title="三 去深圳"></a>三 去深圳</h2><p>我买了5月16日早上9点的票。只要四个小时就能到深圳了。<br>那天，早上6点多我就醒来，心情很是激动，感觉睡不着了，熬到大概7点10就起来开始洗漱。<br>最后还是着急忙慌的才赶到高铁站顺利坐上了去深圳的高铁！<br>中途四个小时，真的就是各种想着未来，想着希望。觉得真的好开心，努力了大半年的小目标终于要实现的感觉真的是倍儿棒。</p>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS</title>
      <link href="/2018/04/17/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/CSS/"/>
      <url>/2018/04/17/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/CSS/</url>
      <content type="html"><![CDATA[<h2 id="1、请简述盒模型。"><a href="#1、请简述盒模型。" class="headerlink" title="1、请简述盒模型。"></a>1、请简述盒模型。</h2><p><strong>IE6盒模型</strong> 与 <strong>W3C标准盒模型</strong>。</p><p>文档中的每个元素被描绘为矩形盒子。盒子有四个边界：外边距边界 <code>margin</code>, 边框边界 <code>border</code>, 内边距边界 <code>padding</code> 与内容边界 <code>content</code> 。</p><blockquote><p>CSS3 中有个 <code>box-sizing</code> 属性可以控制盒子的计算方式。</p></blockquote><p><strong>W3C盒子模型 content-box：</strong><br><code>padding</code> 和 <code>border</code> 不被包含在定义的 <code>width</code> 和 <code>height</code> 之内。对象的实际宽度 <code>Element width = width + border + padding</code>，但占有页面位置还要加上 <code>margin</code>。</p><p><strong>IE6盒子模型 border-box：</strong><br><code>padding</code> 和 <code>border</code> 被包含在定义的 <code>width</code> 和 <code>height</code> 之内。对象的实际宽度 <code>Element width = width</code>， 即使定义有 <code>border</code> 和 <code>padding</code> 也不会改变对象的实际宽度。</p><h2 id="2、什么是CSS-Hack"><a href="#2、什么是CSS-Hack" class="headerlink" title="2、什么是CSS Hack?"></a>2、什么是CSS Hack?</h2><p>针对不同的浏览器写不同的 CSS，就是 CSS Hack。</p><p>IE浏览器 Hack 一般又分为三种，<strong>条件Hack</strong>、<strong>属性级Hack</strong>、<strong>选择符Hack</strong>。<br>例如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1、条件Hack --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if IE]&gt;</span></span><br><span class="line"><span class="comment">  &lt;style&gt;</span></span><br><span class="line"><span class="comment">    .test&#123;color:red;&#125;</span></span><br><span class="line"><span class="comment">  &lt;/style&gt;</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* 2、属性Hack */</span></span><br><span class="line"><span class="selector-class">.test</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#090</span>\<span class="number">9</span>; <span class="comment">/* For IE8+ */</span></span><br><span class="line">  *color: #f00; /* For IE7 and earlier */</span><br><span class="line">  _<span class="selector-tag">color</span>: <span class="selector-id">#ff0</span>; <span class="comment">/* For IE6 and earlier */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 3、选择符Hack */</span></span><br><span class="line"></span><br><span class="line">* <span class="selector-tag">html</span> <span class="selector-class">.test</span> &#123; <span class="comment">/* For IE6 and earlier */</span></span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#090</span>;</span><br><span class="line">&#125; </span><br><span class="line">* + <span class="selector-tag">html</span> <span class="selector-class">.test</span> &#123; <span class="comment">/* For IE7 */</span></span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ff0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、px和em的区别。"><a href="#3、px和em的区别。" class="headerlink" title="3、px和em的区别。"></a>3、px和em的区别。</h2><p>px和em都是长度单位。<br><strong>区别：</strong></p><ul><li>px 的值是固定的，指定是多少就是多少，计算比较容易。</li><li>em 的值不是固定的，并且 em 会继承父级元素的字体大小。</li></ul><p>浏览器的默认字体高都是 16 px。所以未经调整的浏览器都符合: 1 em = 16 px。那么 12 px = 0.75 em，10 px = 0.625 em。</p><h2 id="4、-link和-import的区别"><a href="#4、-link和-import的区别" class="headerlink" title="4、 link和@import的区别?"></a>4、 link和@import的区别?</h2><p>两者都是外部引用CSS的方式。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'stylesheet'</span> <span class="attr">rev</span>=<span class="string">'stylesheet'</span> <span class="attr">href</span>=<span class="string">'CSS文件 '</span> <span class="attr">type</span>=<span class="string">'text/css'</span> <span class="attr">media</span>=<span class="string">'all'</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">'text/css'</span> <span class="attr">media</span>=<span class="string">'screen'</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">     @<span class="keyword">import</span> url(<span class="string">'CSS文件 '</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>区别：</strong></p><ul><li>link 是 XHTML 标签，除了加载 CSS 外，还可以定义 RSS 等其他事务； @import 属于 CSS 范畴，只能加载 CSS 。</li><li>link 引用 CSS 时，在页面载入时同时加载； @import 需要页面网页完全载入以后加载。</li><li>link 是 XHTML 标签，无兼容问题； @import 是在 CSS2.1 提出的，低版本的浏览器 IE5 以下不支持。</li><li>link 支持使用 Javascript 控制 DOM 去改变样式；而 @import 不支持。</li><li>link 方式的样式的权重 高于 @import 的权重。</li></ul><h2 id="5、-请你说说CSS选择器的类型有哪些，并举几个例子说明其用法？"><a href="#5、-请你说说CSS选择器的类型有哪些，并举几个例子说明其用法？" class="headerlink" title="5、 请你说说CSS选择器的类型有哪些，并举几个例子说明其用法？"></a>5、 请你说说CSS选择器的类型有哪些，并举几个例子说明其用法？</h2><ul><li>ID选择器（如：<code>#myid</code>）</li><li>类选择器（如： <code>.myclassname</code>）</li><li>标签选择器（如：<code>body</code>，<code>div</code>，<code>p</code>， <code>ul</code>，<code>li</code>）</li><li>相邻选择器（如：<code>h1 + p</code>）</li><li>子选择器（如：<code>ul &gt; li</code>）</li><li>后代选择器（如：<code>li a</code>）</li><li>通配选择器（如：<code>*</code>号）</li><li>属性选择器（CSS2 引入，如：<code>h1[class]</code>，<code>input[type=&quot;text&quot;]</code>，<code>input[class~=&quot;btn&quot;]</code> ）<ul><li>字符串匹配的属性选择符~存在 ^开头 $结尾 *包含子串 |等于或以其开头</li></ul></li><li>伪类选择器（如，<code>a:visited</code>，<code>input:focus</code>）</li><li>伪元素选择器（如，<code>p:first-line</code>）</li></ul><h2 id="6、-CSS有什么特殊性-（优先级、计算特殊值）"><a href="#6、-CSS有什么特殊性-（优先级、计算特殊值）" class="headerlink" title="6、 CSS有什么特殊性?（优先级、计算特殊值）"></a>6、 CSS有什么特殊性?（优先级、计算特殊值）</h2><p><strong>优先级：</strong></p><ol><li>同类型，同级别的样式后者先于前者</li><li>ID &gt; 类样式 &gt; 标签 &gt; *</li><li>内联 &gt; ID选择器 &gt; 伪类 &gt; 属性选择器 &gt; 类选择器 &gt; 标签选择器 &gt; 通用选择器(*) &gt; 继承的样式</li><li>具体 &gt; 泛化的，特殊性即css优先级</li><li>近的 &gt; 远的 (内嵌样式 &gt; 内部样式表 &gt; 外联样式表)<ul><li>内嵌样式：内嵌在元素中，<code>&lt;span style=&quot;color:red&quot;&gt;span&lt;/span&gt;</code></li><li>内部样式表：在页面中的样式，写在<code>&lt;style&gt;&lt;/style&gt;</code>中的样式</li><li>外联样式表：单独存在一个 css 文件中，通过 <code>link</code> 引入或 <code>import</code> 导入的样式</li></ul></li><li><code>!important</code> 权重最高，比 <code>inline style</code> 还要高</li></ol><p><strong>计算特殊性值：</strong><br><code>!important</code> &gt; 内嵌 &gt; ID &gt; 类 &gt; 标签 | 伪类 | 属性选择 &gt; 伪对象 &gt; 继承 &gt; 通配符</p><p><strong>权重、特殊性计算法：</strong></p><ol><li>内联样式 <code>style=&quot; &quot;</code>，权值 1，0，0，0</li><li>ID 选择器 <code>#name</code>，权值 0，1，0，0</li><li>类选择器 <code>.class</code>、伪类选择器<code>:hover</code>、属性选择器<code>[class=&quot; &quot;]</code>，权值 0，0，1，0</li><li>元素选择器 <code>div</code>、伪元素选择器 <code>:nth-child(1)</code>，权值 0，0，0，1</li></ol><h2 id="7、为什么重置浏览器默认样式，如何重置默浏览器认样式？"><a href="#7、为什么重置浏览器默认样式，如何重置默浏览器认样式？" class="headerlink" title="7、为什么重置浏览器默认样式，如何重置默浏览器认样式？"></a>7、为什么重置浏览器默认样式，如何重置默浏览器认样式？</h2><p>每种浏览器都有一套默认的样式表，即 <code>user agent stylesheet</code>，网页在没有指定的样式时，按浏览器内置的样式表来渲染。这是合理的，像 word 中也有一些预留样式，可以让我们的排版更美观整齐。</p><p>不同浏览器甚至同一浏览器不同版本的默认样式是不同的。但这样会有很多兼容问题。</p><ol><li>最简单的办法：（不推荐使用）<code>*{margin: 0;padding: 0;}</code>。</li><li>使用 CSS Reset 可以将所有浏览器默认样式设置成一样。</li><li><code>normalize</code>：也许有些 CSS Reset 过于简单粗暴，有点伤及无辜，<code>normalize</code> 是另一个选择。<code>bootstrap</code> 已经引用该 css 来重置浏览器默认样式，比普通的 CSS Reset 要精细一些，保留浏览器有用的默认样式，支持包括手机浏览器在内的超多浏览器，同时对 HTML5 元素、排版、列表、嵌入的内容、表单和表格都进行了一般化。</li></ol><p>天猫使用 CSS Reset 重置浏览器默认样式：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">charset</span> <span class="string">"gb2312"</span>;</span><br><span class="line"><span class="selector-tag">body</span>, <span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, <span class="selector-tag">h6</span>, <span class="selector-tag">hr</span>, <span class="selector-tag">p</span>, <span class="selector-tag">blockquote</span>, <span class="selector-tag">dl</span>, <span class="selector-tag">dt</span>, <span class="selector-tag">dd</span>, <span class="selector-tag">ul</span>, <span class="selector-tag">ol</span>, <span class="selector-tag">li</span>, <span class="selector-tag">pre</span>, <span class="selector-tag">form</span>, <span class="selector-tag">fieldset</span>, <span class="selector-tag">legend</span>, <span class="selector-tag">button</span>, <span class="selector-tag">input</span>, <span class="selector-tag">textarea</span>, <span class="selector-tag">th</span>, <span class="selector-tag">td</span> &#123;<span class="attribute">margin</span>: <span class="number">0</span>;<span class="attribute">padding</span>: <span class="number">0</span>&#125;</span><br><span class="line"><span class="selector-tag">body</span>, <span class="selector-tag">button</span>, <span class="selector-tag">input</span>, <span class="selector-tag">select</span>, <span class="selector-tag">textarea</span> &#123;<span class="attribute">font</span>: <span class="number">12px</span> <span class="string">"microsoft yahei"</span>;<span class="attribute">line-height</span>: <span class="number">1.5</span>;<span class="attribute">-ms-overflow-style</span>: scrollbar&#125;</span><br><span class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, <span class="selector-tag">h6</span> &#123;<span class="attribute">font-size</span>: <span class="number">100%</span>&#125;</span><br><span class="line"><span class="selector-tag">ul</span>, <span class="selector-tag">ol</span> &#123;<span class="attribute">list-style</span>: none&#125;</span><br><span class="line"><span class="selector-tag">a</span> &#123;<span class="attribute">text-decoration</span>: none;<span class="attribute">cursor</span>:pointer&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">text-decoration</span>: underline&#125;</span><br><span class="line"><span class="selector-tag">img</span> &#123;<span class="attribute">border</span>: <span class="number">0</span>&#125;</span><br><span class="line"><span class="selector-tag">button</span>, <span class="selector-tag">input</span>, <span class="selector-tag">select</span>, <span class="selector-tag">textarea</span> &#123;<span class="attribute">font-size</span>: <span class="number">100%</span>&#125;</span><br><span class="line"><span class="selector-tag">table</span> &#123;<span class="attribute">border-collapse</span>: collapse;<span class="attribute">border-spacing</span>: <span class="number">0</span>&#125;</span><br><span class="line"><span class="selector-class">.clear</span> &#123;<span class="attribute">clear</span>:both&#125;</span><br><span class="line"><span class="selector-class">.fr</span> &#123;<span class="attribute">float</span>:right&#125;</span><br><span class="line"><span class="selector-class">.fl</span> &#123;<span class="attribute">float</span>:left&#125;</span><br><span class="line"><span class="selector-class">.block</span> &#123;<span class="attribute">display</span>:block;<span class="attribute">text-indent</span>:-<span class="number">999em</span>&#125;</span><br></pre></td></tr></table></figure></p><h2 id="8、-说说浮动元素以及引起的问题和解决办法"><a href="#8、-说说浮动元素以及引起的问题和解决办法" class="headerlink" title="8、 说说浮动元素以及引起的问题和解决办法?"></a>8、 说说浮动元素以及引起的问题和解决办法?</h2><p>浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。</p><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>（1）父元素的高度无法被撑开，影响与父元素同级的元素<br>（2）与浮动元素同级的非浮动元素会跟随其后<br>（3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构</p><h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><p>(1) 结尾处加空<code>div</code>标签 <code>clear:both</code><br><strong>原理：</strong>添加一个空div，利用css提高的clear:both清除浮动，让父级div能自动获取到高度<br><strong>优点：</strong>简单、代码少、浏览器支持好、不容易出现怪问题<br><strong>缺点：</strong>不少初学者不理解原理；如果页面浮动布局多，就要增加很多空div，让人感觉很不好<br><strong>建议：</strong>不推荐使用，但此方法是以前主要使用的一种清除浮动方法</p><p>(2) 父元素<code>div</code>定义 <code>overflow:hidden</code><br><strong>原理：</strong>必须定义<code>width</code>或<code>zoom:1</code>，同时不能定义<code>height</code>，使用<code>overflow:hidden</code>时，浏览器会自动检查浮动区域的高度<br><strong>优点：</strong>简单、代码少、浏览器支持好<br><strong>缺点：</strong>不能和<code>position</code>配合使用，因为超出的尺寸的会被隐藏。<br><strong>建议：</strong>只推荐没有使用<code>position</code>或对<code>overflow:hidden</code>理解比较深的朋友使用。</p><p>(3) 父元素<code>div</code>定义 伪类<code>:after</code> 和 <code>zoom</code><br><strong>原理：</strong>IE8 以上和非 IE 浏览器才支持<code>:after</code>，原理和方法 2 有点类似，<code>zoom</code>(IE 专有属性)可解决 IE6, IE7 浮动问题<br><strong>优点：</strong>浏览器支持好、不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等）<br><strong>缺点：</strong>代码多、不少初学者不理解原理，要两句代码结合使用才能让主流浏览器都支持。<br><strong>建议：</strong>推荐使用，建议定义公共类，以减少 CSS 代码。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.div1</span>&#123;<span class="attribute">background</span>:<span class="number">#000080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red;&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.div2</span>&#123;<span class="attribute">background</span>:<span class="number">#800080</span>;<span class="attribute">border</span>:<span class="number">1px</span> solid red;<span class="attribute">height</span>:<span class="number">100px</span>;<span class="attribute">margin-top</span>:<span class="number">10px</span>&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.left</span>&#123;<span class="attribute">float</span>:left;<span class="attribute">width</span>:<span class="number">20%</span>;<span class="attribute">height</span>:<span class="number">200px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.right</span>&#123;<span class="attribute">float</span>:right;<span class="attribute">width</span>:<span class="number">30%</span>;<span class="attribute">height</span>:<span class="number">80px</span>;<span class="attribute">background</span>:<span class="number">#DDD</span>&#125;</span></span><br><span class="line"><span class="css"><span class="comment">/*清除浮动代码*/</span></span></span><br><span class="line"><span class="css"><span class="selector-class">.clearfloat</span><span class="selector-pseudo">:after</span>&#123;</span></span><br><span class="line"><span class="css">     <span class="selector-tag">display</span><span class="selector-pseudo">:block</span>;</span></span><br><span class="line"><span class="css">     <span class="selector-tag">clear</span><span class="selector-pseudo">:both</span>;</span></span><br><span class="line"><span class="css">     <span class="selector-tag">content</span><span class="selector-pseudo">:""</span>;</span></span><br><span class="line"><span class="css">     <span class="selector-tag">visibility</span><span class="selector-pseudo">:hidden</span>;</span></span><br><span class="line"><span class="css">     <span class="selector-tag">height</span><span class="selector-pseudo">:0</span></span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.clearfloat</span>&#123; <span class="attribute">zoom</span>:<span class="number">1</span> &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div1 clearfloat"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>Left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>Right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div2"</span>&gt;</span></span><br><span class="line">     div2</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="9、-简要说一下CSS的元素分类。"><a href="#9、-简要说一下CSS的元素分类。" class="headerlink" title="9、 简要说一下CSS的元素分类。"></a>9、 简要说一下CSS的元素分类。</h2><ul><li>块级元素：div, p, h1, form, ul, li;</li><li>行内元素 : span, a, label, input, img, strong, em;</li></ul><p><code>block</code>，<code>inline</code>和<code>inlinke-block</code>比较：<br>• <strong>display:block</strong></p><ol><li><code>block</code>元素会独占一行，多个<code>block</code>元素会各自新起一行。默认情况下，<code>block</code>元素宽度自动填满其父元素宽度。</li><li><code>block</code>元素可以设置<code>width</code>，<code>height</code>属性。块级元素即使设置了宽度,仍然是独占一行。</li><li><code>block</code>元素可以设置<code>margin</code>和<code>padding</code>属性。</li></ol><p>• <strong>display:inline</strong></p><ol><li><code>inline</code>元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。</li><li><code>inline</code>元素设置<code>width</code>，<code>height</code>属性无效。</li><li><code>inline</code>元素的<code>margin</code>和<code>padding</code>属性，水平方向的<code>padding-left</code>， <code>padding-right</code>，<code>margin-left</code>， <code>margin-right</code>都产生边距效果；但竖直方向的<code>padding-top</code>，<code>padding-bottom</code>， <code>margin-top</code>， <code>margin-bottom</code>不会产生边距效果。</li></ol><p>• <strong>display:inline-block</strong><br>简单来说就是将对象呈现为 <code>inline</code> 对象，但是对象的内容作为 <code>block</code> 对象呈现。之后的内联对象会被排列在同一行内。</p><blockquote><p>例如：<br>给一个 <code>link</code>（<code>a</code>元素）<code>inline-block</code>属性值，使其既具有<code>block</code>的宽度高度特性又具有 <code>inline</code> 的同行特性。</p></blockquote><p>补充说明：</p><ol><li>一般我们会用<code>display:block</code>，<code>display:inline</code>或者<code>display:inline-block</code>来调整元素的布局级别，其实<code>display</code>的参数远远不止这三种，仅仅是比较常用而已。</li><li>IE（低版本 IE）本来是不支持<code>inline-block</code>的，所以在 IE 中对内联元素使用<code>display:inline-block</code>，理论上 IE 是不识别的，但使用<code>display:inline-block</code>在 IE 下会触发 layout，从而使内联元素拥有了<code>display:inline-block</code>属性的表象。</li></ol><h2 id="10、谈谈你对CSS中刻度的认识？"><a href="#10、谈谈你对CSS中刻度的认识？" class="headerlink" title="10、谈谈你对CSS中刻度的认识？"></a>10、谈谈你对CSS中刻度的认识？</h2><p><strong>在CSS中刻度是用于设置元素尺寸的单位。</strong></p><ol><li>特殊值 0 可以省略单位。例如：<code>margin : 0 px</code> 可以写成 <code>margin : 0</code></li><li>一些属性可能允许有负长度值，或者有一定的范围限制。如果不支持负长度值，那应该变换到能够被支持的最近的一个长度值。</li><li>长度单位包括：相对单位和绝对单位。</li></ol><p>相对长度单位有： em，rem， ex，ch，vw，vh，vmax，vmin<br>绝对长度单位有： cm，mm，q，in，pt，pc，px<br>绝对长度单位：1 in = 2.54 cm = 25.4 mm = 72 pt = 6 pc = 96 px</p><h3 id="文本相对长度单位：em"><a href="#文本相对长度单位：em" class="headerlink" title="文本相对长度单位：em"></a>文本相对长度单位：em</h3><p>相对长度单位是相对于当前对象内文本的字体尺寸，如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。(相对父元素的字体大小倍数)<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123; <span class="attribute">font-size</span>: <span class="number">14px</span>; &#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123; <span class="attribute">font-size</span>: <span class="number">16px</span>; &#125;</span><br><span class="line"><span class="selector-class">.size1</span> <span class="selector-tag">p</span> &#123; <span class="attribute">font-size</span>: <span class="number">1em</span>; &#125;</span><br><span class="line"><span class="selector-class">.size2</span> <span class="selector-tag">p</span> &#123; <span class="attribute">font-size</span>: <span class="number">2em</span>; &#125;</span><br><span class="line"><span class="selector-class">.size3</span> <span class="selector-tag">p</span> &#123; <span class="attribute">font-size</span>: <span class="number">3em</span>; &#125;</span><br></pre></td></tr></table></figure></p><h3 id="文本相对长度单位：rem"><a href="#文本相对长度单位：rem" class="headerlink" title="文本相对长度单位：rem"></a>文本相对长度单位：rem</h3><p>rem 是CSS3新增的一个相对单位（root em，根em），相对于根元素(即 html 元素)<code>font-size</code>计算值的倍数。</p><p>浏览器的默认字体大小为 16 像素，浏览器默认样式也称为 <code>user agent stylesheet</code>，就是所有浏览器内置的默认样式，多数是可以被修改的，但 chrome 不能直接修改，可以被用户样式覆盖。<br><strong>作用：</strong><br>利用 rem 可以实现简单的响应式布局，可以利用 html 元素中字体的大小与屏幕间的比值设置 <code>font-size</code> 的值实现当屏幕分辨率变化时让元素也变化，以前的天猫tmall就使用这种办法。</p><h3 id="em与rem的重要区别："><a href="#em与rem的重要区别：" class="headerlink" title="em与rem的重要区别："></a>em与rem的重要区别：</h3><p>em 的计算规则是依赖父元素<br>rem 的计算规则是依赖根元素计算</p><h2 id="11、对边距折叠的理解。"><a href="#11、对边距折叠的理解。" class="headerlink" title="11、对边距折叠的理解。"></a>11、对边距折叠的理解。</h2><p><strong>外边距折叠：</strong> 相邻的两个或多个外边距 <code>margin</code>在垂直方向会合并成一个外边距</p><p><strong>相邻：</strong> 没有被非空内容、<code>padding</code>、<code>border</code> 或 <code>clear</code> 分隔开的<code>margin</code>特性。非空内容就是说这元素之间要么是兄弟关系或者父子关系。</p><p><strong>垂直方向外边距合并计算:</strong></p><ol><li>参加折叠的<code>margin</code>都是正值：取其中 <code>margin</code> 较大的值为最终 <code>margin</code> 值。</li><li>参与折叠的 <code>margin</code> 都是负值：取的是其中绝对值较大的，然后，从 0 位置，负向位移。</li><li>参与折叠的 <code>margin</code> 中有正值，有负值：先取出负 <code>margin</code> 中绝对值中最大的，然后，和正 <code>margin</code> 值中最大的 <code>margin</code> 相加。</li></ol><h2 id="12、隐藏元素的方式有哪些？"><a href="#12、隐藏元素的方式有哪些？" class="headerlink" title="12、隐藏元素的方式有哪些？"></a>12、隐藏元素的方式有哪些？</h2><ul><li>使用 CSS 的 <code>display : none</code>，不会占用原来的位置</li><li>使用 CSS 的 <code>visibility : hidden</code>，会占用原来的位置</li><li>使用 HTML5 中的新增属性<code>hidden=&quot;hidden&quot;</code>，不会占用原来的位置</li></ul><h2 id="13、对-IFC、BFC-的理解（是什么，如何产生，作用）"><a href="#13、对-IFC、BFC-的理解（是什么，如何产生，作用）" class="headerlink" title="13、对 IFC、BFC 的理解（是什么，如何产生，作用）"></a>13、对 IFC、BFC 的理解（是什么，如何产生，作用）</h2><p><strong>IFC：</strong>行内格式化上下文</p><ol><li>boxes（框）：水平排列，起点：包含块顶部</li><li>水平方向：<code>margin</code>、<code>border</code>、<code>padding</code>保留</li><li>垂直方向：以不同方式对齐<ul><li>顶部 or 底部 对齐 </li><li>基线对齐</li></ul></li></ol><p><strong>BFC：</strong>块级格式化上下文<br><strong>布局规则：</strong></p><ol><li>内部 box 垂直方向<ul><li>一个一个放置</li><li>距离由 <code>margin</code> 决定（同一 BFC 相邻 <code>margin</code> 重叠）</li></ul></li><li>每个元素左外边缘<code>margin-left</code>与包含块的左边相接触，浮动元素也是如此</li><li>不同的两个 BFC 区域无影响（甚至<code>float box</code>也不会有影响）<ul><li>BFC 区域不会与 <code>float box</code>产生影响</li><li>隔离独立容器，里面的子元素不会影响外界元素</li></ul></li><li>计算 BFC 高度时，浮动元素（子元素）也参与计算</li></ol><p><strong>如何产生：</strong></p><ol><li>根元素</li><li>浮动元素<code>float</code> 不为 <code>none</code></li><li>绝对定位元素 <code>position</code> 为<code>absolute</code>或<code>fixed</code></li><li>非块级元素但 <code>display</code> 的值为：<code>inline-block、table-cell、table-caption、flex、inline-flex</code></li><li>块级元素有<code>overflow</code></li></ol><p><strong>作用：</strong></p><ol><li>清除浮动</li><li>布局：自适应两栏布局</li><li>防止垂直<code>margin</code>合并（也叫 <code>margin-collapse</code>外边距塌陷）</li></ol><h2 id="14、说说你对页面中使用定位-position-的理解？"><a href="#14、说说你对页面中使用定位-position-的理解？" class="headerlink" title="14、说说你对页面中使用定位 (position) 的理解？"></a>14、说说你对页面中使用定位 (position) 的理解？</h2><p>使用css布局position非常重要，语法如下：<br><code>position：static | relative | absolute | fixed | center | page | sticky</code><br><strong>默认值：</strong><code>static</code><br><strong>CSS3 新增：</strong><code>center</code>、<code>page</code>、<code>sticky</code></p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>可以认为静态的，默认元素都是静态的定位，对象遵循常规流。<br>此时 4 个定位偏移属性不会被应用，也就是使用<code>left</code>，<code>right</code>，<code>bottom</code>，<code>top</code>将不会生效。</p><h3 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h3><p>相对定位，对象遵循常规流，并且参照自身在常规流中的位置通过<code>top</code>，<code>right</code>，<code>bottom</code>，<code>left</code>这 4 个定位偏移属性进行偏移时不会影响常规流中的任何元素。</p><h3 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h3><ol><li>绝对定位，对象脱离常规流，此时偏移属性参照的是离自身最近的定位祖先元素，如果没有定位的祖先元素，则一直回溯到<code>body</code>元素。盒子的偏移位置不影响常规流中的任何元素，其<code>margin</code>不与其他任何<code>margin</code>折叠。</li><li>元素定位参考的是离自身最近的定位祖先元素，要满足两个条件，第一个是自己的祖先元素，可以是父元素也可以是父元素的父元素，一直找，如果没有则选择<code>body</code>为对照对象。第二个条件是要求祖先元素必须定位，通俗说就是<code>position</code>的属性值为非<code>static</code>都行。<h3 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h3>固定定位，与<code>absolute</code>一致，但偏移定位是以窗口为参考。当出现滚动条时，对象不会随着滚动。<h3 id="center"><a href="#center" class="headerlink" title="center"></a>center</h3>与<code>absolute</code>一致，但偏移定位是以定位祖先元素的中心点为参考。盒子在其包含容器垂直水平居中。（CSS3）<h3 id="page"><a href="#page" class="headerlink" title="page"></a>page</h3>与<code>absolute</code>一致。元素在分页媒体或者区域块内，元素的包含块始终是初始包含块，否则取决于每个<code>absolute</code>模式。（CSS3）<h3 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a>sticky</h3>对象在常态时遵循常规流。它就像是<code>relative</code>和<code>fixed</code>的合体，当在屏幕中时按常规流排版，当滚动到屏幕外时则表现如<code>fixed</code>。<br>该属性的表现是现实中你见到的吸附效果。（CSS3）</li></ol><h2 id="15、如何解决多个元素重叠问题？"><a href="#15、如何解决多个元素重叠问题？" class="headerlink" title="15、如何解决多个元素重叠问题？"></a>15、如何解决多个元素重叠问题？</h2><p>使用<code>z-index</code>属性可以设置元素的层叠顺序。<br><strong>z-index属性</strong><br>语法：<code>z-index: auto | &lt;integer&gt;</code><br><strong>默认值：</strong><code>auto</code><br>适用于：定位元素。即定义了<code>position</code>为非<code>static</code>的元素。<br><strong>取值：</strong></p><ol><li><code>auto</code>：元素在当前层叠上下文中的层叠级别是 0。元素不会创建新的局部层叠上下文，除非它是根元素。</li><li><code>整数</code>： 用整数值来定义堆叠级别。可以为负值。<br> 说明：<ul><li>检索或设置对象的层叠顺序。</li><li>z-index用于确定元素在当前层叠上下文中的层叠级别，并确定该元素是否创建新的局部层叠上下文。</li><li>当多个元素层叠在一起时，数字大者将显示在上面。</li></ul></li></ol><h2 id="16、页面布局的方式有哪些？"><a href="#16、页面布局的方式有哪些？" class="headerlink" title="16、页面布局的方式有哪些？"></a>16、页面布局的方式有哪些？</h2><p>方式：双飞翼、多栏、弹性、流式、瀑布流、响应式布局</p><h3 id="（1）多栏布局"><a href="#（1）多栏布局" class="headerlink" title="（1）多栏布局"></a>（1）多栏布局</h3><ol><li>栏栅格系统：就是利用浮动实现的多栏布局，在<code>bootstrap</code>中用的非常多。</li><li>多列布局：栅格系统并没有真正实现分栏效果（如 word 中的分栏），CSS3 为了满足这个要求增加了多列布局模块</li></ol><h3 id="（2）弹性布局（Flexbox）"><a href="#（2）弹性布局（Flexbox）" class="headerlink" title="（2）弹性布局（Flexbox）"></a>（2）弹性布局（Flexbox）</h3><p>CSS3 引入了一种新的布局模式——Flexbox 布局（简称为 Flex），即伸缩布局盒模型（Flexible Box）。</p><p><strong>目的：</strong><br>用来提供一个更加有效的方式制定、调整和分布一个容器里项目布局，即使它们的大小是未知或者动态的。</p><p><strong>应用：</strong><br>Flexbox 布局常用于设计比较复杂的页面，可以轻松的实现屏幕和浏览器窗口大小发生变化时保持元素的相对位置和大小不变，同时减少了依赖于浮动布局实现元素位置的定义以及重置元素的大小。</p><p>Flexbox 布局在定义伸缩项目大小时伸缩容器会预留一些可用空间，让你可以调节伸缩项目的相对大小和位置。</p><blockquote><p>例如，你可以确保伸缩容器中的多余空间平均分配多个伸缩项目，当然，如果你的伸缩容器没有足够大的空间放置伸缩项目时，浏览器会根据一定的比例减少伸缩项目的大小，使其不溢出伸缩容器。</p></blockquote><p>综合而言，Flexbox <strong>布局功能</strong>主要具有以下几点：</p><ol><li>屏幕和浏览器窗口大小发生改变也可以灵活调整布局；</li><li>可以指定伸缩项目沿着主轴或侧轴按比例分配额外空间（伸缩容器额外空间），从而调整伸缩项目的大小；</li><li>可以指定伸缩项目沿着主轴或侧轴将伸缩容器额外空间，分配到伸缩项目之前、之后或之间；</li><li>可以指定如何将垂直于元素布局轴的额外空间分布到该元素的周围；</li><li>可以控制元素在页面上的布局方向；</li><li>可以按照不同于文档对象模型（DOM）所指定排序方式对屏幕上的元素重新排序。也就是说可以在浏览器渲染中不按照文档流先后顺序重排伸缩项目顺序。</li></ol><p>###（3） 流式布局（Fluid）<br><strong>固定</strong>布局和<strong>流式</strong>布局在网页设计中最常用的两种布局方式。</p><p>固定布局能呈现网页的原始设计效果，流式布局则不受窗口宽度影响，流式布局使用百分比宽度来限定布局元素，这样可以根据客户端分辨率的大小来进行合理的显示。</p><h3 id="（4）响应式布局"><a href="#（4）响应式布局" class="headerlink" title="（4）响应式布局"></a>（4）响应式布局</h3><p>响应式布局是 Ethan Marcotte 在2010年5月份提出的一个概念，就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。这个概念是为解决移动互联网浏览而诞生的。</p><p>响应式布局可以为不同终端的用户提供更加舒适的界面和更好的用户体验，而且随着目前大屏幕移动设备的普及，用“大势所趋”来形容也不为过。</p><p><strong>优点：</strong></p><ol><li>面对不同分辨率设备灵活性强</li><li>能够快捷解决多设备显示适应问题</li></ol><p><strong>缺点：</strong></p><ol><li>兼容各种设备工作量大，效率低下</li><li>代码累赘，会出现隐藏无用的元素，加载时间加长</li><li>其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果</li><li>一定程度上改变了网站原有的布局结构，会出现用户混淆的情况</li></ol><h2 id="17、CSS居中（包括水平居中和垂直居中）。"><a href="#17、CSS居中（包括水平居中和垂直居中）。" class="headerlink" title="17、CSS居中（包括水平居中和垂直居中）。"></a>17、CSS居中（包括水平居中和垂直居中）。</h2><h3 id="内联元素居中方案"><a href="#内联元素居中方案" class="headerlink" title="内联元素居中方案"></a>内联元素居中方案</h3><h4 id="（1）-水平居中设置："><a href="#（1）-水平居中设置：" class="headerlink" title="（1） 水平居中设置："></a>（1） 水平居中设置：</h4><ul><li>行内元素<ul><li>设置 <code>text-align:center</code>；</li></ul></li><li>Flex布局<ul><li>设置 <code>display:flex; justify-content:center;</code> (灵活运用,支持Chroime，Firefox，IE9+)<h4 id="（2）-垂直居中设置："><a href="#（2）-垂直居中设置：" class="headerlink" title="（2） 垂直居中设置："></a>（2） 垂直居中设置：</h4></li></ul></li><li>父元素高度确定的单行文本（内联元素）<ul><li>设置 <code>height = line-height</code>；</li></ul></li><li>父元素高度确定的多行文本（内联元素）<ol><li>插入 <code>table</code> （插入方法和水平居中一样），然后设置 <code>vertical-align:middle</code>；</li><li>先设置 <code>display:table-cell</code> 再设置 <code>vertical-align:middle</code>；</li></ol></li></ul><h3 id="块级元素居中方案"><a href="#块级元素居中方案" class="headerlink" title="块级元素居中方案"></a>块级元素居中方案</h3><h4 id="（1）水平居中设置："><a href="#（1）水平居中设置：" class="headerlink" title="（1）水平居中设置："></a>（1）水平居中设置：</h4><ul><li>定宽块状元素<ul><li>设置 左右 <code>margin</code> 值为 <code>auto</code>；</li></ul></li><li>不定宽块状元素<ol><li>在元素外加入 <code>table</code> 标签（完整的，包括 <code>table</code>、<code>tbody</code>、<code>tr</code>、<code>td</code>），该元素写在 <code>td</code> 内，然后设置 <code>margin</code> 的值为 <code>auto</code>；</li><li>给该元素设置 <code>displa:inline; align-text:center;</code> 方法；</li><li>父元素设置 <code>position:relative</code>，子元素设置 <code>position:absolute; left:50%; margin-left: - @width/2</code>；<h4 id="（2）垂直居中设置："><a href="#（2）垂直居中设置：" class="headerlink" title="（2）垂直居中设置："></a>（2）垂直居中设置：</h4></li></ol></li><li>使用 <code>position:absolute（fixed）</code> ,设置 <code>left</code>、<code>top</code>、<code>margin-left</code>、<code>margin-top</code> 的属性;</li><li>利用 <code>position:fixed（absolute）</code>属性，<code>margin:auto</code> 这个必须不要忘记了;</li><li>利用 <code>display:table-cell</code> 属性使内容垂直居中;</li><li>使用 css3 的新属性 <code>transform:translate(x,y)</code> 属性;</li><li>使用 <code>:before</code> 元素;</li></ul><h2 id="18、CSS3-的新特性。"><a href="#18、CSS3-的新特性。" class="headerlink" title="18、CSS3 的新特性。"></a>18、CSS3 的新特性。</h2><ul><li>CSS3的选择器<ul><li>1）E:last-child 匹配父元素的最后一个子元素E。</li><li>2）E:nth-child(n)匹配父元素的第n个子元素E。</li><li>3）E:nth-last-child(n) CSS3 匹配父元素的倒数第n个子元素E。</li></ul></li><li>@Font-face 特性<ul><li>Font-face 可以用来加载字体样式，而且它还能够加载服务器端的字体文件，让客户端显示客户端所没有安装的字体。.</li></ul></li><li>圆角、 阴影<ul><li>border-radius: 15px;</li><li>box-shadow:10px</li></ul></li><li>多列布局 （multi-column layout）<ul><li>兼容性不好，还不够成熟。还不能用在实际项目中。</li></ul></li></ul><h2 id="19、position跟display、margin-collapse、overflow、float这些特性相互叠加会产生的效果。"><a href="#19、position跟display、margin-collapse、overflow、float这些特性相互叠加会产生的效果。" class="headerlink" title="19、position跟display、margin collapse、overflow、float这些特性相互叠加会产生的效果。"></a>19、position跟display、margin collapse、overflow、float这些特性相互叠加会产生的效果。</h2><h3 id="1、’display’、’position’-和-‘float’-的相互关系"><a href="#1、’display’、’position’-和-‘float’-的相互关系" class="headerlink" title="1、’display’、’position’ 和 ‘float’ 的相互关系"></a>1、’display’、’position’ 和 ‘float’ 的相互关系</h3><ol><li><p>‘display’ 的值为 ‘none’</p><ul><li>如果 ‘display’ 的值为 ‘none’，那么 ‘position’ 和 ‘float’ 不起作用。在这种情况下，元素不产生框。因此浮动和定位无效。</li></ul></li><li><p>‘position’ 的值是 ‘absolute’ 或 ‘fixed’</p><ul><li>如果 ‘position’ 的值是 ‘absolute’ 或 ‘fixed’，框就是绝对定位的，’float’ 计算后的值应该是 ‘none’，并且，’display’ 会被按照上表设置。 框的位置将由 ‘top’，’right’，’bottom’ 和 ‘left’ 属性和该框的包含块确定。<ul><li>也就是说，当元素是绝对定位时，浮动失效，’display’ 会被按规则重置。</li></ul></li></ul></li><li><p>‘float’ 的值不是 “none”</p><ul><li>按照规则，span 是行内元素，因此不能够设置其宽度和高度。但是浮动后，’display’ 值按照转换对应表设置后，成为块级元素</li></ul></li><li><p>元素是根元素</p><ul><li>如果元素是根元素，’display’ 的值按照转换对应表设置。</li></ul></li><li><p>否则，应用指定的 ‘display’ 特性值。</p></li></ol><h3 id="2、’position’-跟-‘display’、’overflow’、’float’下的-‘margin-collapse’。"><a href="#2、’position’-跟-‘display’、’overflow’、’float’下的-‘margin-collapse’。" class="headerlink" title="2、’position’ 跟 ‘display’、’overflow’、’float’下的 ‘margin collapse’。"></a>2、’position’ 跟 ‘display’、’overflow’、’float’下的 ‘margin collapse’。</h3><p>margin collapse：即外边距折叠，指的是毗邻的两个或多个外边距 (margin) 会合并成一个外边距。<br>• 这两个或多个外边距没有被 非空内容、padding、border 或 clear 分隔开。<br>• 这些 margin 都处于普通流中。</p><ul><li>两个或多个毗邻的普通流中的块元素垂直方向上的 margin 会折叠。</li><li>浮动元素、inline-block 元素、绝对定位元素的 margin 不会和垂直方向上其他元素的 margin 折叠。</li><li>创建了块级格式化上下文的元素，不和它的子元素发生 margin 折叠。</li></ul><h2 id="20、-before-和-after中双冒号和单冒号-有什么区别？解释一下这2个伪元素的作用。"><a href="#20、-before-和-after中双冒号和单冒号-有什么区别？解释一下这2个伪元素的作用。" class="headerlink" title="20、::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。"></a>20、::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。</h2><p><strong>单冒号（ <code>:</code> ）</strong>用于 CSS3 伪类，<strong>双冒号（ <code>::</code> ）</strong>用于 CSS3 伪元素。（伪元素由双冒号和伪元素名称组成）</p><p>双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，比如:<code>:first-line</code>、<code>:first-letter</code>、<code>:before</code>、<code>:after</code>等，</p><p>而新的在 CSS3 中引入的伪元素则不允许再支持旧的单冒号的写法。<br>想让插入的内容出现在其它内容前，使用<code>::before</code>，否者，使用<code>::after</code>；<br>在代码顺序上，<code>::after</code>生成的内容也比<code>::before</code>生成的内容靠后。<br>如果按堆栈视角，<code>::after</code>生成的内容会在<code>::before</code>生成的内容之上。</p>]]></content>
      
      <categories>
          
          <category> 前端面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从1到n整数中1出现的次数：O(logn)算法</title>
      <link href="/2018/04/02/Programming/%E4%BB%8E1%E5%88%B0n%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%EF%BC%9AO-logn-%E7%AE%97%E6%B3%95/"/>
      <url>/2018/04/02/Programming/%E4%BB%8E1%E5%88%B0n%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%EF%BC%9AO-logn-%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>输入一个整数n，求从1到n这n个整数的十进制表示中1出现的次数。例如输入12，从1到12这些整数中包含1的数字有1，10，11和12，1一共出现了5次。</p><h2 id="2-本文的目的"><a href="#2-本文的目的" class="headerlink" title="2. 本文的目的"></a>2. 本文的目的</h2><p>《剑指Offer》上的解法，我有点看不懂，在CSDN上找的<a href="https://blog.csdn.net/yi_afly/article/details/52012593" target="_blank" rel="noopener">解析</a>，解释得更加清楚，就转载过来了。</p><h2 id="3-解题思路"><a href="#3-解题思路" class="headerlink" title="3. 解题思路"></a>3. 解题思路</h2><p>将十进制表示的 n 的每一位单独拿出讨论，每一位的值记为weight。</p><h3 id="1-个位"><a href="#1-个位" class="headerlink" title="1) 个位"></a>1) 个位</h3><p>从1到n，每增加1，weight就会加1，当weight加到9时，再加1又会回到0重新开始。那么weight从0-9的这种周期会出现多少次呢？这取决于n的高位是多少，看图：<br><img src="/2018/04/02/Programming/从1到n整数中1出现的次数：O-logn-算法/./1.png" alt="Alt text"></p><p>以534为例，在从1增长到n的过程中，534的个位从0-9变化了53次，记为 round。每一轮变化中，1在个位出现一次，所以一共出现了53次。 </p><p>再来看 weight 的值。weight 为 4，大于 0，说明第 54 轮变化是从 0-4，1又出现了1次。我们记 1 出现的次数为 count，所以： </p><p><img src="/2018/04/02/Programming/从1到n整数中1出现的次数：O-logn-算法/./4.png" alt="count = round+1 = 53 + 1 = 54"></p><p>如果此时 weight 为 0（n=530），说明第 54 轮到 0 就停止了，那么：<br><img src="/2018/04/02/Programming/从1到n整数中1出现的次数：O-logn-算法/./5.png" alt="count = round = 53"></p><h3 id="2-十位"><a href="#2-十位" class="headerlink" title="2) 十位"></a>2) 十位</h3><p>对于 10 位来说，其 0-9 周期的出现次数与个位的统计方式是相同的，见图：<br><img src="/2018/04/02/Programming/从1到n整数中1出现的次数：O-logn-算法/./2.png" alt="Alt text"></p><p>不同点在于：从 1 到 n，每增加 10，十位的 weight 才会增加 1，所以，一轮 0-9 周期内，1 会出现 10 次。即 <code>rount*10</code>。 </p><p>再来看 weight 的值。当此时 weight 为 3，大于 1，说明第 6 轮出现了 10 次 1，则：<br><img src="/2018/04/02/Programming/从1到n整数中1出现的次数：O-logn-算法/./6.png" alt="count = round*10+10 = 5*10+10 = 60"></p><p>如果此时 weight 的值等于 0（n=504），说明第 6 轮到 0 就停止了，所以：<br><img src="/2018/04/02/Programming/从1到n整数中1出现的次数：O-logn-算法/./7.png" alt="count = round*10+10 = 5*10 = 50"></p><p>如果此时 weight 的值等于 1（n=514），那么第 6 轮中 1 出现了多少次呢？很明显，这与个位数的值有关，个位数为 k，第 6 轮中 1 就出现了 k+1 次 (0-k)。我们记个位数为 former，则：<br><img src="/2018/04/02/Programming/从1到n整数中1出现的次数：O-logn-算法/./8.png" alt="count = round*10+former +1= 5*10+4 = 55"></p><h3 id="3-更高位"><a href="#3-更高位" class="headerlink" title="3) 更高位"></a>3) 更高位</h3><p>更高位的计算方式其实与十位是一致的，不再阐述。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4) 总结"></a>4) 总结</h3><p>将 n 的各个位分为两类：个位与其它位。 </p><p>对个位来说：</p><ul><li>若个位大于0，1出现的次数为 <code>round*1+1</code></li><li>若个位等于0，1出现的次数为 <code>round*1</code></li></ul><p>对其它位来说，记每一位的权值为 base，位值为 weight，该位之前的数是 former，举例如图：<br><img src="/2018/04/02/Programming/从1到n整数中1出现的次数：O-logn-算法/./3.png" alt="Alt text"></p><p>则：</p><ul><li>若 weight 为 0，则 1 出现次数为 <code>round*base</code></li><li>若 weight 为 1，则 1 出现次数为 <code>round*base+former+1</code></li><li>若 weight 大于 1，则 1 出现次数为 <code>rount*base+base</code></li></ul><p>比如：</p><ol><li><code>534 = (个位 1 出现次数) + (十位 1 出现次数) + (百位 1 出现次数) =（53*1+1）+（5*10+10）+（0*100+100）= 214</code></li><li><code>530 = （53*1）+（5*10+10）+（0*100+100） = 213</code></li><li><code>504 = （50*1+1）+（5*10）+（0*100+100） = 201</code></li><li><code>514 = （51*1+1）+（5*10+4+1）+（0*100+100） = 207</code></li><li><code>10 = (1*1)+(0*10+0+1) = 2</code></li></ol><h2 id="4-完整代码"><a href="#4-完整代码" class="headerlink" title="4. 完整代码"></a>4. 完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> base = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> round = n;</span><br><span class="line">    <span class="keyword">while</span>( round &gt; <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="keyword">var</span> weight = round % <span class="number">10</span>;</span><br><span class="line">        round = <span class="built_in">Math</span>.floor(round / <span class="number">10</span>);</span><br><span class="line">        count += round * base;</span><br><span class="line">        <span class="keyword">if</span>( weight == <span class="number">1</span>)</span><br><span class="line">            count += ( n % base ) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( weight &gt; <span class="number">1</span> )</span><br><span class="line">            count += base;</span><br><span class="line">        base *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-时间复杂度分析"><a href="#5-时间复杂度分析" class="headerlink" title="5.时间复杂度分析"></a>5.时间复杂度分析</h2><p>由分析思路或者代码都可以看出，while 循环的次数就是 n 的位数，logn（以10为底），而循环体内执行的操作都是有限次的，所以时间复杂度为 O(logn)。</p>]]></content>
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>组件</title>
      <link href="/2018/04/01/Vue%E5%AD%A6%E4%B9%A0/%E7%BB%84%E4%BB%B6/"/>
      <url>/2018/04/01/Vue%E5%AD%A6%E4%B9%A0/%E7%BB%84%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h2 id="什么是组件？"><a href="#什么是组件？" class="headerlink" title="什么是组件？"></a>什么是组件？</h2><ul><li>组件可以扩展 HTML 元素，封装可重用的代码。</li><li>在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。</li><li>在有些情况下，组件也可以表现为用 <code>is</code> 特性进行了扩展的原生 HTML 元素。</li></ul><p>所有的 Vue 组件同时也都是 Vue 的实例，所以可接受相同的选项对象 (除了一些根级特有的选项) 并提供相同的生命周期钩子。</p><blockquote><p>在实例的生命周期中会自动执行一些函数，这些函数就叫做<strong>钩子函数</strong>。</p></blockquote><h2 id="使用组件"><a href="#使用组件" class="headerlink" title="使用组件"></a>使用组件</h2><h3 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h3><p>通过以下方式创建一个 Vue 实例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#some-element'</span>,</span><br><span class="line">  <span class="comment">// 选项</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>注册一个全局组件，使用 <code>Vue.component(tagName, options)</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  <span class="comment">// 选项</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>组件在注册之后，便可以作为自定义元素 <code>&lt;my-component&gt;&lt;/my-component&gt;</code> 在一个实例的模板中使用。</p><blockquote><p>注意确保在初始化根实例之前注册组件：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册</span></span><br><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;A custom component!&lt;/div&gt;'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建根实例</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>渲染为：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>A custom component!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><img src="/2018/04/01/Vue学习/组件/./1.png" alt="Alt text"></p><h3 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h3><p>可以通过某个 Vue 实例/组件的实例选项 <code>components</code> 注册仅在其<strong>作用域</strong>中可用的组件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Child = &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;A custom component!&lt;/div&gt;'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="comment">// &lt;my-component&gt; 将只在父组件模板中可用</span></span><br><span class="line">    <span class="string">'my-component'</span>: Child</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="DOM-模板解析注意事项"><a href="#DOM-模板解析注意事项" class="headerlink" title="DOM 模板解析注意事项"></a>DOM 模板解析注意事项</h3><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>当使用 DOM 作为模板时 (例如，使用 <code>el</code> 选项来把 Vue 实例挂载到一个已有内容的元素上)，会受到 HTML 本身的一些限制。</p><h4 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h4><p>因为 Vue 只有在浏览器解析、规范化模板之后才能获取其内容。</p><ul><li>像 <code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;select&gt;</code> 这样的元素对包含的元素有限制；</li><li>像 <code>&lt;option&gt;</code> 这样的元素只能出现在某些特定元素的内部。</li></ul><h4 id="使用限制示例："><a href="#使用限制示例：" class="headerlink" title="使用限制示例："></a>使用限制示例：</h4><p>在自定义组件中使用这些受限制的元素时会导致一些问题：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-row</span>&gt;</span>...<span class="tag">&lt;/<span class="name">my-row</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>原因：</strong><br><code>&lt;table&gt;</code>元素对包含的元素有限制。自定义组件 <code>&lt;my-row&gt;</code> 会被当作无效的内容，因此会导致错误的渲染结果。<br><strong>解决方法：</strong><br>使用特殊的 <code>is</code> 特性：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span> <span class="attr">is</span>=<span class="string">"my-row"</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure></p><blockquote><p>注意，如果使用来自以下来源之一的字符串模板，则没有这些限制： </p><ul><li><code>&lt;script type=&quot;text/x-template&quot;&gt;</code></li><li>JavaScript 内联模板字符串</li><li>.vue 组件</li></ul></blockquote><h3 id="data-必须是函数"><a href="#data-必须是函数" class="headerlink" title="data 必须是函数"></a>data 必须是函数</h3><p>构造 Vue 实例时传入的各种选项大多数都可以在组件里使用。<br>只有一个例外：<strong>data 必须是函数</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">'hello'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Vue 会停止运行，并在控制台发出警告，告诉你在组件实例中 data 必须是一个函数。</span></span><br></pre></td></tr></table></figure></p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>先作个弊：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-2"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">simple-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">simple-counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">simple-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">simple-counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">simple-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">simple-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">counter</span>: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">'simple-counter'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;button v-on:click="counter += 1"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;'</span>,</span><br><span class="line">  <span class="comment">// 技术上 data 的确是一个函数了，因此 Vue 不会警告，</span></span><br><span class="line">  <span class="comment">// 但是我们却给每个组件实例返回了同一个对象的引用</span></span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-2'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>由于这<a href="https://codepen.io/Wonder233/pen/XEqgaR" target="_blank" rel="noopener">三个组件实例共享了同一个 data 对象（示例）</a>，因此递增一个 counter 会影响所有组件。</p><p><strong>解决办法：</strong><br>通过<a href="https://codepen.io/Wonder233/pen/XEqgaR" target="_blank" rel="noopener">为每个组件返回全新的数据对象（示例）</a>来修复这个问题：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter: <span class="number">0</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在每个 counter 都有它自己内部的状态了。</p><h3 id="组件组合"><a href="#组件组合" class="headerlink" title="组件组合"></a>组件组合</h3><h4 id="父子组件（最常见）："><a href="#父子组件（最常见）：" class="headerlink" title="父子组件（最常见）："></a>父子组件（最常见）：</h4><p>组件 A 在它的模板中使用了组件 B。</p><h4 id="父子组件通信：-prop-向下传递，事件向上传递。"><a href="#父子组件通信：-prop-向下传递，事件向上传递。" class="headerlink" title="父子组件通信： prop 向下传递，事件向上传递。"></a>父子组件通信： prop 向下传递，事件向上传递。</h4><blockquote><p>通过一个良好定义的<strong>接口</strong>来尽可能将父子组件<strong>解耦</strong>很重要。<br>这保证了每个组件的代码可以在相对隔离的环境中书写和理解，从而提高了其可维护性和复用性。</p></blockquote><p>父组件通过 <code>prop</code> 给子组件下发数据，子组件通过<strong>自定义事件</strong>给父组件发送消息。<br><img src="/2018/04/01/Vue学习/组件/./2.png" alt="父子组件通信"></p><h2 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a>Prop</h2><h3 id="传递字面量数据"><a href="#传递字面量数据" class="headerlink" title="传递字面量数据"></a>传递字面量数据</h3><h4 id="为什么不能-也不应该-在子组件的模板内直接引用父组件的数据？"><a href="#为什么不能-也不应该-在子组件的模板内直接引用父组件的数据？" class="headerlink" title="为什么不能 (也不应该) 在子组件的模板内直接引用父组件的数据？"></a>为什么不能 (也不应该) 在子组件的模板内直接引用父组件的数据？</h4><p>因为组件实例的作用域是孤立的。</p><p><strong>方法：</strong><br>父组件的数据通过 prop 下发到子组件中。</p><p>子组件要显式地用 <code>props</code> 选项声明它预期的数据：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'child'</span>, &#123;</span><br><span class="line">  <span class="comment">// 声明 props</span></span><br><span class="line">  props: [<span class="string">'message'</span>],</span><br><span class="line">  <span class="comment">// 就像 data 一样，prop 也可以在模板中使用</span></span><br><span class="line">  <span class="comment">// 同样也可以在 vm 实例中通过 this.message 来使用</span></span><br><span class="line">  template: <span class="string">'&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>然后通过 <code>message</code> 变量向它传入一个普通字符串：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">message</span>=<span class="string">"hello!"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>结果：<br><img src="/2018/04/01/Vue学习/组件/./3.png" alt="结果"></p><h3 id="传递动态数据"><a href="#传递动态数据" class="headerlink" title="传递动态数据"></a>传递动态数据</h3><p>（1）父组件的部分数据传递给子组件（<a href="https://codepen.io/Wonder233/pen/aYGyKx?editors=1010" target="_blank" rel="noopener">示例</a>）<br>用 <code>v-bind</code> 动态地将 prop 绑定到父组件的数据。每当父组件的数据变化时，该变化也会传导给子组件：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"prop-example-2"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"parentMsg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child</span> <span class="attr">v-bind:my-message</span>=<span class="string">"parentMsg"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 或写成 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child</span> <span class="attr">:my-message</span>=<span class="string">"parentMsg"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#prop-example-2'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    parentMsg: <span class="string">'Message from parent'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>（2）父组件的全部数据传递给子组件（<a href="https://codepen.io/Wonder233/pen/aYGyKx?editors=1010" target="_blank" rel="noopener">示例</a>）<br>使用不带任何参数的 <code>v-bind</code> (即用 <code>v-bind</code> 而不是 <code>v-bind:prop-name</code>)。</p><p>例如，已知一个 <code>todo</code> 对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">todo: &#123;</span><br><span class="line">  text: <span class="string">'Learn Vue'</span>,</span><br><span class="line">  isComplete: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;todo-<span class="built_in">item</span> v-bind=<span class="string">"todo"</span>&gt;&lt;/todo-<span class="built_in">item</span>&gt;</span><br></pre></td></tr></table></figure><p>等价于：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">todo-item</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:text</span>=<span class="string">"todo.text"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:is-complete</span>=<span class="string">"todo.isComplete"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">todo-item</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="字面量语法-vs-动态语法"><a href="#字面量语法-vs-动态语法" class="headerlink" title="字面量语法 vs 动态语法"></a>字面量语法 vs 动态语法</h3><h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><p>使用字面量语法传递数值：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 传递了一个字符串 "1" --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">some-prop</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>原因：</strong><br>因为它是一个字面量 prop，它的值是字符串 “1” 而不是一个数值。</p><p><strong>解决方案：</strong><br>如果想传递一个真正的 JavaScript 数值，则需要使用 v-bind，从而让它的值被当作 JavaScript 表达式计算：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 传递真正的数值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">v-bind:some-prop</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h3><h4 id="1-单向绑定"><a href="#1-单向绑定" class="headerlink" title="1.单向绑定"></a>1.单向绑定</h4><p>Prop 是<strong>单向绑定</strong>的：当父组件的属性变化时，将传导给子组件，但是反过来不会。<br><strong>原因：</strong><br>为了防止子组件无意间修改了父组件的状态，来避免应用的数据流变得难以理解。</p><h4 id="2-子组件内部不要去改变-prop"><a href="#2-子组件内部不要去改变-prop" class="headerlink" title="2.子组件内部不要去改变 prop"></a>2.子组件内部不要去改变 prop</h4><p>每次父组件更新时，子组件的所有 prop 都会更新为最新值。</p><h4 id="如何修改-prop-中数据"><a href="#如何修改-prop-中数据" class="headerlink" title="如何修改 prop 中数据"></a>如何修改 prop 中数据</h4><p>有两种情况想要修改 prop 中数据：</p><ol><li>Prop 作为初始值传入后，子组件想把它当作局部数据来用；</li><li>Prop 作为原始数据传入，由子组件处理成其它数据输出。</li></ol><p><strong>解决方案：</strong></p><ol><li><p>定义一个局部变量，并用 prop 的值初始化它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">'initialCounter'</span>],</span><br><span class="line">data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">counter</span>: <span class="keyword">this</span>.initialCounter &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义一个计算属性，处理 prop 的值并返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">'size'</span>],</span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedSize: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size.trim().toLowerCase();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它<strong>会影响</strong>父组件的状态。</p></blockquote><h3 id="Prop-验证"><a href="#Prop-验证" class="headerlink" title="Prop 验证"></a>Prop 验证</h3><p>可以为组件的 prop 指定验证规则。如果传入的数据不符合要求，Vue 会发出警告。</p><p>要指定验证规则，需要用<strong>对象的形式</strong>来定义 prop，而不能用字符串数组：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'example'</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// 基础类型检测 (`null` 指允许任何类型)</span></span><br><span class="line">    propA: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="comment">// 可能是多种类型</span></span><br><span class="line">    propB: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">    <span class="comment">// 必传且是字符串</span></span><br><span class="line">    propC: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 数值且有默认值</span></span><br><span class="line">    propD: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 数组/对象的默认值应当由一个工厂函数返回</span></span><br><span class="line">    propE: &#123;</span><br><span class="line">      type: <span class="built_in">Object</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">message</span>: <span class="string">'hello'</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 自定义验证函数</span></span><br><span class="line">    propF: &#123;</span><br><span class="line">      validator: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value &gt; <span class="number">10</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><code>type</code> 可以是下面原生构造器：</p><ul><li><code>String</code></li><li><code>Number</code></li><li><code>Boolean</code></li><li><code>Function</code></li><li><code>Object</code></li><li><code>Array</code></li><li><code>Symbol</code></li></ul><p><code>type</code> 也可以是一个自定义构造器函数，使用 <code>instanceof</code> 检测。</p><p>当 prop 验证失败，Vue 会抛出警告 (如果使用的是开发版本)。<br>注意 prop 会在组件实例创建之前进行校验，所以在 <code>default</code> 或 <code>validator</code> 函数里，诸如 <code>data</code>、<code>computed</code> 或 <code>methods</code> 等实例属性还无法使用。</p><h3 id="camelCase-驼峰命名-vs-kebab-case-短横线命名"><a href="#camelCase-驼峰命名-vs-kebab-case-短横线命名" class="headerlink" title="camelCase(驼峰命名) vs. kebab-case(短横线命名)"></a>camelCase(驼峰命名) vs. kebab-case(短横线命名)</h3><p>HTML 特性是不区分大小写的。<br>当使用的不是字符串模板时，camelCase (驼峰式命名) 的 prop 需要转换为相对应的 kebab-case (短横线分隔式命名)：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'child'</span>, &#123;</span><br><span class="line">  <span class="comment">// 在 JavaScript 中使用 camelCase</span></span><br><span class="line">  props: [<span class="string">'myMessage'</span>],</span><br><span class="line">  template: <span class="string">'&lt;span&gt;&#123;&#123; myMessage &#125;&#125;&lt;/span&gt;'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在 HTML 中使用 kebab-case --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">my-message</span>=<span class="string">"hello!"</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="非-Prop-特性"><a href="#非-Prop-特性" class="headerlink" title="非 Prop 特性"></a>非 Prop 特性</h2><p><strong>含义：</strong> 指它可以直接传入组件，而不需要定义相应的 prop。</p><p>尽管为组件定义明确的 prop 是推荐的传参方式，组件的作者却并不总能预见到组件被使用的场景。所以，<strong>组件可以接收任意传入的特性，这些特性都会被添加到组件的根元素上。</strong></p><p>例如，假设我们使用了第三方组件 <code>bs-date-input</code>，它包含一个 Bootstrap 插件，该插件需要在 <code>input</code> 上添加 <code>data-3d-date-picker</code> 这个特性。这时可以把特性直接添加到组件上 (不需要事先定义 prop)：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bs-date-input</span> <span class="attr">data-3d-date-picker</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">bs-date-input</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>添加属性 <code>data-3d-date-picker=&quot;true&quot;</code> 之后，它会被自动添加到 <code>bs-date-input</code> 的根元素上。</p><h3 id="替换-合并现有的特性"><a href="#替换-合并现有的特性" class="headerlink" title="替换/合并现有的特性"></a>替换/合并现有的特性</h3><p>假设这是 <code>bs-date-input</code> 的模板：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"date"</span> <span class="attr">class</span>=<span class="string">"form-control"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>为了给该日期选择器插件增加一个特殊的主题，我们可能需要增加一个特殊的 <code>class</code>，比如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bs-date-input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">data-3d-date-picker</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"date-picker-theme-dark"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">bs-date-input</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在这个例子当中，我们定义了两个不同的 <code>class</code> 值：</p><ul><li><code>form-control</code>，来自组件自身的模板</li><li><code>date-picker-theme-dark</code>，来自父组件</li></ul><p>对于多数特性来说，传递给组件的值会覆盖组件本身设定的值。即例如传递 <code>type=&quot;large&quot;</code> 将会覆盖 <code>type=&quot;date&quot;</code> 且有可能破坏该组件！</p><p>但是对于 <code>class</code> 和 <code>style</code> 特性，这两个特性的值都会做合并 (merge) 操作，让最终生成的值为：<code>form-control date-picker-theme-dark</code>。</p><h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p>子组件通过自定义事件跟父组件通信。</p><h3 id="使用-v-on-绑定自定义事件"><a href="#使用-v-on-绑定自定义事件" class="headerlink" title="使用 v-on 绑定自定义事件"></a>使用 v-on 绑定自定义事件</h3><p>每个 Vue 实例都实现了<a href="https://cn.vuejs.org/v2/api/#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95-%E4%BA%8B%E4%BB%B6" target="_blank" rel="noopener">事件接口</a>，即：</p><ul><li>使用 <code>$on(eventName)</code> 监听事件</li><li>使用 <code>$emit(eventName, optionalPayload)</code> 触发事件</li></ul><p>父组件可以在使用子组件的地方直接用 <code>v-on</code> 来监听子组件触发的事件。</p><p><a href="https://codepen.io/Wonder233/pen/GxdMjv?editors=1010" target="_blank" rel="noopener">示例1：</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"counter-event-example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; total &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span> <span class="attr">v-on:increment</span>=<span class="string">"incrementTotal"</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span> <span class="attr">v-on:increment</span>=<span class="string">"incrementTotal"</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'button-counter'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;button v-on:click="incrementCounter"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;'</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      counter: <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    incrementCounter: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.counter += <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'increment'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#counter-event-example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    total: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    incrementTotal: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.total += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>在本例中，子组件已经和它外部完全解耦了，它所做的只是报告自己的内部事件。</p></blockquote><p><a href="https://codepen.io/Wonder233/pen/GxdMjv?editors=1010" target="_blank" rel="noopener">示例2</a>：使用载荷 (payload) 数据<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"message-event-example"</span> <span class="attr">class</span>=<span class="string">"demo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">"msg in messages"</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-message</span> <span class="attr">v-on:message</span>=<span class="string">"handleMessage"</span>&gt;</span><span class="tag">&lt;/<span class="name">button-message</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'button-message'</span>, &#123;</span><br><span class="line">  template: <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;input type="text" v-model="message" /&gt;</span></span><br><span class="line"><span class="string">    &lt;button v-on:click="handleSendMessage"&gt;Send&lt;/button&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;`</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">'test message'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleSendMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'message'</span>, &#123; <span class="attr">message</span>: <span class="keyword">this</span>.message &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#message-event-example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    messages: []</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleMessage: <span class="function"><span class="keyword">function</span> (<span class="params">payload</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.messages.push(payload.message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>第二个示例的重点在于子组件仍然是完全和外界解耦的。它做的事情全都是记录其自身的活动，活动记录是包括一份传入事件触发器的载荷数据在内的，只是为了展示父组件可以不关注的一个场景。</p><h3 id="组件绑定原生事件"><a href="#组件绑定原生事件" class="headerlink" title="组件绑定原生事件"></a>组件绑定原生事件</h3><p>使用 <code>v-on</code> 的修饰符 <code>.native</code>，可以在某个组件的根元素上监听一个原生事件。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-on:click.native</span>=<span class="string">"doTheThing"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="sync-修饰符"><a href="#sync-修饰符" class="headerlink" title=".sync 修饰符"></a>.sync 修饰符</h3><blockquote><p>2.3.0+</p></blockquote><p>当一个子组件改变了一个带 <code>.sync</code> 的 prop 的值时，这个变化也会同步到父组件中所绑定的值。<br><code>.sync</code> 作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 <code>v-on</code> 监听器。</p><p><strong>目的：</strong><br>在开发可复用的组件库时，让子组件改变父组件状态的代码更容易被区分。</p><p><strong>示例：</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">:foo.sync</span>=<span class="string">"bar"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>会被扩展为：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">:foo</span>=<span class="string">"bar"</span> @<span class="attr">update:foo</span>=<span class="string">"val =&gt; bar = val"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>当子组件需要更新 <code>foo</code> 的值时，它需要显式地触发一个更新事件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$emit(<span class="string">'update:foo'</span>, newValue);</span><br></pre></td></tr></table></figure></p><p>当使用一个对象一次性设置多个属性的时候，这个 <code>.sync</code> 修饰符也可以和 <code>v-bind</code> 一起使用：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">comp</span> <span class="attr">v-bind.sync</span>=<span class="string">"&#123; foo: 1, bar: 2 &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="使用自定义事件的表单输入组件"><a href="#使用自定义事件的表单输入组件" class="headerlink" title="使用自定义事件的表单输入组件"></a>使用自定义事件的表单输入组件</h3><p>自定义事件可以用来创建自定义的表单输入组件，使用 <code>v-model</code> 来进行数据双向绑定。</p><h4 id="不在组件中使用"><a href="#不在组件中使用" class="headerlink" title="不在组件中使用"></a>不在组件中使用</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"something"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 是以下示例的语法糖： --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:value</span>=<span class="string">"something"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:input</span>=<span class="string">"something = $event.target.value"</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="在组件中使用"><a href="#在组件中使用" class="headerlink" title="在组件中使用"></a>在组件中使用</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">custom-input</span> <span class="attr">v-model</span>=<span class="string">"something"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 是以下示例的语法糖： --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">custom-input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:value</span>=<span class="string">"something"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:input</span>=<span class="string">"something = arguments[0]"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要让组件的 <code>v-model</code> 生效，它应该 (从 2.2.0 起是可配置的)：</p><ul><li>接受一个 <code>value</code> prop</li><li>在有新的值时触发 <code>input</code> 事件并将新值作为参数</li></ul><p><a href="https://codepen.io/Wonder233/pen/GxdMjv?editors=1010" target="_blank" rel="noopener"><strong>示例：</strong>货币输入的自定义控件</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">currency-input</span> <span class="attr">v-model</span>=<span class="string">"price"</span>&gt;</span><span class="tag">&lt;/<span class="name">currency-input</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'currency-input'</span>, &#123;</span><br><span class="line">  template: <span class="string">`&lt;span&gt;</span></span><br><span class="line"><span class="string">      $&lt;input ref="input"</span></span><br><span class="line"><span class="string">        v-bind:value="value"</span></span><br><span class="line"><span class="string">        v-on:input="updateValue($event.target.value)"</span></span><br><span class="line"><span class="string">      &gt;</span></span><br><span class="line"><span class="string">    &lt;/span&gt;`</span>,</span><br><span class="line">  props: [<span class="string">'value'</span>],</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// 不是直接更新值，而是使用此方法来对输入值进行格式化和位数限制</span></span><br><span class="line">    updateValue: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> formattedValue = value</span><br><span class="line">        <span class="comment">// 删除两侧的空格符</span></span><br><span class="line">        .trim()</span><br><span class="line">        <span class="comment">// 保留 2 位小数</span></span><br><span class="line">        .slice(</span><br><span class="line">          <span class="number">0</span>,</span><br><span class="line">          value.indexOf(<span class="string">'.'</span>) === <span class="number">-1</span></span><br><span class="line">            ? value.length</span><br><span class="line">            : value.indexOf(<span class="string">'.'</span>) + <span class="number">3</span></span><br><span class="line">        );</span><br><span class="line">      <span class="comment">// 如果值尚不合规，则手动覆盖为合规的值</span></span><br><span class="line">      <span class="keyword">if</span> (formattedValue !== value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$refs.input.value = formattedValue;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 通过 input 事件带出数值</span></span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'input'</span>, <span class="built_in">Number</span>(formattedValue));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="自定义组件的-v-model"><a href="#自定义组件的-v-model" class="headerlink" title="自定义组件的 v-model"></a>自定义组件的 v-model</h3><blockquote><p>2.2.0 新增</p></blockquote><p>默认情况下，一个组件的 <code>v-model</code> 会使用 <code>value</code> 、prop 和 <code>input</code> 事件。</p><p><strong>问题：</strong><br>诸如单选框、复选框之类的输入类型可能把 <code>value</code> 用作了别的目的。</p><p><strong>解决方法：</strong><br><code>model</code> 选项可以避免这样的冲突：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-checkbox'</span>, &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    <span class="comment">// 注意：需要显式声明 checked 这个 prop。</span></span><br><span class="line">    prop: <span class="string">'checked'</span>,</span><br><span class="line">    event: <span class="string">'change'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    checked: <span class="built_in">Boolean</span>,</span><br><span class="line">    <span class="comment">// 这样就允许拿 `value` 这个 prop 做其它事了</span></span><br><span class="line">    value: <span class="built_in">String</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-checkbox</span> <span class="attr">v-model</span>=<span class="string">"foo"</span> <span class="attr">value</span>=<span class="string">"some value"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-checkbox</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 上述代码等价于： --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my-checkbox</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:checked</span>=<span class="string">"foo"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">change</span>=<span class="string">"val =&gt; &#123; foo = val &#125;"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">value</span>=<span class="string">"some value"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-checkbox</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="非父子组件的通信"><a href="#非父子组件的通信" class="headerlink" title="非父子组件的通信"></a>非父子组件的通信</h2><p>（1）在简单的场景下，可以使用一个空的 Vue 实例作为事件总线：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bus = <span class="keyword">new</span> Vue();</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在组件 A 中触发事件</span></span><br><span class="line">bus.$emit(<span class="string">'id-selected'</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在组件 B 创建的钩子中监听事件</span></span><br><span class="line">bus.$on(<span class="string">'id-selected'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>（2）在复杂的情况下，使用<a href="https://cn.vuejs.org/v2/guide/state-management.html" target="_blank" rel="noopener">状态管理模式</a>。</p><h2 id="使用插槽分发内容"><a href="#使用插槽分发内容" class="headerlink" title="使用插槽分发内容"></a>使用插槽分发内容</h2><p>组件可以组合，例如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-header</span>&gt;</span><span class="tag">&lt;/<span class="name">app-header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">app-footer</span>&gt;</span><span class="tag">&lt;/<span class="name">app-footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">app</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>注意两点：</p><ol><li><code>&lt;app&gt;</code> 组件不知道它会收到什么内容。这是由使用 <code>&lt;app&gt;</code> 的父组件决定的。</li><li><code>&lt;app&gt;</code> 组件很可能有它自己的模板。</li></ol><p><strong>内容分发：</strong>一种混合父组件的内容与子组件自己的模板的方式。</p><p>Vue.js 实现了一个内容分发 API，使用特殊的 <code>&lt;slot&gt;</code> 元素作为原始内容的插槽。</p><h3 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a>编译作用域</h3><p><strong>组件作用域：</strong></p><ul><li>父组件模板的内容在父组件作用域内编译；</li><li>子组件模板的内容在子组件作用域内编译。</li></ul><p>假定模板为：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child-component</span>&gt;</span></span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><code>message</code> 应该绑定到父组件的数据。</p><blockquote><p>一个常见错误是试图在父组件模板内将一个指令绑定到子组件的属性/方法：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 无效 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">child-component</span> <span class="attr">v-show</span>=<span class="string">"someChildProperty"</span>&gt;</span><span class="tag">&lt;/<span class="name">child-component</span>&gt;</span></span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>假定 <code>someChildProperty</code> 是子组件的属性，上例不会如预期那样工作。父组件模板并不感知子组件的状态。<br>如果要绑定子组件作用域内的指令到一个组件的根节点，应当在子组件自己的模板里做：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'child-component'</span>, &#123;</span><br><span class="line">  <span class="comment">// 有效，因为是在正确的作用域内</span></span><br><span class="line">  template: <span class="string">'&lt;div v-show="someChildProperty"&gt;Child&lt;/div&gt;'</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      someChildProperty: <span class="literal">true</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="单个插槽"><a href="#单个插槽" class="headerlink" title="单个插槽"></a>单个插槽</h3><p>父组件的内容只有在子组件模板包含至少一个 <code>&lt;slot&gt;</code> 插口时才会显示在子组件中。</p><p><strong>单个插槽作用：</strong><br>当子组件模板只有一个没有属性的插槽时，父组件传入的整个内容片段将插入到插槽所在的 DOM 位置，并替换掉插槽标签本身。</p><p>最初在 <code>&lt;slot&gt;</code> 标签中的任何内容都被视为<strong>备用内容</strong>。备用内容在子组件的作用域内编译，并且只有在宿主元素为空，且没有要插入的内容时才显示备用内容。</p><p>假定 <code>my-component</code> 组件有如下模板：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是子组件的标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span></span><br><span class="line">    只有在没有要分发的内容时才会显示。</span><br><span class="line">  <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>父组件模板：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是父组件的标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一些初始内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是更多的初始内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>渲染结果：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是父组件的标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是子组件的标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一些初始内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是更多的初始内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><ol><li>用一个特殊的特性 <code>name</code>  可以给 <code>&lt;slot&gt;</code> 元素配置如何分发内容。</li><li>多个插槽可以有不同的名字。</li><li>具名插槽将匹配内容片段中有对应 <code>slot</code> 特性的元素。</li><li>可以有一个匿名插槽，它是默认插槽，作为找不到匹配的内容片段的备用插槽。如果没有默认插槽，这些找不到匹配的内容片段将被抛弃。</li></ol><p>例如，假定我们有一个 <code>app-layout</code> 组件，它的模板为：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>父组件模板：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">app-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">slot</span>=<span class="string">"header"</span>&gt;</span>这里可能是一个页面标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>主要内容的一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>另一个主要段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">"footer"</span>&gt;</span>这里有一些联系信息<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">app-layout</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>渲染结果为：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这里可能是一个页面标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>主要内容的一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>另一个主要段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这里有一些联系信息<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><blockquote><p>2.1.0 新增</p></blockquote><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><p>作为一个 (能被传递数据的) 可重用模板，来代替已经渲染好的元素。</p><p><strong>示例1：</strong><br>在子组件中，只需将数据传递到插槽，就像你将 prop 传递给组件一样：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">text</span>=<span class="string">"hello from child"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在父级中，具有特殊特性 <code>slot-scope</code> 的 <code>&lt;template&gt;</code> 元素必须存在，表示它是作用域插槽的模板。<code>slot-scope</code> 的值将被用作一个临时变量名，此变量接收从子组件传递过来的 <code>prop</code> 对象：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">"props"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>hello from parent<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; props.text &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>渲染结果：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>hello from parent<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>hello from child<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><blockquote><p>在 2.5.0+，<code>slot-scope</code> 能被用在任意元素或组件中而不再局限于 <code>&lt;template&gt;</code>。</p></blockquote><p><strong>示例2：</strong><br>更典型的用例是在列表组件中，允许使用者自定义如何渲染列表的每一项：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-awesome-list</span> <span class="attr">:items</span>=<span class="string">"items"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 作用域插槽也可以是具名的 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">    <span class="attr">slot</span>=<span class="string">"item"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">slot-scope</span>=<span class="string">"props"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"my-fancy-item"</span>&gt;</span></span><br><span class="line">    &#123;&#123; props.text &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-awesome-list</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>列表组件<code>my-awesome-list</code>的模板：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"item"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">"item in items"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:text</span>=<span class="string">"item.text"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里写入备用内容 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h4><p><code>slot-scope</code> 的值实际上是一个可以出现在函数签名参数位置的合法的 JavaScript 表达式。</p><p>在受支持的环境 (单文件组件或现代浏览器) 中，可以在表达式中使用 ES2015 解构：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot-scope</span>=<span class="string">"&#123; text &#125;"</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h2><h3 id="在同一个挂载点动态切换多个组件"><a href="#在同一个挂载点动态切换多个组件" class="headerlink" title="在同一个挂载点动态切换多个组件"></a>在同一个挂载点动态切换多个组件</h3><p>通过使用保留的 <code>&lt;component&gt;</code> 元素，并对其 <code>is</code> 特性进行动态绑定。</p><h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    currentView: <span class="string">'home'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    home: &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">    posts: &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">    archive: &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentView"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 组件在 vm.currentview 变化时改变！ --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><p>直接绑定到组件对象上：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Home = &#123;</span><br><span class="line">  template: <span class="string">'&lt;p&gt;Welcome home!&lt;/p&gt;'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    currentView: Home</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h3><p><strong><code>keep-alive</code> 指令作用：</strong><br>可以把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"currentView"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 非活动组件将被缓存！ --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <a href="https://cn.vuejs.org/v2/api/#keep-alive" target="_blank" rel="noopener">API 参考</a>中查看更多 <code>&lt;keep-alive&gt;</code> 的细节。</p><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="编写可复用组件"><a href="#编写可复用组件" class="headerlink" title="编写可复用组件"></a>编写可复用组件</h3><p><strong>注意点：</strong></p><ol><li>在编写组件时，考虑好以后是否要进行复用。</li><li>可复用组件应当定义一个清晰的公开接口，同时也不要对其使用的外层数据作出任何假设。</li></ol><p>Vue 组件的 API 来自三部分——prop、事件和插槽：</p><ul><li>Prop 允许<strong>外部环境</strong>传递数据给组件；</li><li>事件允许<strong>从组件内触发</strong>传出数据给外部环境；</li><li>插槽允许外部环境<strong>将额外的内容组合</strong>在组件中。</li></ul><p>使用 <code>v-bind</code> 和 <code>v-on</code> 的简写语法，模板的意图会更清楚且简洁：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:foo</span>=<span class="string">"baz"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:bar</span>=<span class="string">"qux"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">event-a</span>=<span class="string">"doThis"</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">event-b</span>=<span class="string">"doThat"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">slot</span>=<span class="string">"icon"</span> <span class="attr">src</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">"main-text"</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="子组件引用"><a href="#子组件引用" class="headerlink" title="子组件引用"></a>子组件引用</h3><p>尽管有 prop 和事件，但是有时仍然需要在 JavaScript 中直接访问子组件。</p><p><strong>方法：</strong><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">user-profile</span> <span class="attr">ref</span>=<span class="string">"profile"</span>&gt;</span><span class="tag">&lt;/<span class="name">user-profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = <span class="keyword">new</span> Vue(&#123; <span class="attr">el</span>: <span class="string">'#parent'</span> &#125;);</span><br><span class="line"><span class="comment">// 访问子组件实例</span></span><br><span class="line"><span class="keyword">var</span> child = parent.$refs.profile;</span><br></pre></td></tr></table></figure><p>当 <code>ref</code> 和 <code>v-for</code> 一起使用时，获取到的引用会是一个数组，包含和循环数据源对应的子组件。</p><blockquote><p><code>$refs</code> 只在组件渲染完成后才填充，并且它是非响应式的。它仅仅是一个直接操作子组件的应急方案——应当避免在模板或计算属性中使用 <code>$refs</code>。</p></blockquote><h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><p>Vue.js 允许将组件定义为一个工厂函数，异步地解析组件的定义。</p><p>Vue.js 只在组件需要渲染时触发工厂函数，并且把结果缓存起来，用于后面的再次渲染。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'async-example'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将组件定义传入 resolve 回调函数</span></span><br><span class="line">    resolve(&#123;</span><br><span class="line">      template: <span class="string">'&lt;div&gt;I am async!&lt;/div&gt;'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>工厂函数接收一个 <code>resolve</code> 回调，在收到从服务器下载的组件定义时调用。也可以调用 reject(reason) 指示加载失败。</p><p>可以在工厂函数中返回一个 <code>Promise</code>，所以当使用 webpack 2 + ES2015 的语法时可以这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(</span><br><span class="line">  <span class="string">'async-webpack-example'</span>,</span><br><span class="line">  <span class="comment">// 该 `import` 函数返回一个 `Promise` 对象。</span></span><br><span class="line">  () =&gt; <span class="keyword">import</span>(<span class="string">'./my-async-component'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>当使用局部注册时，也可以直接提供一个返回 <code>Promise</code> 的函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">'my-component'</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./my-async-component'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="高级异步组件"><a href="#高级异步组件" class="headerlink" title="高级异步组件"></a>高级异步组件</h3><p>自 2.3.0 起，异步组件的工厂函数也可以返回一个如下的对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> AsyncComp = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">  <span class="comment">// 需要加载的组件。应当是一个 Promise</span></span><br><span class="line">  component: <span class="keyword">import</span>(<span class="string">'./MyComp.vue'</span>),</span><br><span class="line">  <span class="comment">// 加载中应当渲染的组件</span></span><br><span class="line">  loading: LoadingComp,</span><br><span class="line">  <span class="comment">// 出错时渲染的组件</span></span><br><span class="line">  error: ErrorComp,</span><br><span class="line">  <span class="comment">// 渲染加载中组件前的等待时间。默认：200ms。</span></span><br><span class="line">  delay: <span class="number">200</span>,</span><br><span class="line">  <span class="comment">// 最长等待时间。超出此时间则渲染错误组件。默认：Infinity</span></span><br><span class="line">  timeout: <span class="number">3000</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>注意，当一个异步组件被作为 <code>vue-router</code> 的路由组件使用时，这些高级选项都是无效的，因为在路由切换前就会提前加载所需要的异步组件。另外，如果你要在路由组件中使用上述写法，需要使用 <code>vue-router</code> 2.4.0 以上的版本。</p><h3 id="组件命名约定"><a href="#组件命名约定" class="headerlink" title="组件命名约定"></a>组件命名约定</h3><ol><li><p>可以使用 <strong>kebab-case (短横线分隔命名)</strong>、<strong>camelCase (驼峰式命名)</strong> 或 <strong>PascalCase (单词首字母大写命名)</strong>注册组件 (或者 prop)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在组件定义中</span></span><br><span class="line">components: &#123;</span><br><span class="line">  <span class="comment">// 使用 kebab-case 注册</span></span><br><span class="line">  <span class="string">'kebab-cased-component'</span>: &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">  <span class="comment">// 使用 camelCase 注册</span></span><br><span class="line">  <span class="string">'camelCasedComponent'</span>: &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">  <span class="comment">// 使用 PascalCase 注册</span></span><br><span class="line">  <span class="string">'PascalCasedComponent'</span>: &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 HTML 模板中，请使用 <strong>kebab-case</strong>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在 HTML 模板中始终使用 kebab-case --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">kebab-cased-component</span>&gt;</span><span class="tag">&lt;/<span class="name">kebab-cased-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">camel-cased-component</span>&gt;</span><span class="tag">&lt;/<span class="name">camel-cased-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pascal-cased-component</span>&gt;</span><span class="tag">&lt;/<span class="name">pascal-cased-component</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>当使用字符串模式时，可以不受 HTML 大小写不敏感的限制。</p><p>在模板中，可以使用下面的方式来引用你的组件：</p><ul><li>kebab-case</li><li>camelCase 或 kebab-case (如果组件已经被定义为 camelCase)</li><li>kebab-case、camelCase 或 PascalCase (如果组件已经被定义为 PascalCase)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">components: &#123;</span><br><span class="line">  <span class="string">'kebab-cased-component'</span>: &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">  <span class="string">'camelCasedComponent'</span>: &#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">  <span class="string">'PascalCasedComponent'</span>: &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">kebab-cased-component</span>&gt;</span><span class="tag">&lt;/<span class="name">kebab-cased-component</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">camel-cased-component</span>&gt;</span><span class="tag">&lt;/<span class="name">camel-cased-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">camelCasedComponent</span>&gt;</span><span class="tag">&lt;/<span class="name">camelCasedComponent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">pascal-cased-component</span>&gt;</span><span class="tag">&lt;/<span class="name">pascal-cased-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pascalCasedComponent</span>&gt;</span><span class="tag">&lt;/<span class="name">pascalCasedComponent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PascalCasedComponent</span>&gt;</span><span class="tag">&lt;/<span class="name">PascalCasedComponent</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>意味着：<br> PascalCase 是最通用的声明约定。<br> kebab-case 是最通用的使用约定。</p></blockquote><h3 id="递归组件"><a href="#递归组件" class="headerlink" title="递归组件"></a><a href="https://cn.vuejs.org/v2/guide/components.html#%E9%80%92%E5%BD%92%E7%BB%84%E4%BB%B6" target="_blank" rel="noopener">递归组件</a></h3><h3 id="组件间的循环引用"><a href="#组件间的循环引用" class="headerlink" title="组件间的循环引用"></a><a href="https://cn.vuejs.org/v2/guide/components.html#%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8" target="_blank" rel="noopener">组件间的循环引用</a></h3><h3 id="内联模板"><a href="#内联模板" class="headerlink" title="内联模板"></a><a href="https://cn.vuejs.org/v2/guide/components.html#%E5%86%85%E8%81%94%E6%A8%A1%E6%9D%BF" target="_blank" rel="noopener">内联模板</a></h3><h3 id="X-Template"><a href="#X-Template" class="headerlink" title="X-Template"></a><a href="https://cn.vuejs.org/v2/guide/components.html#X-Template" target="_blank" rel="noopener">X-Template</a></h3><h3 id="对低开销的静态组件使用-v-once"><a href="#对低开销的静态组件使用-v-once" class="headerlink" title="对低开销的静态组件使用 v-once"></a><a href="https://cn.vuejs.org/v2/guide/components.html#%E5%AF%B9%E4%BD%8E%E5%BC%80%E9%94%80%E7%9A%84%E9%9D%99%E6%80%81%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8-v-once" target="_blank" rel="noopener">对低开销的静态组件使用 v-once</a></h3>]]></content>
      
      <categories>
          
          <category> Vue学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>表单输入绑定</title>
      <link href="/2018/03/31/Vue%E5%AD%A6%E4%B9%A0/%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E7%BB%91%E5%AE%9A/"/>
      <url>/2018/03/31/Vue%E5%AD%A6%E4%B9%A0/%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E7%BB%91%E5%AE%9A/</url>
      <content type="html"><![CDATA[<h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><p>使用 <code>v-model</code> 指令在表单 <code>&lt;input&gt;</code> 及 <code>&lt;textarea&gt;</code> 元素上创建<strong>双向数据绑定</strong>。它会根据控件类型<strong>自动选取</strong>正确的方法来更新元素。</p><p><code>v-model</code> 的<strong>本质：</strong><br>语法糖。负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。</p><blockquote><p><code>v-model</code> 会忽略所有表单元素的 <code>value</code>、<code>checked</code>、<code>selected</code> 特性的初始值而总是将 Vue 实例的数据作为数据来源。<br>应该通过 JavaScript 在组件的 <code>data</code> 选项中声明初始值。</p></blockquote><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><p><a href="https://codepen.io/Wonder233/pen/WzJvgm?editors=1010" target="_blank" rel="noopener">参考示例</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"message"</span> <span class="attr">placeholder</span>=<span class="string">"edit me"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Message is: &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="多行文本"><a href="#多行文本" class="headerlink" title="多行文本"></a>多行文本</h3><p><a href="https://codepen.io/Wonder233/pen/WzJvgm?editors=1010" target="_blank" rel="noopener">参考示例</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Multiline message is:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"white-space: pre-line;"</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">v-model</span>=<span class="string">"message"</span> <span class="attr">placeholder</span>=<span class="string">"add multiple lines"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure></p><blockquote><p>在文本区域插值——数据单向绑定 (<code>&lt;textarea&gt;&lt;/textarea&gt;</code>) 并不会生效，应用 v-model 来代替。</p></blockquote><h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><p>（1）单个复选框，绑定到布尔值：<a href="https://codepen.io/Wonder233/pen/WzJvgm?editors=1010" target="_blank" rel="noopener">参考示例</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"checkbox"</span> <span class="attr">v-model</span>=<span class="string">"checked"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"checkbox"</span>&gt;</span>&#123;&#123; checked &#125;&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>（2）多个复选框，绑定到同一个数组：<a href="https://codepen.io/Wonder233/pen/WzJvgm?editors=1010" target="_blank" rel="noopener">参考示例</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'example-3'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"jack"</span> <span class="attr">value</span>=<span class="string">"Jack"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"jack"</span>&gt;</span>Jack<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"john"</span> <span class="attr">value</span>=<span class="string">"John"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"john"</span>&gt;</span>John<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"mike"</span> <span class="attr">value</span>=<span class="string">"Mike"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"mike"</span>&gt;</span>Mike<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Checked names: &#123;&#123; checkedNames &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-3'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    checkedNames: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="单选按钮"><a href="#单选按钮" class="headerlink" title="单选按钮"></a>单选按钮</h3><p><a href="https://codepen.io/Wonder233/pen/WzJvgm?editors=1010" target="_blank" rel="noopener">参考示例</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-4"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"one"</span> <span class="attr">value</span>=<span class="string">"One"</span> <span class="attr">v-model</span>=<span class="string">"picked"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"one"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"two"</span> <span class="attr">value</span>=<span class="string">"Two"</span> <span class="attr">v-model</span>=<span class="string">"picked"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"two"</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Picked: &#123;&#123; picked &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-4'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    picked: <span class="string">'one'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="选择框"><a href="#选择框" class="headerlink" title="选择框"></a>选择框</h3><p>（1）单选时：<a href="https://codepen.io/Wonder233/pen/WzJvgm?editors=1010" target="_blank" rel="noopener">参考示例</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-5"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">disabled</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span>请选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'...'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    selected: <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>如果 <code>v-model</code> 表达式的初始值未能匹配任何选项，<code>&lt;select&gt;</code> 元素将被渲染为“未选中”状态。<br>在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 <code>change</code> 事件。因此，更推荐像上面这样提供一个值为空的禁用选项。</p></blockquote><p>（2）多选时：<a href="https://codepen.io/Wonder233/pen/WzJvgm?editors=1010" target="_blank" rel="noopener">参考示例</a><br>绑定到一个数组。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-6"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span> <span class="attr">multiple</span> <span class="attr">style</span>=<span class="string">"width: 50px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>（3）可以用 <code>v-for</code> 渲染动态选项：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">v-for</span>=<span class="string">"option in options"</span> <span class="attr">v-bind:value</span>=<span class="string">"option.value"</span>&gt;</span></span><br><span class="line">    &#123;&#123; option.text &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'...'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    selected: <span class="string">'A'</span>,</span><br><span class="line">    options: [</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">'One'</span>, <span class="attr">value</span>: <span class="string">'A'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">'Two'</span>, <span class="attr">value</span>: <span class="string">'B'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">'Three'</span>, <span class="attr">value</span>: <span class="string">'C'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h2><p><strong>静态属性绑定：</strong>对于单选按钮，复选框及选择框的选项，<code>v-model</code> 绑定的值通常是<strong>静态字符串</strong> (对于复选框也可以是布尔值)：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当选中时，`picked` 为字符串 "a" --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">v-model</span>=<span class="string">"picked"</span> <span class="attr">value</span>=<span class="string">"a"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- `toggle` 为 true 或 false --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">v-model</span>=<span class="string">"toggle"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 当选中第一个选项时，`selected` 为字符串 "abc" --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"abc"</span>&gt;</span>ABC<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>动态属性绑定：</strong>用 <code>v-bind</code> 实现，并且这个属性的值可以不是字符串。</p><h3 id="复选框-1"><a href="#复选框-1" class="headerlink" title="复选框"></a>复选框</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">v-model</span>=<span class="string">"toggle"</span> <span class="attr">true-value</span>=<span class="string">"yes"</span> <span class="attr">false-value</span>=<span class="string">"no"</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当选中时</span></span><br><span class="line">vm.toggle === <span class="string">'yes'</span>;</span><br><span class="line"><span class="comment">// 当没有选中时</span></span><br><span class="line">vm.toggle === <span class="string">'no'</span>;</span><br></pre></td></tr></table></figure><h3 id="单选按钮-1"><a href="#单选按钮-1" class="headerlink" title="单选按钮"></a>单选按钮</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">v-model</span>=<span class="string">"pick"</span> <span class="attr">v-bind:value</span>=<span class="string">"a"</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当选中时</span></span><br><span class="line">vm.pick === vm.a;</span><br></pre></td></tr></table></figure><h3 id="选择框的选项"><a href="#选择框的选项" class="headerlink" title="选择框的选项"></a>选择框的选项</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 内联对象字面量 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">v-bind:value</span>=<span class="string">"&#123; number: 123 &#125;"</span>&gt;</span>123<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当选中时</span></span><br><span class="line"><span class="keyword">typeof</span> vm.selected; <span class="comment">// =&gt; 'object'</span></span><br><span class="line">vm.selected.number; <span class="comment">// =&gt; 123</span></span><br></pre></td></tr></table></figure><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><h3 id="lazy"><a href="#lazy" class="headerlink" title=".lazy"></a><code>.lazy</code></h3><p><strong>默认情况</strong>下，<code>v-model</code> 在每次 input 事件触发后将输入框的值与数据进行同步 。<br>添加 <code>lazy</code> 修饰符，将转变为<strong>使用 <code>change</code> 事件</strong>进行同步：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在“change”时而非“input”时更新 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.lazy</span>=<span class="string">"msg"</span> &gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="number"><a href="#number" class="headerlink" title=".number"></a><code>.number</code></h3><p>给 <code>v-model</code> 添加 <code>number</code> 修饰符，自动将用户的输入值转为数值类型：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.number</span>=<span class="string">"age"</span> <span class="attr">type</span>=<span class="string">"number"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="trim"><a href="#trim" class="headerlink" title=".trim"></a><code>.trim</code></h3><p>给 <code>v-model</code> 添加 <code>trim</code> 修饰符，自动过滤用户输入的首尾空白字符：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.trim</span>=<span class="string">"msg"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Vue学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>事件处理</title>
      <link href="/2018/03/31/Vue%E5%AD%A6%E4%B9%A0/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
      <url>/2018/03/31/Vue%E5%AD%A6%E4%B9%A0/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="事件绑定方法"><a href="#事件绑定方法" class="headerlink" title="事件绑定方法"></a>事件绑定方法</h2><h3 id="直接运行-JavaScript-代码"><a href="#直接运行-JavaScript-代码" class="headerlink" title="直接运行 JavaScript 代码"></a>直接运行 JavaScript 代码</h3><p>用 <code>v-on</code> 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。<br>示例：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"counter += 1"</span>&gt;</span>Add 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>The button above has been clicked &#123;&#123; counter &#125;&#125; times.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example1 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-1'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    counter: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong><a href="https://codepen.io/Wonder233/pen/MVGYRz" target="_blank" rel="noopener">结果演示</a></strong></p><h3 id="添加事件处理方法名称"><a href="#添加事件处理方法名称" class="headerlink" title="添加事件处理方法名称"></a>添加事件处理方法名称</h3><p><code>v-on</code> 可以接收一个需要调用的方法名称。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-2"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- `greet` 是在下面定义的方法名 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"greet"</span>&gt;</span>Greet<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example2 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-2'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    name: <span class="string">'Wonder233'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 在 `methods` 对象中定义方法</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    greet: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// `this` 在方法里指向当前 Vue 实例</span></span><br><span class="line">      alert(<span class="string">'Hello '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</span><br><span class="line">      <span class="comment">// `event` 是原生 DOM 事件</span></span><br><span class="line">      <span class="keyword">if</span> (event) &#123;</span><br><span class="line">        alert(event.target.tagName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以用 JavaScript 直接调用方法</span></span><br><span class="line">example2.greet() <span class="comment">// =&gt; 'Hello Wonder233!'</span></span><br></pre></td></tr></table></figure><p><strong><a href="https://codepen.io/Wonder233/pen/oqdgRb" target="_blank" rel="noopener">结果演示</a></strong></p><h3 id="在内联处理器（JavaScript语句）中调用方法"><a href="#在内联处理器（JavaScript语句）中调用方法" class="headerlink" title="在内联处理器（JavaScript语句）中调用方法"></a>在内联处理器（JavaScript语句）中调用方法</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-3"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"say('hi')"</span>&gt;</span>Say hi<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"say('what')"</span>&gt;</span>Say what<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-3'</span>,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    say: <span class="function"><span class="keyword">function</span> (<span class="params">message</span>) </span>&#123;</span><br><span class="line">      alert(message)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 <code>$event</code> 把它传入方法：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"warn('Form cannot be submitted yet.', $event)"</span>&gt;</span></span><br><span class="line">  Submit</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  warn: <span class="function"><span class="keyword">function</span> (<span class="params">message, event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 现在我们可以访问原生事件对象</span></span><br><span class="line">    <span class="keyword">if</span> (event) </span><br><span class="line">    event.preventDefault();</span><br><span class="line">    alert(message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><p><strong>目的：</strong><br>为了使方法只有纯粹的数据逻辑，不去处理 DOM 事件细节。</p><p><strong>解决办法：</strong><br>使用事件修饰符。</p><p>修饰符是由点开头的指令后缀来表示的。</p><ul><li><code>.stop</code></li><li><code>.prevent</code></li><li><code>.capture</code></li><li><code>.self</code></li><li><code>.once</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"onSubmit"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">"doThat"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">"doThis"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">"doThat"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。<br>因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。</p></blockquote><hr><blockquote><p>2.1.4 新增</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 点击事件将只会触发一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.once</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不像其它只能对原生的 DOM 事件起作用的修饰符，<code>.once</code> 修饰符还能被用到自定义的组件事件上。</p><hr><blockquote><p>2.3.0 新增</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 而不会等待 `onScroll` 完成  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:scroll.passive</span>=<span class="string">"onScroll"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>.passive</code> 修饰符尤其能够提升移动端的性能。</p><blockquote><p>注意：<br>不要把 <code>.passive</code> 和 <code>.prevent</code> 一起使用，因为 <code>.prevent</code> 将会被忽略，同时浏览器可能会向你展示一个警告。<br>请记住，<code>.passive</code> 会告诉浏览器你不想阻止事件的默认行为。</p></blockquote><h3 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h3><p>Vue 允许为 <code>v-on</code> 在监听键盘事件时添加按键修饰符：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.13</span>=<span class="string">"submit"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>Vue 为最常用的按键提供了别名：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 同上 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.enter</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.enter</span>=<span class="string">"submit"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>全部的按键别名：</p><ul><li><code>.enter</code></li><li><code>.tab</code></li><li><code>.delete</code> (捕获“删除”和“退格”键)</li><li><code>.esc</code></li><li><code>.space</code></li><li><code>.up</code></li><li><code>.down</code></li><li><code>.left</code></li><li><code>.right</code></li></ul><p>可以通过全局 <code>config.keyCodes</code> 对象自定义按键修饰符别名：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以使用 `v-on:keyup.f1`</span></span><br><span class="line">Vue.config.keyCodes.f1 = <span class="number">112</span></span><br></pre></td></tr></table></figure></p><h4 id="自动匹配按键修饰符"><a href="#自动匹配按键修饰符" class="headerlink" title="自动匹配按键修饰符"></a>自动匹配按键修饰符</h4><blockquote><p>2.5.0 新增</p></blockquote><p>可直接将 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/KeyboardEvent/key" target="_blank" rel="noopener">KeyboardEvent.key</a> 暴露的任意有效按键名转换为 kebab-case（短横线命名） 来作为修饰符：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.page-down</span>=<span class="string">"onPageDown"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在上面的例子中，处理函数仅在 $event.key === ‘PageDown’ 时被调用。</p><h3 id="系统修饰键"><a href="#系统修饰键" class="headerlink" title="系统修饰键"></a>系统修饰键</h3><blockquote><p>2.1.0 新增</p></blockquote><p>可以用如下修饰符来实现仅在<strong>按下相应按键</strong>时才触发<strong>鼠标或键盘事件</strong>的监听器。</p><ul><li><code>.ctrl</code></li><li><code>.alt</code></li><li><code>.shift</code></li><li><code>.meta</code></li></ul><blockquote><p>注意：<br>在 Mac 系统键盘上，meta 对应 command 键 (⌘)。<br>在 Windows 系统键盘 meta 对应 Windows 徽标键 (⊞)。<br>在 Sun 操作系统键盘上，meta 对应实心宝石键 (◆)。<br>在其他特定键盘上，尤其在 MIT 和 Lisp 机器的键盘、以及其后继产品，比如 Knight 键盘、space-cadet 键盘，meta 被标记为“META”。<br>在 Symbolics 键盘上，meta 被标记为“META”或者“Meta”。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Alt + C --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.alt.67</span>=<span class="string">"clear"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Ctrl + Click --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.ctrl</span>=<span class="string">"doSomething"</span>&gt;</span>Do something<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>请注意修饰键与常规按键不同：<br>在和 keyup 事件一起用时，事件触发时<strong>修饰键必须处于按下状态</strong>。<br>换句话说，只有在按住 ctrl 的情况下释放其它按键，才能触发 keyup.ctrl。而单单释放 ctrl 也不会触发事件。如果你想要这样的行为，请为 ctrl 换用 keyCode：keyup.17。</p></blockquote><h4 id="exact-修饰符"><a href="#exact-修饰符" class="headerlink" title=".exact 修饰符"></a>.exact 修饰符</h4><blockquote><p>2.5.0 新增</p></blockquote><p><code>.exact</code> 修饰符允许你控制由<strong>精确的系统修饰符组合触发的事件</strong>。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.ctrl</span>=<span class="string">"onClick"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.ctrl.exact</span>=<span class="string">"onCtrlClick"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.exact</span>=<span class="string">"onClick"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><a href="https://codepen.io/Wonder233/pen/YaLXrx" target="_blank" rel="noopener">参考示例</a></p><h4 id="鼠标按钮修饰符"><a href="#鼠标按钮修饰符" class="headerlink" title="鼠标按钮修饰符"></a>鼠标按钮修饰符</h4><blockquote><p>2.2.0 新增</p></blockquote><p>限制处理函数仅响应特定的鼠标按钮：</p><ul><li><code>.left</code></li><li><code>.right</code></li><li><code>.middle</code></li></ul><h2 id="为什么在-HTML-中监听事件"><a href="#为什么在-HTML-中监听事件" class="headerlink" title="为什么在 HTML 中监听事件?"></a>为什么在 HTML 中监听事件?</h2><p>Vue 的这种事件监听的方式违背了关注点分离 (separation of concern) 这个长期以来的优良传统。</p><p>但不必担心，因为所有的 Vue.js <strong>事件处理方法和表达式都严格绑定在当前视图的 ViewModel</strong> 上，它不会导致任何维护上的困难。实际上，使用 v-on 有几个好处：</p><ol><li><p>扫一眼 HTML 模板便<strong>能轻松定位</strong>在 JavaScript 代码里<strong>对应的方法</strong>。</p></li><li><p>因为你无须在 JavaScript 里手动绑定事件，你的 <strong>ViewModel 代码可以是非常纯粹的逻辑</strong>，和 DOM 完全解耦，更易于测试。</p></li><li><p>当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。</p></li></ol>]]></content>
      
      <categories>
          
          <category> Vue学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>列表渲染</title>
      <link href="/2018/03/31/Vue%E5%AD%A6%E4%B9%A0/%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/"/>
      <url>/2018/03/31/Vue%E5%AD%A6%E4%B9%A0/%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/</url>
      <content type="html"><![CDATA[<h2 id="一个数组的-v-for"><a href="#一个数组的-v-for" class="headerlink" title="一个数组的 v-for"></a>一个数组的 v-for</h2><p>用 <code>v-for</code> 指令根据一组数组的选项列表进行渲染。</p><p>（1）<code>v-for</code> 指令需要使用 <code>item in items</code> 形式的特殊语法，<code>items</code> 是源数据数组并且 <code>item</code> 是数组元素迭代的别名。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"example-1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span></span><br><span class="line">    &#123;&#123;item.message&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example1 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-1'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [</span><br><span class="line">      &#123; <span class="attr">message</span>: <span class="string">'Foo'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">message</span>: <span class="string">'Bar'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>结果：<br><img src="/2018/03/31/Vue学习/列表渲染/./1.png" alt="Alt text"></p><p>（2）v-for 还支持一个可选的第二个参数为当前项的索引。</p><blockquote><p>在 v-for 块中，我们拥有对父作用域属性的完全访问权限。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"example-2"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in items"</span>&gt;</span></span><br><span class="line">    &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example2 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-2'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    parentMessage: <span class="string">'Parent'</span>,</span><br><span class="line">    items: [</span><br><span class="line">      &#123; <span class="attr">message</span>: <span class="string">'Foo'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">message</span>: <span class="string">'Bar'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="/2018/03/31/Vue学习/列表渲染/./2.png" alt="Alt text"></p><p>（3）也可以用 of 替代 in 作为分隔符，因为它是最接近 JavaScript 迭代器的语法：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item of items"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="一个对象的-v-for"><a href="#一个对象的-v-for" class="headerlink" title="一个对象的 v-for"></a>一个对象的 v-for</h2><p>（1）可以用 v-for 通过一个对象的属性来迭代。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"v-for-object"</span> <span class="attr">class</span>=<span class="string">"demo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"value in object"</span>&gt;</span></span><br><span class="line">    &#123;&#123;value&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#v-for-object'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    object: &#123;</span><br><span class="line">      firstName: <span class="string">'John'</span>,</span><br><span class="line">      lastName: <span class="string">'Doe'</span>,</span><br><span class="line">      age: <span class="number">30</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>结果：<br><img src="/2018/03/31/Vue学习/列表渲染/./3.png" alt="Alt text"></p><p>（2）可以提供第二个的参数为键名：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(value, key) in object"</span>&gt;</span></span><br><span class="line">  &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><img src="/2018/03/31/Vue学习/列表渲染/./4.png" alt="Alt text"></p><p>（3）可以提供第三个参数为索引：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(value, key, index) in object"</span>&gt;</span></span><br><span class="line">  &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><img src="/2018/03/31/Vue学习/列表渲染/./5.png" alt="Alt text"></p><blockquote><p>在遍历对象时，是按 Object.keys() 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下是一致的。</p></blockquote><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>当 Vue.js 用 <code>v-for</code> 正在更新已渲染过的元素列表时，它默认用“<strong>就地复用</strong>”策略。<br>如果数据项的顺序被改变，Vue 将<strong>不会移动 DOM 元素</strong>来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。</p><p>这个默认的模式是高效的，但是只适用于<strong>不依赖子组件状态</strong>或<strong>临时 DOM 状态</strong> (例如：表单输入值) 的列表渲染输出。</p><p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 <code>key</code> 属性。理想的 <code>key</code> 值是每项都有的且唯一的 <code>id</code>。它的工作方式类似于一个属性，所以你需要用 <code>v-bind</code> 来绑定动态值 (在这里使用简写)：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></span><br><span class="line">&#123;&#123;item&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><blockquote><p>建议尽可能在使用 <code>v-for</code> 时提供 <code>key</code>，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。</p></blockquote><h2 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h2><h3 id="变异方法"><a href="#变异方法" class="headerlink" title="变异方法"></a>变异方法</h3><p>变异方法 (mutation method)：改变被这些方法调用的原始数组。</p><p>Vue 包含一组观察数组的变异方法，它们会触发视图更新。这些方法如下：</p><ul><li><code>push()</code></li><li><code>pop()</code></li><li><code>shift()</code></li><li><code>unshift()</code></li><li><code>splice()</code></li><li><code>sort()</code></li><li><code>reverse()</code></li></ul><h3 id="替换数组"><a href="#替换数组" class="headerlink" title="替换数组"></a>替换数组</h3><p>非变异方法 (non-mutating method)：不会改变原始数组，但总是返回一个新数组。例如：<code>filter(), concat()</code>和<code>slice()</code> 。</p><p>当使用非变异方法时，可以用新数组替换旧数组：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">example1.items = example1.items.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item.message.match(<span class="regexp">/Foo/</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的、启发式的方法，所以用一个<strong>含有相同元素的数组</strong>去替换原来的数组是非常高效的操作。</p></blockquote><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>由于 JavaScript 的限制，Vue 不能检测通过以下方法变动的数组：</p><ol><li>利用索引直接设置一个项，例如：<code>vm.items[indexOfItem] = newValue</code></li><li>修改数组的长度，例如：<code>vm.items.length = newLength</code></li></ol><p>举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">vm.items[<span class="number">1</span>] = <span class="string">'x'</span>; <span class="comment">// 不是响应性的</span></span><br><span class="line">vm.items.length = <span class="number">2</span>; <span class="comment">// 不是响应性的</span></span><br></pre></td></tr></table></figure></p><h4 id="解决第一类问题"><a href="#解决第一类问题" class="headerlink" title="解决第一类问题"></a>解决第一类问题</h4><p>以下两种方式可以实现和 <code>vm.items[indexOfItem] = newValue</code> 相同的效果，同时也将触发状态更新：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue.set</span></span><br><span class="line">Vue.set(vm.items, indexOfItem, newValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用 `vm.$set` 实例方法，该方法是全局方法 `Vue.set` 的一个别名：</span></span><br><span class="line">vm.$set(vm.items, indexOfItem, newValue);</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array.prototype.splice</span></span><br><span class="line">vm.items.splice(indexOfItem, <span class="number">1</span>, newValue);</span><br></pre></td></tr></table></figure><h4 id="解决第二类问题"><a href="#解决第二类问题" class="headerlink" title="解决第二类问题"></a>解决第二类问题</h4><p>使用 <code>splice</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.items.splice(newLength);</span><br></pre></td></tr></table></figure></p><h2 id="对象更新检测"><a href="#对象更新检测" class="headerlink" title="对象更新检测"></a>对象更新检测</h2><h4 id="问题一："><a href="#问题一：" class="headerlink" title="问题一："></a>问题一：</h4><p>由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// `vm.a` 现在是响应式的</span></span><br><span class="line"></span><br><span class="line">vm.b = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// `vm.b` 不是响应式的</span></span><br></pre></td></tr></table></figure></p><blockquote><p>对于已经创建的实例，Vue 不能动态添加根级别的响应式属性。</p></blockquote><p><strong>解决方案：</strong><br>使用 <code>Vue.set(object, key, value)</code> 方法向嵌套对象添加响应式属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    userProfile: &#123;</span><br><span class="line">      name: <span class="string">'Anika'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加一个新的 age 属性到嵌套的 userProfile 对象：</span></span><br><span class="line">Vue.set(vm.userProfile, <span class="string">'age'</span>, <span class="number">27</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//还可以使用 vm.$set 实例方法，它只是全局 Vue.set 的别名：</span></span><br><span class="line">vm.$set(vm.userProfile, <span class="string">'age'</span>, <span class="number">27</span>);</span><br></pre></td></tr></table></figure></p><h4 id="问题二："><a href="#问题二：" class="headerlink" title="问题二："></a>问题二：</h4><p>为已有对象赋予多个新属性，比如使用 <code>Object.assign()</code> 或 <code>_.extend()</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(vm.userProfile, &#123;</span><br><span class="line">  age: <span class="number">27</span>,</span><br><span class="line">  favoriteColor: <span class="string">'Vue Green'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//不起作用</span></span><br></pre></td></tr></table></figure></p><p><strong>解决方案：</strong><br>应该用两个对象的属性创建一个新的对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vm.userProfile = <span class="built_in">Object</span>.assign(&#123;&#125;, vm.userProfile, &#123;</span><br><span class="line">  age: <span class="number">27</span>,</span><br><span class="line">  favoriteColor: <span class="string">'Vue Green'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="显示过滤-排序结果"><a href="#显示过滤-排序结果" class="headerlink" title="显示过滤/排序结果"></a>显示过滤/排序结果</h2><p><strong>目的：</strong><br>显示一个数组的过滤或排序副本，而不实际改变或重置原始数据。</p><p><strong>解决方案一：</strong><br>创建返回过滤或排序数组的计算属性。</p><p>例如：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"n in evenNumbers"</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  numbers: [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  evenNumbers: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.numbers.filter(<span class="function"><span class="keyword">function</span> (<span class="params">number</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> number % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解决方案二：</strong><br>在计算属性不适用的情况下 (例如，在嵌套 <code>v-for</code> 循环中) 使用 <code>method</code> 方<br>法。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"n in even(numbers)"</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  numbers: [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  even: <span class="function"><span class="keyword">function</span> (<span class="params">numbers</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> numbers.filter(<span class="function"><span class="keyword">function</span> (<span class="params">number</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> number % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一段取值范围的-v-for"><a href="#一段取值范围的-v-for" class="headerlink" title="一段取值范围的 v-for"></a>一段取值范围的 v-for</h2><p>v-for 也可以取整数。在这种情况下，它将重复多次模板。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">"n in 10"</span>&gt;</span>&#123;&#123; n &#125;&#125; <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>结果：</strong><br><img src="/2018/03/31/Vue学习/列表渲染/./6.png" alt="Alt text"></p><h2 id="在模板中使用-v-for"><a href="#在模板中使用-v-for" class="headerlink" title="在模板中使用 v-for"></a>在模板中使用 v-for</h2><p>可以利用带有 <code>v-for</code> 的 <code>&lt;template&gt;</code> 渲染多个元素。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; item.msg &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"divider"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="在-v-for-中使用-v-if"><a href="#在-v-for-中使用-v-if" class="headerlink" title="在 v-for 中使用 v-if"></a>在 v-for 中使用 v-if</h2><p>处于同一节点时，<code>v-for</code> 的优先级比 <code>v-if</code> 更高，这意味着 <code>v-if</code> 将分别重复运行于每个 <code>v-for</code> 循环中。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"todo in todos"</span> <span class="attr">v-if</span>=<span class="string">"!todo.isComplete"</span>&gt;</span></span><br><span class="line">  &#123;&#123; todo &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>想要有条件地跳过循环的执行。</p><p><strong>解决方案：</strong><br>将 <code>v-if</code> 置于外层元素 (或 <code>&lt;template&gt;</code>)上。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-if</span>=<span class="string">"todos.length"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"todo in todos"</span>&gt;</span></span><br><span class="line">    &#123;&#123; todo &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>No todos left!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="在组件中使用-v-for"><a href="#在组件中使用-v-for" class="headerlink" title="在组件中使用 v-for"></a>在组件中使用 v-for</h2><p>在自定义组件里，可以像任何普通元素一样用 <code>v-for</code> 。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span> <span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure></p><blockquote><p>2.2.0+ 的版本里，当在组件中使用 <code>v-for</code> 时，<code>key</code> 是必须的。</p></blockquote><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>任何数据都不会被自动传递到组件里，因为组件有自己独立的作用域。</p><p><strong>原因：</strong><br>不自动将 数据 注入到组件里的原因是，这会使得组件与 <code>v-for</code> 的运作紧密耦合。明确组件数据的来源能够使组件在其他场合重复使用。</p><p><strong>解决方案：</strong><br>用 <code>props</code> 把迭代数据传递到组件里。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-for</span>=<span class="string">"(item, index) in items"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:item</span>=<span class="string">"item"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:index</span>=<span class="string">"index"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:key</span>=<span class="string">"item.id"</span></span></span><br><span class="line"><span class="tag">&gt;</span> <span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>下面是一个简单的 todo list 的<a href="https://codepen.io/Wonder233/pen/WzJNob" target="_blank" rel="noopener">完整例子</a>：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"todo-list-example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-model</span>=<span class="string">"newTodoText"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-on:keyup.enter</span>=<span class="string">"addNewTodo"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">placeholder</span>=<span class="string">"Add a todo"</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">      <span class="attr">is</span>=<span class="string">"todo-item"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-for</span>=<span class="string">"(todo, index) in todos"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-bind:key</span>=<span class="string">"todo.id"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-bind:title</span>=<span class="string">"todo.title"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-on:remove</span>=<span class="string">"todos.splice(index, 1)"</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><blockquote><p>注意这里的 <code>is=&quot;todo-item&quot;</code> 属性。这种做法在使用 DOM 模板时是十分必要的。<br><strong>原因：</strong><br>在 <code>&lt;ul&gt;</code> 元素内只有 <code>&lt;li&gt;</code> 元素会被看作有效内容。这样做实现的效果与 <code>&lt;todo-item&gt;</code> 相同，但是可以避开一些潜在的浏览器解析错误。<br>查看 <a href="https://cn.vuejs.org/v2/guide/components.html#DOM-%E6%A8%A1%E6%9D%BF%E8%A7%A3%E6%9E%90%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" target="_blank" rel="noopener">DOM 模板解析说明</a> 来了解更多信息。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'todo-item'</span>, &#123;</span><br><span class="line">  template: <span class="string">'\</span></span><br><span class="line"><span class="string">    &lt;li&gt;\</span></span><br><span class="line"><span class="string">      &#123;&#123; title &#125;&#125;\</span></span><br><span class="line"><span class="string">      &lt;button v-on:click="$emit(\'remove\')"&gt;X&lt;/button&gt;\</span></span><br><span class="line"><span class="string">    &lt;/li&gt;\</span></span><br><span class="line"><span class="string">  '</span>,</span><br><span class="line">  props: [<span class="string">'title'</span>]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#todo-list-example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    newTodoText: <span class="string">''</span>,</span><br><span class="line">    todos: [</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">1</span>,</span><br><span class="line">        title: <span class="string">'Do the dishes'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">2</span>,</span><br><span class="line">        title: <span class="string">'Take out the trash'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">3</span>,</span><br><span class="line">        title: <span class="string">'Mow the lawn'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    nextTodoId: <span class="number">4</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    addNewTodo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.todos.push(&#123;</span><br><span class="line">        id: <span class="keyword">this</span>.nextTodoId++,</span><br><span class="line">        title: <span class="keyword">this</span>.newTodoText</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">this</span>.newTodoText = <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Vue学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>条件渲染</title>
      <link href="/2018/03/31/Vue%E5%AD%A6%E4%B9%A0/%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/"/>
      <url>/2018/03/31/Vue%E5%AD%A6%E4%B9%A0/%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93/</url>
      <content type="html"><![CDATA[<h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">"ok"</span>&gt;</span>Yes<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以用 <code>v-else</code> 添加一个“else 块”：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">"ok"</span>&gt;</span>Yes<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else</span>&gt;</span>No<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="在-lt-template-gt-元素上使用-v-if-条件渲染分组"><a href="#在-lt-template-gt-元素上使用-v-if-条件渲染分组" class="headerlink" title="在 &lt; template &gt; 元素上使用 v-if 条件渲染分组"></a>在 &lt; template &gt; 元素上使用 <code>v-if</code> 条件渲染分组</h3><blockquote><p><code>v-if</code> 是一个指令，必须将它添加到一个元素上。</p></blockquote><p>可以把一个 <code>&lt;template&gt;</code> 元素当做不可见的包裹元素，并在上面使用 <code>v-if</code>。最终的渲染结果将不包含 <code>&lt;template&gt;</code> 元素。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"ok"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a>v-else</h3><p>使用 <code>v-else</code> 指令来表示 <code>v-if</code> 的“else 块”：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"Math.random() &gt; 0.5"</span>&gt;</span></span><br><span class="line">  Now you see me</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  Now you don't</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><blockquote><p><code>v-else</code> 元素必须紧跟在带 <code>v-if</code> 或者 <code>v-else-if</code> 的元素的后面，否则它将不会被识别。</p></blockquote><h3 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a>v-else-if</h3><blockquote><p>2.1.0 新增</p></blockquote><p><code>v-else-if</code>，充当 <code>v-if</code> 的“else-if 块”，可以连续使用：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"type === 'A'"</span>&gt;</span></span><br><span class="line">  A</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">"type === 'B'"</span>&gt;</span></span><br><span class="line">  B</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">"type === 'C'"</span>&gt;</span></span><br><span class="line">  C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  Not A/B/C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><blockquote><p><code>v-else-if</code> 必须紧跟在带 <code>v-if</code> 或者 <code>v-else-if</code> 的元素之后。</p></blockquote><h3 id="用-key-管理可复用的元素"><a href="#用-key-管理可复用的元素" class="headerlink" title="用 key 管理可复用的元素"></a>用 <code>key</code> 管理可复用的元素</h3><p>Vue 会尽可能高效地渲染元素，通常会<strong>复用已有元素</strong>而不是从头开始渲染。</p><p>例如，如果你允许用户在不同的登录方式之间切换：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"loginType === 'username'"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your username"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your email address"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>那么在上面的代码中切换 <code>loginType</code> 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，<code>&lt;input&gt;</code> 不会被替换掉——仅仅是替换了它的 <code>placeholder</code>。</p><p>如果不想有这种复用的效果，只需添加一个具有唯一值的 <code>key</code> 属性即可：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"loginType === 'username'"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your username"</span> <span class="attr">key</span>=<span class="string">"username-input"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your email address"</span> <span class="attr">key</span>=<span class="string">"email-input"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>现在，每次切换时，输入框都将被重新渲染。</p><blockquote><p>注意，<code>&lt;label&gt;</code> 元素仍然会被高效地复用，因为它们没有添加 <code>key</code> 属性。</p></blockquote><h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">"ok"</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>带有 <code>v-show</code> 的元素<strong>始终会被渲染并保留在 DOM</strong> 中。<code>v-show</code> 只是简单地切换元素的 CSS 属性 <code>display</code>。</p><blockquote><p>注意，<code>v-show</code> 不支持 <code>&lt;template&gt;</code> 元素，也不支持 <code>v-else</code>。</p></blockquote><h2 id="v-if-vs-v-show"><a href="#v-if-vs-v-show" class="headerlink" title="v-if vs v-show"></a><code>v-if</code> vs <code>v-show</code></h2><p><code>v-if</code> ：</p><ul><li>是“真正”的条件渲染：它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</li><li>“惰性的”：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</li></ul><p><code>v-show</code> ：不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p><blockquote><p>v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。<br>因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。</p></blockquote><h2 id="v-if-与-v-for-一起使用"><a href="#v-if-与-v-for-一起使用" class="headerlink" title="v-if 与 v-for 一起使用"></a><code>v-if</code> 与 <code>v-for</code> 一起使用</h2><p>当 <code>v-if</code> 与 <code>v-for</code> 一起使用时，<code>v-for</code> 具有比 <code>v-if</code> 更高的优先级。</p>]]></content>
      
      <categories>
          
          <category> Vue学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Class与Style绑定</title>
      <link href="/2018/03/31/Vue%E5%AD%A6%E4%B9%A0/Class%E4%B8%8EStyle%E7%BB%91%E5%AE%9A/"/>
      <url>/2018/03/31/Vue%E5%AD%A6%E4%B9%A0/Class%E4%B8%8EStyle%E7%BB%91%E5%AE%9A/</url>
      <content type="html"><![CDATA[<h2 id="绑定-HTML-Class"><a href="#绑定-HTML-Class" class="headerlink" title="绑定 HTML Class"></a>绑定 HTML Class</h2><h3 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h3><p>（1）<strong>内联</strong>传给 <code>v-bind:class</code>一个对象，以动态地切换 <code>class</code>：<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"</span></span></span><span class="template-variable">&#123; active: isActive &#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!-- active 这个 class 存在与否取决于变量 isActive 为 truthy(真值) --&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"static"</span> <span class="attr">v-bind:class</span>=<span class="string">"</span></span></span><span class="template-variable">&#123; active: isActive, 'text-danger': hasError &#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">data:</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">  isActive:</span> <span class="literal">false</span><span class="string">,</span></span><br><span class="line"><span class="attr">  hasError:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>结果渲染为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"static text-danger"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>（2）给 <code>v-bind:class</code>绑定一个<strong>数据对象</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"classObject"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">data:</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">  classObject:</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    active:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">    'text-danger':</span> <span class="literal">false</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>（3）给 <code>v-bind:class</code>绑定一个<strong>返回对象的计算属性</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"classObject"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span>: &#123;</span><br><span class="line">  isActive: <span class="literal">true</span>,</span><br><span class="line">  error: <span class="literal">null</span></span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  classObject: function () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      active: <span class="keyword">this</span>.isActive &amp;&amp; !<span class="keyword">this</span>.error,</span><br><span class="line">      <span class="string">'text-danger'</span>: <span class="keyword">this</span>.error &amp;&amp; <span class="keyword">this</span>.error.type === <span class="string">'fatal'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a>数组语法</h3><p>（1）把一个数组传给 <code>v-bind:class</code>，以应用一个 <code>class</code> 列表：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"[activeClass, errorClass]"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">data</span>: &#123;</span><br><span class="line">  <span class="attribute">activeClass</span>: <span class="string">'active'</span>,</span><br><span class="line">  errorClass: <span class="string">'text-danger'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"active text-danger"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>（2）用<strong>三元表达式</strong>根据条件切换列表中的 <code>class</code>：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[isActive ? activeClass : '', errorClass]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 将始终添加 errorClass，只有在 isActive 为 truthy(真值) 时才添加 activeClass。 --&gt;</span></span><br></pre></td></tr></table></figure></p><p>（3）在数组语法中使用对象语法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"[&#123; active: isActive &#125;, errorClass]"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><h3 id="用在组件上"><a href="#用在组件上" class="headerlink" title="用在组件上"></a>用在组件上</h3><p>当在一个自定义组件上使用 <code>class</code> 属性时：</p><ol><li>这些类将被添加到该组件的根元素上面。</li><li>这个元素上已经存在的类不会被覆盖。</li></ol><p>例如，如果你声明了这个组件：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Vue</span>.component(<span class="symbol">'my</span>-component', &#123;</span><br><span class="line">  template: '&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"foo bar"</span>&gt;<span class="type">Hi</span>&lt;/p&gt;'</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>然后在使用它的时候添加一些 <code>class</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component <span class="class"><span class="keyword">class</span></span>=<span class="string">"baz boo"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>HTML 将被渲染为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"foo bar baz boo"</span>&gt;Hi&lt;<span class="regexp">/p&gt;</span></span><br></pre></td></tr></table></figure></p><p>对于带数据绑定 class 也同样适用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-component v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"&#123; active: isActive &#125;"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>当 <code>isActive</code> 为 <code>true</code> 时，HTML 将被渲染成为：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"foo bar active"</span>&gt;Hi&lt;<span class="regexp">/p&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="绑定内联样式"><a href="#绑定内联样式" class="headerlink" title="绑定内联样式"></a>绑定内联样式</h2><h3 id="对象语法-1"><a href="#对象语法-1" class="headerlink" title="对象语法"></a>对象语法</h3><p>（1）<strong>内联</strong>传给 <code>v-bind:style</code>一个 JavaScript 对象，以动态地切换 <code>style</code>：</p><p>CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用单引号括起来) 来命名：<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"</span></span></span><span class="template-variable">&#123; color: activeColor, fontSize: fontSize + 'px' &#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">data</span>: &#123;</span><br><span class="line">  <span class="attribute">activeColor</span>: <span class="string">'red'</span>,</span><br><span class="line">  fontSize: <span class="number">30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）给 <code>v-bind:style</code>绑定一个<strong>样式对象</strong>：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> v-<span class="keyword">bind</span>:style=<span class="string">"styleObject"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">data</span>: &#123;</span><br><span class="line">  <span class="attribute">styleObject</span>: &#123;</span><br><span class="line">    color: <span class="string">'red'</span>,</span><br><span class="line">    fontSize: <span class="string">'13px'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）给 <code>v-bind:class</code> 绑定一个<strong>返回对象的计算属性</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">"classObject"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span>: &#123;</span><br><span class="line">  color: <span class="string">'red'</span>,</span><br><span class="line">  size1: <span class="number">8</span>,</span><br><span class="line">  size2: <span class="number">5</span></span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  classObject: function () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      color: <span class="keyword">this</span>.color,</span><br><span class="line">      fontSize: <span class="keyword">this</span>.size1 + <span class="keyword">this</span>.size2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组语法-1"><a href="#数组语法-1" class="headerlink" title="数组语法"></a>数组语法</h3><p>将多个样式对象应用到同一个元素上：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> v-<span class="keyword">bind</span>:style=<span class="string">"[baseStyles, overridingStyles]"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">data</span>: &#123;</span><br><span class="line">  <span class="attribute">baseStyles</span>: &#123;</span><br><span class="line">  background: <span class="string">'red'</span>,</span><br><span class="line">      border:<span class="string">'1px solid'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="selector-tag">overridingStyles</span>: &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="string">'100px'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动添加前缀"><a href="#自动添加前缀" class="headerlink" title="自动添加前缀"></a>自动添加前缀</h3><p>当 <code>v-bind:style</code> 使用需要添加<strong>浏览器引擎前缀</strong>的 CSS 属性时，如 <code>transform</code>，Vue.js 会自动侦测并添加相应的前缀。</p><h3 id="多重值"><a href="#多重值" class="headerlink" title="多重值"></a>多重值</h3><blockquote><p>2.3.0+</p></blockquote><p>从 2.3.0 起你可以为 style 绑定中的属性提供一个包含多个值的数组，常用于提供多个带前缀的值，例如：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="symbol">:style=<span class="string">"&#123; display: ['-webkit-box', '-ms-flexbox', 'flex'] &#125;"</span>&gt;&lt;/div&gt;</span></span><br></pre></td></tr></table></figure></p><p>这样写只会渲染数组中最后一个被浏览器支持的值。在本例中，如果浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 display: flex。</p><p>[1] truthy 不是 true，详见 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy" target="_blank" rel="noopener">MDN</a> 的解释。</p>]]></content>
      
      <categories>
          
          <category> Vue学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>模板语法</title>
      <link href="/2018/03/30/Vue%E5%AD%A6%E4%B9%A0/%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/"/>
      <url>/2018/03/30/Vue%E5%AD%A6%E4%B9%A0/%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>Vue.js 使用了<strong>基于 HTML 的模板语法</strong>，允许开发者声明式地<strong>将 DOM 绑定至底层 Vue 实例的数据</strong>。所有 Vue.js 的模板都是合法的 HTML ，所以能被遵循规范的浏览器和 HTML 解析器解析。</p><hr><p>在底层的实现上，Vue 将模板编译成<strong>虚拟 DOM 渲染函数</strong>。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。</p><h2 id="插值——数据绑定"><a href="#插值——数据绑定" class="headerlink" title="插值——数据绑定"></a>插值——数据绑定</h2><h3 id="文本-——双大括号-123-123-125-125"><a href="#文本-——双大括号-123-123-125-125" class="headerlink" title="文本 ——双大括号&#123;&#123;&#125;&#125;"></a>文本 ——双大括号&#123;&#123;&#125;&#125;</h3><ol><li>数据绑定最常见的形式就是使用<strong>“Mustache”语法 (双大括号)</strong> 的文本插值：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Message: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>Mustache 标签将会被替代为对应数据对象上 msg 属性的值。无论何时，绑定的数据对象上 msg 属性发生了改变，插值处的内容都会更新。</p><ol start="2"><li>通过使用 <strong>v-once</strong> 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-once</span>&gt;</span>这个将不会改变: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="原始-HTML——v-html"><a href="#原始-HTML——v-html" class="headerlink" title="原始 HTML——v-html"></a>原始 HTML——v-html</h3><p>双大括号会将数据解释为普通文本，而非 HTML 代码。<br>为了输出真正的 HTML，你需要使用 v-html 指令：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using mustaches: &#123;&#123; rawHtml &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using v-html directive: <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">"rawHtml"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><img src="/2018/03/30/Vue学习/模板语法/./1.png" alt="Alt text"><br>这个 span 的内容将会被替换成为属性值 rawHtml，直接作为 HTML——<strong>会忽略解析属性值中的数据绑定</strong>。</p><blockquote><p>不能使用 v-html 来复合局部模板，因为 Vue 不是基于字符串的模板引擎。</p></blockquote><h3 id="绑定-HTML-属性——v-bind"><a href="#绑定-HTML-属性——v-bind" class="headerlink" title="绑定 HTML 属性——v-bind"></a>绑定 HTML 属性——v-bind</h3><p>双大括号语法&#123;&#123;&#125;&#125;不能作用在 HTML 特性上，此时应该使用 v-bind 指令：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">"dynamicId"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><blockquote><p>注意：上面的 dynamicId 是一个变量。</p></blockquote><p>在布尔特性的情况下，它们的存在即暗示为 true，v-bind 工作起来略有不同：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-bind:disabled</span>=<span class="string">"isButtonDisabled"</span>&gt;</span>Button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>如果 isButtonDisabled 的值是 null、undefined 或 false，则 disabled 特性甚至不会被包含在渲染出来的 &lt; button &gt; 元素中。</p><h3 id="使用-JavaScript-表达式"><a href="#使用-JavaScript-表达式" class="headerlink" title="使用 JavaScript 表达式"></a>使用 JavaScript 表达式</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; number + 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; ok ? 'YES' : 'NO' &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; message.split('').reverse().join('') &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">"'list-' + id"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。</p><p><strong>限制：</strong><br>每个绑定都只能包含<strong>单个表达式</strong>。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 以下例子都将不会生效 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 这是语句，不是表达式 --&gt;</span></span><br><span class="line">&#123;&#123; var a = 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;</span></span><br><span class="line">&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;</span><br></pre></td></tr></table></figure></p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><ol><li>指令 (Directives) 是带有 v- 前缀的特殊属性。</li><li>指令属性的值预期是单个 JavaScript 表达式（v-for 是例外情况）。</li><li>指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。</li></ol><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>一些指令能够接收一个“参数”，在指令名称之后以冒号表示。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- v-bind 指令可以用于响应式地更新 HTML 属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- v-on 指令用于监听 DOM 事件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">"doSomething"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>修饰符 (Modifiers) 是以<strong>半角句号 .</strong> 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- .prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault() --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"onSubmit"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h2><p>Vue.js 为 v-bind 和 v-on 这两个最常用的指令，提供了特定简写：</p><h3 id="v-bind-缩写"><a href="#v-bind-缩写" class="headerlink" title="v-bind 缩写"></a>v-bind 缩写</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-on-缩写"><a href="#v-on-缩写" class="headerlink" title="v-on 缩写"></a>v-on 缩写</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">"doSomething"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">"doSomething"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Vue学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算属性和侦听器</title>
      <link href="/2018/03/30/Vue%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%99%A8/"/>
      <url>/2018/03/30/Vue%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%99%A8/</url>
      <content type="html"><![CDATA[<h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>对于任何复杂逻辑，应当使用计算属性。</p><h3 id="基础例子"><a href="#基础例子" class="headerlink" title="基础例子"></a>基础例子</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Original message: "&#123;&#123; message &#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Computed reversed message: "&#123;&#123; reversedMessage &#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">'Hello'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 计算属性的 getter</span></span><br><span class="line">    reversedMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>结果：</strong><br>Original message: “Hello”<br>Computed reversed message: “olleH”</p><p>这里声明了一个计算属性 reversedMessage。提供的函数将用作属性 vm.reversedMessage 的 getter 函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(vm.reversedMessage) <span class="comment">// =&gt; 'olleH'</span></span><br><span class="line">vm.message = <span class="string">'Goodbye'</span></span><br><span class="line"><span class="built_in">console</span>.log(vm.reversedMessage) <span class="comment">// =&gt; 'eybdooG'</span></span><br></pre></td></tr></table></figure></p><p>Vue 知道 vm.reversedMessage 依赖于 vm.message，因此当 vm.message 发生改变时，所有依赖 vm.reversedMessage 的绑定也会更新。</p><blockquote><p>可以像绑定普通属性一样在模板中绑定计算属性。</p></blockquote><h3 id="计算属性缓存-vs-方法"><a href="#计算属性缓存-vs-方法" class="headerlink" title="计算属性缓存 vs 方法"></a>计算属性缓存 vs 方法</h3><p>上面的例子可以通过在表达式中调用方法来达到同样的效果：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Reversed message: "&#123;&#123; reversedMessage() &#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在组件中</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  reversedMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>相同点：</strong><br>可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。<br><strong>不同点：</strong><br>计算属性是<strong>基于它们的依赖进行缓存的</strong>。计算属性只有在它的相关依赖发生改变时才会重新求值。</p><ul><li>这意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。</li><li>而每当触发重新渲染时，调用方法将总会再次执行函数。</li></ul><h3 id="计算属性-vs-侦听属性"><a href="#计算属性-vs-侦听属性" class="headerlink" title="计算属性 vs 侦听属性"></a>计算属性 vs 侦听属性</h3><p>Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：<strong>侦听属性。</strong></p><p>当你有一些数据需要随着其它数据变动而变动时，通常更好的做法是使用计算属性而不是命令式的 watch 回调。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span>&#123;&#123; fullName &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#demo'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Foo'</span>,</span><br><span class="line">    lastName: <span class="string">'Bar'</span>,</span><br><span class="line">    fullName: <span class="string">'Foo Bar'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    firstName: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.fullName = val + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    lastName: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.fullName = <span class="keyword">this</span>.firstName + <span class="string">' '</span> + val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码是命令式且重复的。将它与计算属性的版本进行比较：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#demo'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Foo'</span>,</span><br><span class="line">    lastName: <span class="string">'Bar'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    fullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="计算属性的-setter"><a href="#计算属性的-setter" class="headerlink" title="计算属性的 setter"></a>计算属性的 setter</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> names = newValue.split(<span class="string">' '</span>)</span><br><span class="line">      <span class="keyword">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>运行 vm.fullName = ‘John Doe’ 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。</p><h2 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h2><p>当需要在数据变化时执行<strong>异步或开销较大的操作</strong>时，Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"watch-example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    Ask a yes/no question:</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"question"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; answer &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> watchExampleVM = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">  el: <span class="string">'#watch-example'</span>,</span></span><br><span class="line"><span class="undefined">  data: &#123;</span></span><br><span class="line"><span class="actionscript">    question: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">    answer: <span class="string">'I cannot give you an answer until you ask a question!'</span></span></span><br><span class="line"><span class="undefined">  &#125;,</span></span><br><span class="line"><span class="undefined">  watch: &#123;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 如果 `question` 发生改变，这个函数就会运行</span></span></span><br><span class="line"><span class="actionscript">    question: <span class="function"><span class="keyword">function</span> <span class="params">(newQuestion, oldQuestion)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.answer = <span class="string">'Waiting for you to stop typing...'</span></span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.getAnswer()</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;,</span></span><br><span class="line"><span class="undefined">  methods: &#123;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// `_.debounce` 是一个通过 Lodash 限制操作频率的函数。</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// AJAX 请求直到用户输入完毕才会发出。想要了解更多关于</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 请参考：https://lodash.com/docs#debounce</span></span></span><br><span class="line"><span class="undefined">    getAnswer: _.debounce(</span></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">if</span> (<span class="keyword">this</span>.question.indexOf(<span class="string">'?'</span>) === <span class="number">-1</span>) &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.answer = <span class="string">'Questions usually contain a question mark. ;-)'</span></span></span><br><span class="line"><span class="actionscript">          <span class="keyword">return</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.answer = <span class="string">'Thinking...'</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> vm = <span class="keyword">this</span></span></span><br><span class="line"><span class="actionscript">        axios.get(<span class="string">'https://yesno.wtf/api'</span>)</span></span><br><span class="line"><span class="actionscript">          .then(<span class="function"><span class="keyword">function</span> <span class="params">(response)</span> </span>&#123;</span></span><br><span class="line"><span class="undefined">            vm.answer = _.capitalize(response.data.answer)</span></span><br><span class="line"><span class="undefined">          &#125;)</span></span><br><span class="line"><span class="actionscript">          .catch(<span class="function"><span class="keyword">function</span> <span class="params">(error)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            vm.answer = <span class="string">'Error! Could not reach the API. '</span> + error</span></span><br><span class="line"><span class="undefined">          &#125;)</span></span><br><span class="line"><span class="undefined">      &#125;,</span></span><br><span class="line"><span class="actionscript">      <span class="comment">// 这是我们为判定用户停止输入等待的毫秒数</span></span></span><br><span class="line"><span class="undefined">      500</span></span><br><span class="line"><span class="undefined">    )</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>结果：</strong><br><img src="/2018/03/30/Vue学习/计算属性和侦听器/./1.png" alt="Alt text"></p><p>使用 watch 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p><p>除了 watch 选项之外，还可以使用命令式的 <a href="https://cn.vuejs.org/v2/api/#vm-watch" target="_blank" rel="noopener">vm.$watch API</a>。</p>]]></content>
      
      <categories>
          
          <category> Vue学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTTPS 介绍</title>
      <link href="/2018/03/30/HTTP/HTTPS-%E4%BB%8B%E7%BB%8D/"/>
      <url>/2018/03/30/HTTP/HTTPS-%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h2 id="HTTPS-概述"><a href="#HTTPS-概述" class="headerlink" title="HTTPS 概述"></a>HTTPS 概述</h2><p>HTTPS 由两部分组成：HTTP + SSL / TLS，即在 HTTP 上又加了一层处理加密信息的模块。<br>服务端和客户端的信息传输都会通过 TLS 进行加密，所以传输的数据都是加密后的数据。</p><p><img src="/2018/03/30/HTTP/HTTPS-介绍/./1.png" alt="HTTP 与 HTTPS 对比"><br>HTTP 安全层通过 SSL 及其现代替代协议 TLS 实现的。</p><h2 id="HTTPS-原理"><a href="#HTTPS-原理" class="headerlink" title="HTTPS 原理"></a>HTTPS 原理</h2><h3 id="1-客户端发起HTTPS请求"><a href="#1-客户端发起HTTPS请求" class="headerlink" title="1. 客户端发起HTTPS请求"></a>1. 客户端发起HTTPS请求</h3><p>客户端首先建立一条到 Web 服务器端口 443 的连接。（进行TCP 三次握手）</p><h3 id="2-服务端的配置"><a href="#2-服务端的配置" class="headerlink" title="2. 服务端的配置"></a>2. 服务端的配置</h3><p>采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。<br><strong>区别：</strong></p><ul><li>自己颁发的证书需要客户端验证通过，才可以继续访问，</li><li>使用受信任的公司申请的证书则不会弹出提示页面。</li></ul><blockquote><p>这套证书其实是一对公钥和私钥。<br><strong>理解：</strong><br>可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</p></blockquote><h3 id="3-传送证书"><a href="#3-传送证书" class="headerlink" title="3. 传送证书"></a>3. 传送证书</h3><p>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。</p><h3 id="4-客户端解析证书"><a href="#4-客户端解析证书" class="headerlink" title="4. 客户端解析证书"></a>4. 客户端解析证书</h3><p>由客户端的 TLS 来完成：</p><ul><li>首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。</li><li>如果证书没有问题，那么就生成一个随即值。然后用证书对该随机值进行加密。</li></ul><h3 id="5-传送加密信息"><a href="#5-传送加密信息" class="headerlink" title="5. 传送加密信息"></a>5. 传送加密信息</h3><p>客户端传输用证书加密后的随机值。<br><strong>目的：</strong></p><ul><li>让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</li></ul><h3 id="6-服务端解密信息"><a href="#6-服务端解密信息" class="headerlink" title="6. 服务端解密信息"></a>6. 服务端解密信息</h3><p>服务端用私钥解密后，得到了客户端传过来的随机值（私钥），然后把内容通过该值进行对称加密。</p><blockquote><p><strong>对称加密：</strong><br>将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</p></blockquote><h3 id="7-传输加密后的信息"><a href="#7-传输加密后的信息" class="headerlink" title="7. 传输加密后的信息"></a>7. 传输加密后的信息</h3><p>服务端传输用私钥加密后的信息，可以在客户端被还原。</p><h3 id="8-客户端解密信息"><a href="#8-客户端解密信息" class="headerlink" title="8. 客户端解密信息"></a>8. 客户端解密信息</h3><p>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。</p><h2 id="HTTPS的优点"><a href="#HTTPS的优点" class="headerlink" title="HTTPS的优点"></a>HTTPS的优点</h2><h3 id="1-SEO方面"><a href="#1-SEO方面" class="headerlink" title="1.SEO方面"></a>1.SEO方面</h3><p>谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</p><h3 id="2-安全性"><a href="#2-安全性" class="headerlink" title="2.安全性"></a>2.安全性</h3><p>尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处：</p><ol><li><p>使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</p></li><li><p>HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</p></li><li><p>HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p></li></ol><h2 id="HTTPS的缺点"><a href="#HTTPS的缺点" class="headerlink" title="HTTPS的缺点"></a>HTTPS的缺点</h2><h3 id="1-SEO方面-1"><a href="#1-SEO方面-1" class="headerlink" title="1.SEO方面"></a>1.SEO方面</h3><ol><li><p>加载时间延长，耗电增加</p><blockquote><p>据ACM CoNEXT数据显示，使用 HTTPS 协议会使页面的加载时间延长近 50%，增加 10% 到 20% 的耗电。</p></blockquote></li><li><p>影响缓存，增加数据开销和功耗。</p></li><li><p>加密范围也比较有限</p><blockquote><p>在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。</p></blockquote></li><li><p>SSL证书的信用链体系并不安全。</p><blockquote><p>特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</p></blockquote></li></ol><h3 id="2-经济方面"><a href="#2-经济方面" class="headerlink" title="2.经济方面"></a>2.经济方面</h3><ol><li><p>SSL 证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</p></li><li><p>SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗（SSL 有扩展可以部分解决这个问题，但是比较麻烦，而且要求浏览器、操作系统支持，Windows XP 就不支持这个扩展，考虑到 XP 的装机量，这个特性几乎没用）。</p></li><li><p>HTTPS 连接缓存不如 HTTP 高效，大流量网站如非必要也不会采用，流量成本太高。</p></li><li><p>HTTPS 连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本，如果全部采用 HTTPS，基于大部分计算资源闲置的假设的 VPS 的平均成本会上去。</p></li><li><p>HTTPS 协议握手阶段比较费时，对网站的相应速度有负面影响，如非必要，没有理由牺牲用户体验。</p></li></ol><h2 id="HTTPS和HTTP的区别"><a href="#HTTPS和HTTP的区别" class="headerlink" title="HTTPS和HTTP的区别"></a>HTTPS和HTTP的区别</h2><ol><li>HTTPS 协议需要申请证书，一般免费证书较少，因而需要一定费用。</li><li>HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。</li><li>HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>HTTP 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</li></ol>]]></content>
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>块级绑定</title>
      <link href="/2018/03/30/LearnES6/%E5%9D%97%E7%BA%A7%E7%BB%91%E5%AE%9A/"/>
      <url>/2018/03/30/LearnES6/%E5%9D%97%E7%BA%A7%E7%BB%91%E5%AE%9A/</url>
      <content type="html"><![CDATA[<h2 id="var-声明与变量提升"><a href="#var-声明与变量提升" class="headerlink" title="var 声明与变量提升"></a>var 声明与变量提升</h2><p><strong>变量提升（ hoisting ）：</strong>使用 var 关键字声明的变量，无论其实际声明位置在何处，都会被视为声明于所在函数的顶部（如果声明不在任意函数内，则视为在全局作用域的顶部）。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">condition</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="string">'blue'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// value 在此处可访问，值为 undefined</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// value 在此处可访问，值为 undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>JS 引擎会将 getValue 函数调整为如下形式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">condition</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    value = <span class="string">'blue'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="块级声明"><a href="#块级声明" class="headerlink" title="块级声明"></a>块级声明</h2><p><strong>块级声明</strong>：让所声明的变量在指定块的作用域外无法被访问。</p><p>块级作用域（又被称为词法作用域）在如下情况被创建：</p><ol><li>在一个函数内部</li><li>在一个由一对花括号包裹的代码块内部</li></ol><h3 id="let-声明"><a href="#let-声明" class="headerlink" title="let 声明"></a>let 声明</h3><p>大体上可以直接用 let 代替 var 进行变量声明，但会将变量的作用域限制在当前代码块中。</p><blockquote><p>由于 let 声明并不会被提升，因此若想让变量在整个代码块内部可用，需要手动将 let 声明放置到代码块顶部。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">condition</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="string">'blue'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// value 在此处不可用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// value 在此处不可用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>在 condition 的值为 false 时，该变量永远不会被声明并初始化。</p><h4 id="禁止重复声明"><a href="#禁止重复声明" class="headerlink" title="禁止重复声明"></a>禁止重复声明</h4><p>如果一个标识符已经在代码块内部被定义，那么在此代码块内使用同一个标识符进行 let 声明就会导致错误。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法错误</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">40</span>;</span><br></pre></td></tr></table></figure></p><p>在嵌套的作用域内使用 let 声明一个同名新变量，就不会有问题。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不会抛出错误</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>原因：</strong><br>不是在同一作用域级别再次创建 count 变量，而是在 if 语句内部创建新变量。在 if 代码块内部，这个新变量会屏蔽全局的 count 变量，从而在局部阻止对于后者的访问。</p><h3 id="常量声明"><a href="#常量声明" class="headerlink" title="常量声明"></a>常量声明</h3><p>使用 const 声明的变量会被认为是常量（ constant ），值在被设置完成后就不允许再被更改。</p><blockquote><p>所有的 const 变量都需要在声明时进行初始化。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有效的常量</span></span><br><span class="line"><span class="keyword">const</span> maxItems = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法错误：未进行初始化</span></span><br><span class="line"><span class="keyword">const</span> name;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="常量声明与-let-声明对比"><a href="#常量声明与-let-声明对比" class="headerlink" title="常量声明与 let 声明对比"></a>常量声明与 let 声明对比</h4><p><strong>相似点：</strong></p><ol><li><p>常量声明与 let 声明一样，都是块级声明。常量在声明它们的语句块之外是无法被访问的，并且声明也不会被提升。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  <span class="keyword">const</span> maxItems = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其他代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// maxItems 在此处无法访问</span></span><br></pre></td></tr></table></figure></li><li><p>在同一作用域内定义一个已有变量时会抛出错误，无论是在全局还是函数作用域，无论该变量此前是用 var 声明的，还是用 let 声明的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">"Hello!"</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二者均会抛出错误</span></span><br><span class="line"><span class="keyword">const</span> message = <span class="string">"Goodbye!"</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">30</span>;</span><br></pre></td></tr></table></figure></li></ol><p><strong>本质区别：</strong><br>试图对 const 声明的常量再次赋值会抛出错误，无论是否运行在严格模式下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxItems = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">maxItems = <span class="number">6</span>;      <span class="comment">// 抛出错误</span></span><br></pre></td></tr></table></figure></p><h4 id="使用-const-声明对象"><a href="#使用-const-声明对象" class="headerlink" title="使用 const 声明对象"></a>使用 const 声明对象</h4><p>const 声明会阻止对于<strong>变量绑定与变量自身值</strong>的修改，但不会阻止对<strong>变量成员</strong>的修改。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Nicholas"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工作正常</span></span><br><span class="line">person.name = <span class="string">"Greg"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line">person = &#123;</span><br><span class="line">  name: <span class="string">"Greg"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>使用 let 或 const 声明的变量，在达到声明位置之前都是无法访问的，试图访问会导致一个引用错误。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> value);  <span class="comment">// 引用错误</span></span><br><span class="line">  <span class="keyword">let</span> value = <span class="string">"blue"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>原因：</strong><br>因为 value 位于被 JS 社区称为<strong>暂时性死区（ temporal dead zone ， TDZ ）</strong>的区域内。</p><p>当 JS 引擎扫描接下来的代码块并发现变量声明时：</p><ul><li>在处理 var 时将声明提升到函数或全局作用域的顶部；</li><li>处理 let 或 const 时，则会将声明放入暂时性死区。</li></ul><p>任何在暂时性死区内访问变量的企图都会导致“运行时”错误（runtime error）。只有执行到变量的声明语句时，该变量才会从暂时性死区内被移除，才可以安全使用。</p><blockquote><p>可以在变量被定义的代码块之外对该变量使用 typeof。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> value); <span class="comment">// "undefined"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="string">'blue'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>typeof 运算符被用于 value 变量被定义的代码块外部，此时 value 并未在暂时性死区内。因为 value 变量绑定尚不存在，而 typeof 仅会单纯返回 “undefined” 。</p></blockquote><h2 id="循环中的块级绑定"><a href="#循环中的块级绑定" class="headerlink" title="循环中的块级绑定"></a>循环中的块级绑定</h2><h3 id="循环内的-var-声明"><a href="#循环内的-var-声明" class="headerlink" title="循环内的 var 声明"></a>循环内的 var 声明</h3><p>在 JS 中，由于 var 声明导致了变量提升，循环结束后 i 仍然可被访问，于是在循环内创建函数就会产生问题。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  func(); <span class="comment">// 输出数值 "10" 十次</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><strong>解决方案：</strong><br>在循环内使用立即调用函数表达式（IIFEs），以便在每次迭代中强制创建变量的一个新副本：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  funcs.push(</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;)(i)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  func(); <span class="comment">// 从 0 到 9 依次输出</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="循环内的-let-声明"><a href="#循环内的-let-声明" class="headerlink" title="循环内的 let 声明"></a>循环内的 let 声明</h3><p>使用 let 声明，在每次迭代中，都会创建一个新的同名变量并对其进行初始化。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  func(); <span class="comment">// 从 0 到 9 依次输出</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这种方式在 for-in 和 for-of 循环中同样适用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [],</span><br><span class="line">  object = &#123;</span><br><span class="line">    a: <span class="literal">true</span>,</span><br><span class="line">    b: <span class="literal">true</span>,</span><br><span class="line">    c: <span class="literal">true</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">  funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  func(); <span class="comment">// 依次输出 "a"、 "b"、 "c"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>let 声明在循环内部的行为是在规范中特别定义的，与不提升变量声明的特征没有必然联系。</p></blockquote><h3 id="循环内的常量声明"><a href="#循环内的常量声明" class="headerlink" title="循环内的常量声明"></a>循环内的常量声明</h3><p>ES6 规范没有明确禁止在循环中使用 const 声明，然而它会根据不同循环方式而有不同行为。</p><h4 id="常规-for-循环"><a href="#常规-for-循环" class="headerlink" title="常规 for 循环"></a>常规 for 循环</h4><p>可以在初始化时使用 const ，但循环会在试图改变该变量的值时抛出错误。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在一次迭代后抛出错误</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="for-in-或-for-of-循环"><a href="#for-in-或-for-of-循环" class="headerlink" title="for-in 或 for-of 循环"></a>for-in 或 for-of 循环</h4><p>const 变量在 for-in 或 for-of 循环中使用时，与 let 变量效果相同。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [],</span><br><span class="line">  object = &#123;</span><br><span class="line">    a: <span class="literal">true</span>,</span><br><span class="line">    b: <span class="literal">true</span>,</span><br><span class="line">    c: <span class="literal">true</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不会导致错误</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">  funcs.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  func(); <span class="comment">// 依次输出 "a"、 "b"、 "c"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><strong>原因：</strong><br>因为for-in 与 for-of 循环为每次迭代创建了一个新的变量绑定，而不是像 for 循环那样试图去修改已绑定的变量的值。</p><h2 id="全局块级绑定"><a href="#全局块级绑定" class="headerlink" title="全局块级绑定"></a>全局块级绑定</h2><h3 id="使用-var-声明"><a href="#使用-var-声明" class="headerlink" title="使用 var 声明"></a>使用 var 声明</h3><p>在全局作用域上使用 var 时，会创建一个新的全局变量，并成为全局对象（在浏览器中是 window ）的一个属性。</p><blockquote><p>使用 var 可能会无意中覆盖一个已有的全局属性。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：浏览器中才有 window 属性</span></span><br><span class="line"><span class="comment">// 在浏览器中</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.RegExp);     <span class="comment">//function RegExp()&#123;&#125;</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">RegExp</span> = <span class="string">"Hello!"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.RegExp);     <span class="comment">// "Hello!"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ncz = <span class="string">"Hi!"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.ncz);        <span class="comment">// "Hi!"</span></span><br></pre></td></tr></table></figure><h3 id="使用-let-或-const-声明"><a href="#使用-let-或-const-声明" class="headerlink" title="使用 let 或 const 声明"></a>使用 let 或 const 声明</h3><p>在全局作用域上使用 let 或 const 声明时，会创建新的绑定，但不会有任何属性被添加到全局对象上。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在浏览器中</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">RegExp</span> = <span class="string">"Hello!"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>);                    <span class="comment">// "Hello!"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.RegExp === <span class="built_in">RegExp</span>);  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ncz = <span class="string">"Hi!"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(ncz);                       <span class="comment">// "Hi!"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"ncz"</span> <span class="keyword">in</span> <span class="built_in">window</span>);           <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><blockquote><p>若想让代码能从全局对象中被访问，仍然需要使用 var 。这种做法常见于在浏览器中跨越帧或窗口去访问代码的场合。</p></blockquote>]]></content>
      
      <categories>
          
          <category> LearnES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用 ES5 实现一个简单的Promise</title>
      <link href="/2018/03/29/LearnES5/%E7%94%A8ES5-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Promise/"/>
      <url>/2018/03/29/LearnES5/%E7%94%A8ES5-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Promise/</url>
      <content type="html"><![CDATA[<h2 id="Promise使用"><a href="#Promise使用" class="headerlink" title="Promise使用"></a>Promise使用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'步骤一：执行'</span>);</span><br><span class="line">        resolve(<span class="string">'1'</span>);</span><br><span class="line">    &#125;,<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'步骤二：执行'</span>);</span><br><span class="line">        resolve(<span class="string">'2'</span>);</span><br><span class="line">    &#125;,<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(fn1).then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(fn2);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">33</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Promise-标准解读"><a href="#Promise-标准解读" class="headerlink" title="Promise 标准解读"></a>Promise 标准解读</h2><p><a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promises/A+标准：</a></p><ol><li>只有一个then方法，没有catch，race，all等方法，甚至没有构造函数。<ul><li>Promise 标准中仅指定了 Promise 对象的 then 方法的行为，其它一切我们常见的方法/函数都并没有指定，包括 catch，race，all 等常用方法，甚至也没有指定该如何构造出一个 Promise 对象，另外 then 也没有一般实现中（Q, $q等）所支持的第三个参数，一般称 onProgress。</li></ul></li><li><p>then 方法返回一个新的 Promise。</p><ul><li>Promise的then方法返回一个新的Promise，而不是返回this。<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">promise2</span> = promise1.<span class="keyword">then</span>(alert)</span><br><span class="line">promise2 != promise1 // <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>不同Promise的实现需要可以相互调用 (interoperable)。</p></li><li>Promise 的初始状态为 pending，它可以由此状态转换为 fulfilled（本文为了一致把此状态叫做 resolved）或者 rejected，一旦状态确定，就不可以再次转换为其它状态，状态确定的过程称为 settle。</li></ol><p>首先看一下原生 ES6 中Promise 的使用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise构造函数接收一个 executor（执行） 函数。</span></span><br><span class="line"><span class="comment">// executor函数执行完同步或异步操作后，调用它的两个参数resolve和reject</span></span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//如果操作成功，调用resolve并传入value</span></span><br><span class="line"><span class="comment">//如果操作失败，调用reject并传入reason</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="实现构造函数的框架："><a href="#实现构造函数的框架：" class="headerlink" title="实现构造函数的框架："></a>实现构造函数的框架：</h2><p>先实现构造函数的框架如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPromise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> self = <span class="keyword">this</span>；</span><br><span class="line">self.status = <span class="string">'pending'</span>； <span class="comment">// Promise当前的状态</span></span><br><span class="line">self.data = <span class="literal">undefined</span>；  <span class="comment">// Promise的值</span></span><br><span class="line"><span class="comment">// Promise resolve时的回调函数集，因为在Promise结束之前有可能有多个回调添加到它上面</span></span><br><span class="line">self.onResolvedCallback = []； </span><br><span class="line"><span class="comment">// Promise reject时的回调函数集，因为在Promise结束之前有可能有多个回调添加到它上面</span></span><br><span class="line">self.onRejectedCallback = []； </span><br><span class="line"></span><br><span class="line">executor(resolve, reject)； <span class="comment">// 执行executor并传入相应的参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码基本实现了Promise构造函数的主体，但目前还有两个问题：</p><ol><li>我们给executor函数传了两个参数：resolve 和 reject，这两个参数目前还没有定义。</li><li>executor 有可能会出错（throw），类似下面这样，而如果 executor 出错，Promise 应该被其 throw 出值 reject：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="number">2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>所以我们需要在构造函数里定义resolve和reject这两个函数：</p><h2 id="定义-resolve-和-reject-两个函数："><a href="#定义-resolve-和-reject-两个函数：" class="headerlink" title="定义 resolve 和 reject 两个函数："></a>定义 resolve 和 reject 两个函数：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPromise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">self.status = <span class="string">'pending'</span>; <span class="comment">// Promise当前的状态</span></span><br><span class="line">self.data = <span class="literal">undefined</span>;  <span class="comment">// Promise的值</span></span><br><span class="line">self.onResolvedCallback = []; <span class="comment">// Promise resolve时的回调函数集，因为在Promise结束之前有可能有多个回调添加到它上面</span></span><br><span class="line">self.onRejectedCallback = []; <span class="comment">// Promise reject时的回调函数集，因为在Promise结束之前有可能有多个回调添加到它上面</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 考虑到执行executor的过程中有可能出错，所以我们用try/catch块给包起来，并且在出错后以catch到的值reject掉这个Promise</span></span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">executor(resolve, reject); <span class="comment">// 执行executor</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">reject(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>resolve和reject这两个函数能不能不定义在构造函数里？</strong><br>考虑到我们在 executor 函数里是以 resolve(value)，reject(reason) 的形式调用的这两个函数，而不是以 resolve.call(promise, value)，reject.call(promise, reason) 这种形式调用的，所以这两个函数在调用时的内部也必然有一个隐含的 this ，也就是说，要么这两个函数是经过 bind 后传给了executor，要么它们定义在构造函数的内部，使用 self 来访问所属的Promise对象。<br>所以如果我们想把这两个函数定义在构造函数的外部，确实是可以这么写的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPromise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    executor(resolve.bind(<span class="keyword">this</span>), reject.bind(<span class="keyword">this</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    reject.bind(<span class="keyword">this</span>)(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>但是众所周知，bind 会返回一个新的函数，这么一来还是相当于每个 Promise 对象都有一对属于自己的 resolve 和 reject 函数，就跟写在构造函数内部没什么区别了，所以我们就直接把这两个函数定义在构造函数里面了。<br>另外，这里的实现并没有考虑隐藏 this 上的变量，这使得这个 Promise 的状态可以在 executor 函数外部被改变，在一个靠谱的实现里，构造出的 Promise 对象的状态和最终结果应当是无法从外部更改的。</p></blockquote><p>接下来，实现resolve和reject这两个函数。</p><h2 id="实现-resolve-和-reject："><a href="#实现-resolve-和-reject：" class="headerlink" title="实现 resolve 和 reject："></a>实现 resolve 和 reject：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPromise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">self.status = <span class="string">'resolved'</span>;</span><br><span class="line">self.data = value;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> self.onResolvedCallback)&#123;</span><br><span class="line">self.onResolvedCallback[i](value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">self.status = <span class="string">'rejected'</span>;</span><br><span class="line">self.data = reason;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> self.onRejectedCallback)&#123;</span><br><span class="line">self.onRejectedCallback[i](reason);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本上就是在判断状态为pending之后把状态改为相应的值，并把对应的value和reason存在self的data属性上面，之后执行相应的回调函数。</p><h2 id="实现then方法"><a href="#实现then方法" class="headerlink" title="实现then方法"></a>实现then方法</h2><h3 id="解析-then-方法"><a href="#解析-then-方法" class="headerlink" title="解析 then 方法"></a>解析 then 方法</h3><p>Promise 对象有一个 then 方法，用来注册在这个 Promise 状态确定后的回调，很明显，then 方法需要写在原型链上。<br>then 方法会返回一个 Promise，关于这一点，Promise/A+ 标准并没有要求返回的这个 Promise 是一个新的对象，但在 Promise/A 标准中，明确规定了 then 要返回一个新的对象，目前的 Promise 实现中 then 几乎都是返回一个新的 Promise (<a href="https://promisesaplus.com/differences-from-promises-a#point-5" target="_blank" rel="noopener">详情</a>) 对象，所以在我们的实现中，也让 then 返回一个新的 Promise 对象。</p><p>每个 Promise 对象都可以在其上多次调用 then 方法，而每次调用 then 返回的 Promise 的状态取决于那一次调用 then 时传入参数的返回值，所以 then 不能返回 this，因为 then 每次返回的 Promise 的结果都有可能不同。</p><h3 id="实现then方法-1"><a href="#实现then方法-1" class="headerlink" title="实现then方法"></a>实现then方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// then方法接收两个参数，onResolved，onRejected，分别为Promise成功或失败后的回调</span></span><br><span class="line">myPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> promise2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据标准，如果then的参数不是function，则我们需要忽略它，此处以如下方式处理：</span></span><br><span class="line">  <span class="comment">// 如果想要把then的实参留空且让值可以穿透到后面，</span></span><br><span class="line">  <span class="comment">// 意味着then的两个参数的默认值分别为function(value) &#123;return value&#125;，function(reason) &#123;throw reason&#125;。</span></span><br><span class="line">  onResolved =</span><br><span class="line">    <span class="keyword">typeof</span> onResolved === <span class="string">'function'</span></span><br><span class="line">      ? onResolved</span><br><span class="line">      : <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> value;</span><br><span class="line">        &#125;;</span><br><span class="line">  onRejected =</span><br><span class="line">    <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span></span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">'resolved'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (promise2 = <span class="keyword">new</span> myPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;&#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (promise2 = <span class="keyword">new</span> myPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;&#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (promise2 = <span class="keyword">new</span> myPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;&#125;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Promise总共有三种可能的状态，我们分三个 if 块来处理，在里面分别都返回一个 new Promise。</p><p>根据标准，我们知道，对于如下代码，promise2 的值取决于 then 里面函数的返回值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise2 = promise1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'sth went wrong'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果 promise1 被 resolve 了，promise2 的将被 4 resolve，如果 promise1 被 reject 了，promise2 将被 new Error(‘sth went wrong’) reject。</p><p>所以，我们需要在 then 里面执行 onResolved 或者 onRejected，并根据返回值(标准中记为 x )来确定 promise2 的结果，并且，如果 onResolved/onRejected 返回的是一个 Promise，promise2 将直接取这个 Promise 的结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// then方法接收两个参数，onResolved，onRejected，分别为Promise成功或失败后的回调</span></span><br><span class="line">myPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> promise2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据标准，如果then的参数不是function，则我们需要忽略它，此处以如下方式处理：</span></span><br><span class="line">  onResolved =</span><br><span class="line">    <span class="keyword">typeof</span> onResolved === <span class="string">'function'</span> ? onResolved : <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;&#125;;</span><br><span class="line">  onRejected =</span><br><span class="line">    <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="keyword">function</span>(<span class="params">reject</span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">'resolved'</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果promise1(此处即为this/self)的状态已经确定并且是resolved，我们调用onResolved</span></span><br><span class="line">    <span class="comment">// 因为考虑到有可能throw，所以我们将其包在try/catch块里</span></span><br><span class="line">    <span class="keyword">return</span> (promise2 = <span class="keyword">new</span> myPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> x = onResolved(self.data);</span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> myPromise) &#123;</span><br><span class="line">          <span class="comment">// 如果onResolved的返回值是一个Promise对象，直接取它的结果做为promise2的结果</span></span><br><span class="line">          x.then(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 否则，以它的返回值做为promise2的结果</span></span><br><span class="line">          resolve(x);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e); <span class="comment">// 如果出错，以捕获到的错误做为promise2的结果</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 此处与前一个if块的逻辑几乎相同，区别在于所调用的是onRejected函数，就不再做过多解释</span></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (promise2 = <span class="keyword">new</span> myPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> x = onRejected(self.data);</span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> myPromise) &#123;</span><br><span class="line">          x.then(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(x);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e); <span class="comment">// 如果出错，以捕获到的错误做为promise2的结果</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果当前的Promise还处于pending状态，我们并不能确定调用onResolved还是onRejected，</span></span><br><span class="line">    <span class="comment">// 只能等到Promise的状态确定后，才能确实如何处理。</span></span><br><span class="line">    <span class="comment">// 所以我们需要把我们的 两种情况 的处理逻辑做为callback放入promise1(此处即this/self)的回调数组里</span></span><br><span class="line">    <span class="comment">// 逻辑本身跟第一个if块内的几乎一致，此处不做过多解释</span></span><br><span class="line">    <span class="keyword">return</span> (promise2 = <span class="keyword">new</span> myPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      self.onResolvedCallback.push(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> x = onResolved(self.data);</span><br><span class="line">          <span class="keyword">if</span> (x <span class="keyword">instanceof</span> myPromise) &#123;</span><br><span class="line">            x.then(resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(x);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      self.onRejectedCallback.push(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> x = onRejected(self.data);</span><br><span class="line">          <span class="keyword">if</span> (x <span class="keyword">instanceof</span> myPromise) &#123;</span><br><span class="line">            x.then(resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(x);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺便实现一个catch方法</span></span><br><span class="line">myPromise.prototype.catch = <span class="function"><span class="keyword">function</span>(<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>至此，我们就实现了一个的 Promise。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPromise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  self.state = <span class="string">'pending'</span>; <span class="comment">// Promise当前的状态</span></span><br><span class="line">  self.data = <span class="literal">undefined</span>; <span class="comment">// Promise当前的值</span></span><br><span class="line">  self.onResolvedCallback = []; <span class="comment">// Promise resolve时的回调函数集，因为在Promise结束之前有可能有多个回调添加到它上面</span></span><br><span class="line">  self.onRejectedCallback = []; <span class="comment">// Promise reject时的回调函数集，因为在Promise结束之前有可能有多个回调添加到它上面</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (self.state == <span class="string">'pending'</span>) &#123;</span><br><span class="line">      self.state = <span class="string">'resolved'</span>;</span><br><span class="line">      self.data = value;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> self.onResolvedCallback) &#123;</span><br><span class="line">        self.onResolvedCallback[i](value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (self.state == <span class="string">'pending'</span>) &#123;</span><br><span class="line">      self.state = <span class="string">'rejected'</span>;</span><br><span class="line">      self.data = reason;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> self.onRejectedCallback) &#123;</span><br><span class="line">        self.onRejectedCallback[i](reason);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 考虑到执行executor的过程中有可能出错，所以我们用try/catch块给包起来，</span></span><br><span class="line">  <span class="comment">// 并且在出错后以catch到的值reject掉这个Promise</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    executor(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myPromise.prototype.constructor = <span class="string">'myPromise'</span>;</span><br><span class="line">myPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> promise2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据标准，如果then的参数不是function，则我们需要忽略它，此处以如下方式处理：</span></span><br><span class="line">  <span class="comment">// 如果想要把then的实参留空且让值可以穿透到后面，</span></span><br><span class="line">  <span class="comment">// 意味着then的两个参数的默认值分别为function(value) &#123;return value&#125;，function(reason) &#123;throw reason&#125;。</span></span><br><span class="line">  onResolved =</span><br><span class="line">    <span class="keyword">typeof</span> onResolved === <span class="string">'function'</span></span><br><span class="line">      ? onResolved</span><br><span class="line">      : <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> value;</span><br><span class="line">        &#125;;</span><br><span class="line">  onRejected =</span><br><span class="line">    <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span></span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.state == <span class="string">'resolved'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (promise2 = <span class="keyword">new</span> myPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> x = onResolved(self.data);</span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> myPromise) &#123;</span><br><span class="line">          x.then(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(x);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.state == <span class="string">'rejected'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (promise2 = <span class="keyword">new</span> myPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> x = onRejected(self.data);</span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> myPromise) &#123;</span><br><span class="line">          x.then(resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(x);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.state == <span class="string">'pending'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (promise2 = <span class="keyword">new</span> myPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      self.onResolvedCallback.push(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> x = onResolved(self.data);</span><br><span class="line">          <span class="keyword">if</span> (x <span class="keyword">instanceof</span> myPromise) &#123;</span><br><span class="line">            x.then(resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(x);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      self.onRejectedCallback.push(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> x = onRejected(self.data);</span><br><span class="line">          <span class="keyword">if</span> (x <span class="keyword">instanceof</span> myPromise) &#123;</span><br><span class="line">            x.then(resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(x);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myPromise.prototype.catch = <span class="function"><span class="keyword">function</span>(<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参考文献：<br><a href="https://zhuanlan.zhihu.com/p/21834559" target="_blank" rel="noopener">【1】史上最易读懂的 Promise/A+ 完全实现</a><br><a href="https://www.cnblogs.com/huansky/p/6064402.html" target="_blank" rel="noopener">【2】手把手教你实现一个完整的 Promise</a></p>]]></content>
      
      <categories>
          
          <category> LearnES5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript异步编程</title>
      <link href="/2018/03/29/LearnES5/JavaScript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
      <url>/2018/03/29/LearnES5/JavaScript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><ol><li>JavaScript语言执行环境是单线程的，单线程在程序执行时，所走的程序路径按照连续顺序排下来，前面的必须处理好，后面的才会执行。</li><li>在某个特定的时刻只有特定的代码能够被执行，且会阻塞其它的代码。</li></ol><p>基于JavaScript的单线程语言执行环境及其不足，提出了JavaScript的同步与异步编程方式：</p><ol><li>同步，即任务一步一步执行，当前代码执行完毕后才能继续执行后续代码，程序的执行顺序与任务的排列顺序是一致的、同步的；</li><li>异步，每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。</li></ol><p>JavaScript异步编程实现主要归为三类：<strong>回调函数、事件监听、发布订阅、Promise对象</strong></p><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>假定有三个函数 f1 、 f2 和 f3，f2 等待 f1 的执行结果。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f1();</span><br><span class="line">f2();</span><br><span class="line">f3();</span><br></pre></td></tr></table></figure></p><p>如果 f1 是一个很耗时的任务，则可以改写 f1，把 f2 写成 f1 的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// f1 的任务代码</span></span><br><span class="line">    callback();</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则执行代码就编程这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1(f2);</span><br><span class="line">f3();</span><br></pre></td></tr></table></figure></p><p>这样把同步操作变成了异步操作，f1 不会堵塞后面的程序例如 f3 的运行，相当于先执行程序的主要逻辑，将耗时的操作推迟执行。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>简单、容易理解和部署。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。</p><h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><p>采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生。<br>为f1绑定一个事件（这里采用的jQuery的写法）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f1.on(<span class="string">'done'</span>, f2);</span><br></pre></td></tr></table></figure><p>当 f1 发生 done 事件，就执行 f2。<br>对f1进行改写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// f1的任务代码</span></span><br><span class="line">    f1.trigger(<span class="string">'done'</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>f1.trigger(‘done’)表示，执行完成后，立即触发done事件，从而开始执行f2。</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合”（Decoupling），有利于实现模块化。</p><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>整个程序都要变成事件驱动型，运行流程会变得很不清晰。</p><h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><p>假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”（publish-subscribe pattern），又称”观察者模式”（observer pattern）。</p><p>PubSub，发布、订阅模式， 用以分发事件。常见的有jQuery的自定义事件监听、Node的EventEmitter对象等。</p><h3 id="jQuery事件监听"><a href="#jQuery事件监听" class="headerlink" title="jQuery事件监听"></a>jQuery事件监听</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#btn'</span>).on(<span class="string">'myEvent'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'There is my Event'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">'#btn'</span>).trigger(<span class="string">'myEvent'</span>); <span class="comment">//触发 myEvent 事件</span></span><br></pre></td></tr></table></figure><h3 id="PubSub"><a href="#PubSub" class="headerlink" title="PubSub"></a>PubSub</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> PubSub = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.handlers = &#123;&#125;; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅事件</span></span><br><span class="line">PubSub.prototype.subscribe = <span class="function"><span class="keyword">function</span>(<span class="params">eventType, handler</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果操作中心没有这个事件类型，则将该事件初始化</span></span><br><span class="line">  <span class="keyword">if</span> (!(eventType <span class="keyword">in</span> <span class="keyword">this</span>.handlers)) &#123; </span><br><span class="line">      <span class="keyword">this</span>.handlers[eventType] = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.handlers[eventType].push(handler); <span class="comment">//添加事件监听器</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;<span class="comment">//返回上下文环境以实现链式调用</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 发布事件</span></span><br><span class="line">PubSub.prototype.publish = <span class="function"><span class="keyword">function</span>(<span class="params">eventType</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取除事件类型之外的其他参数</span></span><br><span class="line">  <span class="keyword">var</span> _args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, _handlers = <span class="keyword">this</span>.handlers[eventType]; i &lt; _handlers.length; i++) &#123;</span><br><span class="line">      _handlers[i].apply(<span class="keyword">this</span>, _args);<span class="comment">//遍历事件监听器</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> PubSub;<span class="comment">//构造PubSub实例</span></span><br><span class="line"><span class="comment">// 订阅一个事件</span></span><br><span class="line">event.subscribe(<span class="string">'list'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(msg);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 发布这个事件</span></span><br><span class="line">event.publish(<span class="string">'list'</span>, &#123;<span class="attr">data</span>: [<span class="string">'one,'</span>, <span class="string">'two'</span>]&#125;);</span><br><span class="line"><span class="comment">//Object &#123;data: Array[2]&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h2><p>Promises对象是CommonJS工作组提出的一种规范，目的是为异步编程提供统一接口。</p><h3 id="Promise-的生命周期"><a href="#Promise-的生命周期" class="headerlink" title="Promise 的生命周期"></a>Promise 的生命周期</h3><ol><li>一个promise可能有三种状态：等待（pending）、已完成（fulfilled）、已拒绝（rejected）;</li><li>一个promise的状态只可能从“等待”转到“完成”态或者“拒绝”态，不能逆向转换，同时“完成”态和“拒绝”态不能相互转换；</li><li>promise 必须实现 then 方法（可以说，then就是promise的核心），而且 then 必须返回一个 promise，同一个 promise 的 then 可以调用多次，并且回调的执行顺序跟它们被定义时的顺序一致；</li><li>then 方法接受两个参数，第一个参数是 Promise 被完成时要调用的函数，在 promise 由“等待”态转换到“完成”态时调用；另一个是 Promise 被拒绝时的回调，在 promise 由“等待”态转换到“拒绝”态时调用。</li><li>同时，then 可以接受另一个 promise 传入，也接受一个“类 then ”的对象或方法，即 thenable 对象。（thenable 是一个包含了then方法的对象或函数。）</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = readFile(<span class="string">"example.txt);</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">promise.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">contents</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//完成</span></span><br><span class="line">    <span class="built_in">console</span>.log(contents);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//拒绝</span></span><br><span class="line">    <span class="built_in">console</span>.error(err.message);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>也可以写成：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = readFile(<span class="string">"example.txt);</span></span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">contents</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//完成</span></span><br><span class="line">  <span class="built_in">console</span>.log(contents);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//拒绝</span></span><br><span class="line">  <span class="built_in">console</span>.error(err.message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在Node.js中也是使用 Promise 实现上面的 readFile() 函数。</span></span><br><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//触发异步操作：Node.js原生的异步调用包在一个 Promise 中。</span></span><br><span class="line">    fs.readFile(filename,&#123;<span class="attr">encoding</span>:<span class="string">"utf8"</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,contents</span>)</span>&#123;</span><br><span class="line">      <span class="comment">//检查错误</span></span><br><span class="line">  <span class="keyword">if</span>(err)&#123;</span><br><span class="line">    reject(err);</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="comment">//读取成功</span></span><br><span class="line">   resolve(contents);</span><br><span class="line">&#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LearnES5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>书籍整理</title>
      <link href="/2018/03/29/%E7%94%9F%E6%B4%BB/%E4%B9%A6%E7%B1%8D%E6%95%B4%E7%90%86/"/>
      <url>/2018/03/29/%E7%94%9F%E6%B4%BB/%E4%B9%A6%E7%B1%8D%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="正在看"><a href="#正在看" class="headerlink" title="正在看"></a>正在看</h2><h3 id="《你不知道的-JavaScript-上卷》"><a href="#《你不知道的-JavaScript-上卷》" class="headerlink" title="《你不知道的 JavaScript 上卷》"></a><a href="https://book.douban.com/subject/26351021/" target="_blank" rel="noopener">《你不知道的 JavaScript 上卷》</a></h3><p><img src="/2018/03/29/生活/书籍整理/1_1.jpg" alt="《你不知道的 JavaScript 上卷》"></p><h3 id="《HTTP-权威指南》"><a href="#《HTTP-权威指南》" class="headerlink" title="《HTTP 权威指南》"></a><a href="https://book.douban.com/subject/10746113/" target="_blank" rel="noopener">《HTTP 权威指南》</a></h3><p><img src="/2018/03/29/生活/书籍整理/1_2.jpg" alt="《HTTP 权威指南》"></p><h3 id="《ES6-标准入门》"><a href="#《ES6-标准入门》" class="headerlink" title="《ES6 标准入门》"></a><a href="https://book.douban.com/subject/27127030/" target="_blank" rel="noopener">《ES6 标准入门》</a></h3><p><img src="/2018/03/29/生活/书籍整理/1_3.jpg" alt="《ES6 标准入门》"></p><h3 id="《深入理解-ES6-》"><a href="#《深入理解-ES6-》" class="headerlink" title="《深入理解 ES6 》"></a><a href="https://book.douban.com/subject/27072230/" target="_blank" rel="noopener">《深入理解 ES6 》</a></h3><p><img src="/2018/03/29/生活/书籍整理/1_4.jpg" alt="《深入理解 ES6》"></p><h2 id="已看完"><a href="#已看完" class="headerlink" title="已看完"></a>已看完</h2><h3 id="《Head-First-HTML-与-CSS（第2版）》"><a href="#《Head-First-HTML-与-CSS（第2版）》" class="headerlink" title="《Head First HTML 与 CSS（第2版）》"></a><a href="https://book.douban.com/subject/25752357/" target="_blank" rel="noopener">《Head First HTML 与 CSS（第2版）》</a></h3><p><img src="/2018/03/29/生活/书籍整理/2_1.jpg" alt="《Head First HTML 与 CSS（第2版）》"></p><h3 id="《HTML-5-CSS-3-从入门到精通》"><a href="#《HTML-5-CSS-3-从入门到精通》" class="headerlink" title="《HTML 5 + CSS 3 从入门到精通》"></a><a href="https://book.douban.com/subject/24708139/" target="_blank" rel="noopener">《HTML 5 + CSS 3 从入门到精通》</a></h3><p><img src="/2018/03/29/生活/书籍整理/2_2.jpg" alt="《HTML 5 + CSS 3 从入门到精通》"></p><h3 id="《JavaScript-高级程序设计（第3版）》"><a href="#《JavaScript-高级程序设计（第3版）》" class="headerlink" title="《JavaScript 高级程序设计（第3版）》"></a><a href="https://book.douban.com/subject/10546125/" target="_blank" rel="noopener">《JavaScript 高级程序设计（第3版）》</a></h3><p><img src="/2018/03/29/生活/书籍整理/2_3.jpg" alt="《JavaScript 高级程序设计（第3版）》"></p><h3 id="《JavaScript-语言精粹》"><a href="#《JavaScript-语言精粹》" class="headerlink" title="《JavaScript 语言精粹》"></a><a href="https://book.douban.com/subject/11874748/" target="_blank" rel="noopener">《JavaScript 语言精粹》</a></h3><p><img src="/2018/03/29/生活/书籍整理/2_4.jpg" alt="《JavaScript 语言精粹》"></p><h3 id="《CSS-权威指南》"><a href="#《CSS-权威指南》" class="headerlink" title="《CSS 权威指南》"></a><a href="https://book.douban.com/subject/2308234/" target="_blank" rel="noopener">《CSS 权威指南》</a></h3><p><img src="/2018/03/29/生活/书籍整理/2_5.jpg" alt="《CSS 权威指南》"></p><h3 id="《大话数据结构》"><a href="#《大话数据结构》" class="headerlink" title="《大话数据结构》"></a><a href="https://book.douban.com/subject/6424904/" target="_blank" rel="noopener">《大话数据结构》</a></h3><p><img src="/2018/03/29/生活/书籍整理/2_6.jpg" alt="《大话数据结构》"></p><h2 id="准备看"><a href="#准备看" class="headerlink" title="准备看"></a>准备看</h2><h3 id="《JavaScript-DOM-编程艺术（第2版）》"><a href="#《JavaScript-DOM-编程艺术（第2版）》" class="headerlink" title="《JavaScript DOM 编程艺术（第2版）》"></a><a href="https://book.douban.com/subject/6038371/" target="_blank" rel="noopener">《JavaScript DOM 编程艺术（第2版）》</a></h3><p><img src="/2018/03/29/生活/书籍整理/3_1.jpg" alt="《JavaScript DOM 编程艺术（第2版）》"></p><h3 id="《高性能-JavaScript》"><a href="#《高性能-JavaScript》" class="headerlink" title="《高性能 JavaScript》"></a><a href="https://book.douban.com/subject/26599677/" target="_blank" rel="noopener">《高性能 JavaScript》</a></h3><p><img src="/2018/03/29/生活/书籍整理/3_2.jpg" alt="《高性能 JavaScript》"></p><h3 id="《Effective-JavaScript-编写高质量-JavaScript-代码的-68-个有效方法》"><a href="#《Effective-JavaScript-编写高质量-JavaScript-代码的-68-个有效方法》" class="headerlink" title="《Effective JavaScript 编写高质量 JavaScript 代码的 68 个有效方法》"></a><a href="https://book.douban.com/subject/25786138/" target="_blank" rel="noopener">《Effective JavaScript 编写高质量 JavaScript 代码的 68 个有效方法》</a></h3><p><img src="/2018/03/29/生活/书籍整理/3_3.jpg" alt="《Effective JavaScript 编写高质量 JavaScript 代码的 68 个有效方法》"></p><h3 id="《你不知道的-JavaScript-中卷》"><a href="#《你不知道的-JavaScript-中卷》" class="headerlink" title="《你不知道的 JavaScript 中卷》"></a><a href="https://book.douban.com/subject/26854244/" target="_blank" rel="noopener">《你不知道的 JavaScript 中卷》</a></h3><p><img src="/2018/03/29/生活/书籍整理/3_4.jpg" alt="《你不知道的 JavaScript 中卷》"></p><h3 id="《你不知道的-JavaScript-下卷》"><a href="#《你不知道的-JavaScript-下卷》" class="headerlink" title="《你不知道的 JavaScript 下卷》"></a><a href="https://book.douban.com/subject/27620408/" target="_blank" rel="noopener">《你不知道的 JavaScript 下卷》</a></h3><p><img src="/2018/03/29/生活/书籍整理/3_5.jpg" alt="《你不知道的 JavaScript 下卷》"></p>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>js代码判断浏览器种类</title>
      <link href="/2018/03/28/LearnES5/js%E4%BB%A3%E7%A0%81%E5%88%A4%E6%96%AD%E6%B5%8F%E8%A7%88%E5%99%A8%E7%A7%8D%E7%B1%BB/"/>
      <url>/2018/03/28/LearnES5/js%E4%BB%A3%E7%A0%81%E5%88%A4%E6%96%AD%E6%B5%8F%E8%A7%88%E5%99%A8%E7%A7%8D%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h2 id="只区分浏览器，不考虑版本"><a href="#只区分浏览器，不考虑版本" class="headerlink" title="只区分浏览器，不考虑版本"></a>只区分浏览器，不考虑版本</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> browserVersions = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> u = navigator.userAgent;</span><br><span class="line">  <span class="keyword">var</span> app = navigator.appVersion;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    trident: u.indexOf(<span class="string">"Trident"</span>) &gt; <span class="number">-1</span>, <span class="comment">//IE内核</span></span><br><span class="line">    presto: u.indexOf(<span class="string">"Presto"</span>) &gt; <span class="number">-1</span>, <span class="comment">//opera内核</span></span><br><span class="line">    webKit: u.indexOf(<span class="string">"AppleWebKit"</span>) &gt; <span class="number">-1</span>, <span class="comment">//苹果、谷歌内核</span></span><br><span class="line">    gecko: u.indexOf(<span class="string">"Gecko"</span>) &gt; <span class="number">-1</span> &amp;&amp; u.indexOf(<span class="string">"KHTML"</span>) == <span class="number">-1</span>, <span class="comment">//火狐内核</span></span><br><span class="line">    mobile: !!u.match(<span class="regexp">/AppleWebKit.*Mobile.*/</span>)||!!u.match(<span class="regexp">/AppleWebKit/</span>), <span class="comment">//是否为移动终端</span></span><br><span class="line">    ios: !!u.match(<span class="regexp">/(i[^;]+;( U;)? CPU.+Mac OS X/</span>), <span class="comment">//ios终端</span></span><br><span class="line">    android: u.indexOf(<span class="string">"Android"</span>) &gt; <span class="number">-1</span> || u.indexOf(<span class="string">"Linux"</span>) &gt; <span class="number">-1</span>, <span class="comment">//android终端或者uc浏览器</span></span><br><span class="line">    iPhone: u.indexOf(<span class="string">"iPhone"</span>) &gt; <span class="number">-1</span> || u.indexOf(<span class="string">"Mac"</span>) &gt; <span class="number">-1</span>, <span class="comment">//是否为iPhone或者QQHD浏览器</span></span><br><span class="line">    iPad: u.indexOf(<span class="string">"iPad"</span>) &gt; <span class="number">-1</span>, <span class="comment">//是否iPad</span></span><br><span class="line">    webApp: u.indexOf(<span class="string">"Safari"</span>) == <span class="number">-1</span> <span class="comment">//是否web应该程序，没有头部与底部</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LearnES5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>华为笔试题</title>
      <link href="/2018/03/28/Programming/%E5%8D%8E%E4%B8%BA%E7%AC%94%E8%AF%95%E9%A2%98/"/>
      <url>/2018/03/28/Programming/%E5%8D%8E%E4%B8%BA%E7%AC%94%E8%AF%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>华为笔试题，前面两道题非常简单就不进行记录了。</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入是一个整型数组，数组里的整形数可以是正数，也可以是负数。子数组指的是数组中连续的一个或多个元素的集合，求这些子数组中，求和后最大值是多少。</p><p><strong>输入描述：</strong></p><blockquote><p>一个整型数组</p></blockquote><p><strong>输出描述：</strong></p><blockquote><p>最大连续子数组的和。</p></blockquote><h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GreatSum</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    sum += arr[i];</span><br><span class="line">    <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      sum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; result) &#123;</span><br><span class="line">      result = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> j <span class="keyword">in</span> arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">          result = arr[j];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result &lt; arr[j]) &#123;</span><br><span class="line">          result = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网易互娱一面感想</title>
      <link href="/2018/03/28/%E7%94%9F%E6%B4%BB/%E7%BD%91%E6%98%93%E4%BA%92%E5%A8%B1%E4%B8%80%E9%9D%A2%E6%84%9F%E6%83%B3/"/>
      <url>/2018/03/28/%E7%94%9F%E6%B4%BB/%E7%BD%91%E6%98%93%E4%BA%92%E5%A8%B1%E4%B8%80%E9%9D%A2%E6%84%9F%E6%83%B3/</url>
      <content type="html"><![CDATA[<p>邮件通知我今天下午网易互娱一面视频面试，我当时心里是很紧张的。担心出现像之前今日头条视频面一样的情况，在公司的会议室面试结果老大来视察，差点被抓到暗地找实习，所以这次我背着电脑回寝室面。</p><p>中午怎么也睡不好觉，一点风吹草动就被惊醒，直接导致面试的时候思路不是很清晰。</p><p>但是，其实最郁闷的是面试，面试官先让我介绍一下我自己。我就说本科怎么怎么样，然后现在研究生怎么怎么blabla说了一堆。介绍完之后，他也不问我基础，让我说一下我最熟练的项目。我就说我现在正在重构的视频侦查作战平台，基于angularjs1做的，然后介绍了一堆。然后面试官问我知不知道前端框架，用前端框架会轻松得很多，你知不知道vue。我说我看过一些文档，但因为公司项目基于angularjs1，所以没有上手实战过。</p><p>看得出来他对我所知道的知识也不是很感兴趣，所以也没有怎么针对我所了解的知识进行深问。然后没问多少东西就结束了。最后的最后他给我提了一些意见：对前端的兴趣是有的，但热情不够= =。。。让我多去看github上人家写的源码。</p><p>本来我以为会像头条那样把基础问得很深，问得特别难，没想到会被技术刷人了。</p><p>结论：果然我要去上手实战一下 Vue 么！</p><p>后来佳静回来了，说了一番话让我没那么感觉郁闷了。她说不仅是前端团队在选择你，其实你也要选择前端团队。其实框架是互通的，如果他们并不知道angularjs也是前端框架的话，那说明这个团队其实知识面也是局限的，可能在这个团队学到的东西也很有限。嗯，我觉得也有道理。</p>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>HTML</title>
      <link href="/2018/03/27/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/HTML/"/>
      <url>/2018/03/27/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/HTML/</url>
      <content type="html"><![CDATA[<h3 id="1、-lt-img-gt-标签上-title-属性与-alt-属性的区别是什么？"><a href="#1、-lt-img-gt-标签上-title-属性与-alt-属性的区别是什么？" class="headerlink" title="1、 &lt;img&gt;标签上 title 属性与 alt 属性的区别是什么？"></a>1、 <code>&lt;img&gt;</code>标签上 <code>title</code> 属性与 <code>alt</code> 属性的区别是什么？</h3><ul><li><code>alt</code> 属性：是为了给那些不能看到你文档中图像的浏览者提供文字说明的。且长度必须少于 100 个英文字符或者用户必须保证替换文字尽可能的短。这包括那些使用本来就不支持图像显示或者图像显示被关闭的浏览器的用户，视觉障碍的用户和使用屏幕阅读器的用户等。</li><li><code>title</code> 属性：为设置该属性的元素提供建议性的信息。使用 title 属性提供非本质的额外信息。</li></ul><h3 id="2、-请写出至少-5-个-HTML5-新增的标签，并说明其语义和应用场景。"><a href="#2、-请写出至少-5-个-HTML5-新增的标签，并说明其语义和应用场景。" class="headerlink" title="2、 请写出至少 5 个 HTML5 新增的标签，并说明其语义和应用场景。"></a>2、 请写出至少 5 个 HTML5 新增的标签，并说明其语义和应用场景。</h3><ul><li><code>section</code>：定义文档中的一个章节</li><li><code>nav</code>：定义只包含导航链接的章节</li><li><code>header</code>：定义页面或章节的头部。它经常包含 logo、页面标题和导航性的目录。</li><li><code>footer</code>：定义页面或章节的尾部。它经常包含版权信息、法律信息链接和反馈建议用的地址。</li><li><code>aside</code>：定义和页面内容关联度较低的内容——如果被删除，剩下的内容仍然很合理。</li></ul><h3 id="3、-请说说你对标签语义化的理解？"><a href="#3、-请说说你对标签语义化的理解？" class="headerlink" title="3、 请说说你对标签语义化的理解？"></a>3、 请说说你对标签语义化的理解？</h3><h4 id="什么是-HTML-语义化？"><a href="#什么是-HTML-语义化？" class="headerlink" title="什么是 HTML 语义化？"></a>什么是 HTML 语义化？</h4><p>根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。</p><h4 id="为什么要语义化？"><a href="#为什么要语义化？" class="headerlink" title="为什么要语义化？"></a>为什么要语义化？</h4><ul><li>为了在没有 CSS 的情况下，页面也能呈现出很好地内容结构、代码结构 ;</li><li>用户体验：例如 <code>title</code>、 <code>alt</code> 用于解释名词或解释图片信息、 <code>label</code> 标签的活用；</li><li>有利于 SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；</li><li>方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；</li><li>便于团队开发和维护，语义化更具可读性，是下一步网页的重要动向，遵循 W3C 标准的团队都遵循这个标准，可以减少差异化。</li></ul><h4 id="语义化标签有哪些？"><a href="#语义化标签有哪些？" class="headerlink" title="语义化标签有哪些？"></a>语义化标签有哪些？</h4><ul><li><code>&lt;header&gt;&lt;/header&gt;</code></li><li><code>&lt;footer&gt;&lt;/footer&gt;</code></li><li><code>&lt;nav&gt;&lt;/nav&gt;</code></li><li><code>&lt;section&gt;&lt;/section&gt;</code></li><li><code>&lt;article&gt;&lt;/article&gt;</code> ：用来在页面中表示一套结构完整且独立的内容部分</li><li><code>&lt;aside&gt;&lt;/aside&gt;</code> ：主题的附属信息 ( 用途很广，主要就是一个附属内容 ) ，如果 article 里面为一篇文章的话，那么文章的作者以及信息内容就是这篇文章的附属内容了</li><li><code>&lt;figure&gt;&lt;/figure&gt;</code> ：媒体元素，比如一些视频，图片啊等等</li><li><code>&lt;datalist&gt;&lt;/datalist&gt;</code> ：选项列表，与 input 元素配合使用，来定义 input 可能的值</li><li><code>&lt;details&gt;&lt;/details&gt;</code> ：用于描述文档或者文档某个部分的细节 ~ 默认属性为 open<ul><li>ps：配合 summary 一起使用</li></ul></li></ul><h3 id="4、-Doctype-作用-严格模式与混杂模式如何区分？它们有何意义"><a href="#4、-Doctype-作用-严格模式与混杂模式如何区分？它们有何意义" class="headerlink" title="4、 Doctype 作用? 严格模式与混杂模式如何区分？它们有何意义?"></a>4、 Doctype 作用? 严格模式与混杂模式如何区分？它们有何意义?</h3><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><ul><li><code>&lt;!DOCTYPE&gt;</code> 声明位于文档中的最前面，告知浏览器的解析器使用哪种文档类型来解析文档。</li><li>该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。</li></ul><h5 id="区分："><a href="#区分：" class="headerlink" title="区分："></a>区分：</h5><ul><li>严格模式的排版 和 JS 运作模式 是以该浏览器支持的最高标准运行。</li><li>混杂模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。DOCTYPE 不存在 或 格式不正确 会导致文档以混杂模式呈现。</li></ul><blockquote><p>DOCTYPE 声明——标准模式与怪异模式的区别</p></blockquote><h3 id="5、-你知道多少种-Doctype-文档类型？"><a href="#5、-你知道多少种-Doctype-文档类型？" class="headerlink" title="5、 你知道多少种 Doctype 文档类型？"></a>5、 你知道多少种 Doctype 文档类型？</h3><p>标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。</p><ul><li>HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。</li><li>XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。</li><li>Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页， 浏览器按 W3C 标准解析执行代码</li><li>Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。</li></ul><h3 id="6、HTML-与-XHTML——二者有什么区别。"><a href="#6、HTML-与-XHTML——二者有什么区别。" class="headerlink" title="6、HTML 与 XHTML——二者有什么区别。"></a>6、HTML 与 XHTML——二者有什么区别。</h3><p>HTML 是一种基本的 WEB 网页设计语言，XHTML 是一个基于 XML 的置标语言</p><ul><li>XHTML 元素必须被正确地嵌套</li><li>XHTML 元素必须被关闭，空标签也必须被关闭，如必须写成 <br></li><li>XHTML 标签名必须用小写字母</li><li>XHTML 文档要求给所有属性赋一个值</li><li>XHTML 要求所有的属性必须用引号””括起来</li><li>XHTML 文档需要把所有 &lt; 、&gt;、&amp; 等特殊符号用编码表示</li><li>XHTML 文档不要在注释内容中使“–”</li><li>XHTML 图片必须有说明文字</li><li>XHTML 文档中用 id 属性代替 name 属性</li></ul><h3 id="7、-HTML5-有哪些新特性、移除了哪些元素？"><a href="#7、-HTML5-有哪些新特性、移除了哪些元素？" class="headerlink" title="7、 HTML5 有哪些新特性、移除了哪些元素？"></a>7、 HTML5 有哪些新特性、移除了哪些元素？</h3><p>HTML5 新增了 27 个元素，废弃了 16 个元素。根据现有的标准规范，把 HTML5 的元素按优先级定义为结构性属性、级块性元素、行内语义性元素和交互性元素 4 大类。</p><h4 id="元素新特性"><a href="#元素新特性" class="headerlink" title="元素新特性"></a>元素新特性</h4><ol><li>结构性元素主要负责 web 上下文结构的定义。</li></ol><ul><li><code>section</code>：在 web 页面应用中，该元素也可以用于区域的章节描述。</li><li><code>header</code>：页面主体上的头部， header 元素往往在一对 body 元素中。</li><li><code>footer</code>：页面的底部（页脚），通常会标出网站的相关信息。</li><li><code>nav</code>：专门用于菜单导航、链接导航的元素，是 navigator 的缩写。</li><li><code>article</code>：用于表现一篇文章的主体内容，一般为文字集中显示的区域。</li></ul><ol start="2"><li>级块性元素主要完成 web 页面区域的划分，确保内容的有效分割。</li></ol><ul><li><code>aside</code>：用于表达注记、贴士、侧栏、摘要、插入的引用等作为补充主体的内容。</li><li><code>figure</code>：是对多个元素进行组合并展示的元素，通常与 ficaption 联合使用。</li><li><code>code</code>：表示一段代码块。</li><li><code>dialog</code>：用于表达人与人之间的对话，该元素包含 dt 和 dd 这两个组合元素， dt 用于表示说话者，而 dd 用来表示说话内容。</li></ul><ol start="3"><li>行内语义性元素主要完成 web 页面具体内容的引用和描述，是丰富内容展示的基础。</li></ol><ul><li><code>meter</code>：表示特定范围内的数值，可用于工资、数量、百分比等。</li><li><code>time</code>：表示时间值。</li><li><code>progress</code>：用来表示进度条，可通过对其 max 、 min 、 step 等属性进行控制，完成对进度的表示和监事。</li><li><code>video</code>：视频元素，用于支持和实现视频文件的直接播放，支持缓冲预载和多种视频媒体格式。</li><li><code>audio</code>：音频元素，用于支持和实现音频文件的直接播放，支持缓冲预载和多种音频媒体格式。</li></ul><ol start="4"><li>交互性元素主要用于功能性的内容表达，会有一定的内容和数据的关联，是各种事件的基础。</li></ol><ul><li><code>details</code>：用来表示一段具体的内容，但是内容默认可能不显示，通过某种手段（如单击）与 legend 交互才会显示出来。</li><li><code>datagrid</code>：用来控制客户端数据与显示，可以由动态脚本及时更新。</li><li><code>menu</code>：主要用于交互菜单（曾被废弃又被重新启用的元素）。</li><li><code>command</code>：用来处理命令按钮。</li></ul><h4 id="API-新特性："><a href="#API-新特性：" class="headerlink" title="API 新特性："></a>API 新特性：</h4><ol><li>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</li><li>语义化更好的内容标签（ <code>header</code> ，<code>nav</code>，<code>footer</code>，<code>aside</code>，<code>article</code>，<code>section</code>）</li><li>音频、视频 API(<code>audio</code>，<code>video</code>)</li><li>画布( canvas ) API</li><li>地理(Geolocation) API</li><li>本地离线存储 <code>localStorage</code> 长期存储数据，浏览器关闭后数据不丢失</li><li><code>sessionStorage</code> 的数据在页面会话结束时会被清除</li><li>表单控件，<code>calendar</code>、<code>date</code>、<code>time</code>、<code>email</code>、<code>url</code>、<code>search</code></li><li>新的技术 <code>web worker</code>, <code>web socket</code> 等<ul><li><code>web socket</code> 一种协议，可以让我们建立客户端到服务器端的全双工通信，这就意味着服务器端可以主动推送数据到客户端。</li><li><code>web worker</code> 运行在浏览器后台的 js 程序，他不影响主程序的运行，是另开的一个 js 线程，可以用这个线程执行复杂的数据操作，然后把操作结果通过 postMessage 传递给主线程，这样在进行复杂且耗时的操作时就不会阻塞主线程了。</li></ul></li><li>拖拽释放(Drag and drop) API</li></ol><h4 id="移除元素："><a href="#移除元素：" class="headerlink" title="移除元素："></a>移除元素：</h4><ol><li>纯表现的元素：<ul><li><code>&lt;basefont&gt;</code> 默认字体，不设置字体，以此渲染</li><li><code>&lt;font&gt;</code> 字体标签</li><li><code>&lt;center&gt;</code> 水平居中</li><li><code>&lt;u&gt;</code> 下划线</li><li><code>&lt;big&gt;</code> 大字体</li><li><code>&lt;strike&gt;</code> 中横线</li><li><code>&lt;tt&gt;</code> 文本等宽</li></ul></li><li>框架集：frame，frameset，noframes；</li></ol><h3 id="8、-Quirks-模式是什么？它和-Standards-模式有什么区别？"><a href="#8、-Quirks-模式是什么？它和-Standards-模式有什么区别？" class="headerlink" title="8、 Quirks 模式是什么？它和 Standards 模式有什么区别？"></a>8、 Quirks 模式是什么？它和 Standards 模式有什么区别？</h3><h4 id="Quirks-模式（怪癖模式，诡异模式，怪异模式）"><a href="#Quirks-模式（怪癖模式，诡异模式，怪异模式）" class="headerlink" title="Quirks 模式（怪癖模式，诡异模式，怪异模式）"></a>Quirks 模式（怪癖模式，诡异模式，怪异模式）</h4><p>在写程序时我们也会经常遇到这样的问题，如何保证原来的接口不变，又提供更强大的功能，尤其是新功能不兼容旧功能时。IE6 以前的页面大家都不会去写 DTD，所以 IE6 就假定 如果写了 DTD，就意味着这个页面将采用对 CSS 支持更好的布局，而如果没有，则采用兼容之前的布局方式(Quirks 模式)。</p><h4 id="区别：总体有布局、样式解析和脚本执行三个方面的区别。"><a href="#区别：总体有布局、样式解析和脚本执行三个方面的区别。" class="headerlink" title="区别：总体有布局、样式解析和脚本执行三个方面的区别。"></a>区别：总体有布局、样式解析和脚本执行三个方面的区别。</h4><ol><li>盒模型：在 W3C 标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在 Quirks 模式下，IE 的宽度和高度还包含了 padding 和 border。</li><li>设置行内元素的高宽：在 Standards 模式下，给<code>&lt;span&gt;</code>等行内元素设置 wdith 和 height 都不会生效，而在 quirks 模式下，则会生效。</li><li>设置百分比的高度：在 standards 模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置百分比的高度，子元素设置一个百分比的高度是无效的用</li><li>设置水平居中：使用 <code>margin: 0 auto</code> 在 standards 模式下可以使元素水平居中，但在 quirks 模式下却会失效。</li></ol><h3 id="9、-请阐述-table-表格布局的缺点。"><a href="#9、-请阐述-table-表格布局的缺点。" class="headerlink" title="9、 请阐述 table 表格布局的缺点。"></a>9、 请阐述 table 表格布局的缺点。</h3><ol><li>太深的嵌套，比如 table &gt; tr &gt; td &gt; h3，会导致搜索引擎读取困难，而且，最直接的损失就是大大增加了冗余代码量。</li><li>灵活性差，比如要将 tr 设置 border 等属性，是不行的，得通过 td</li><li>代码臃肿，当在 table 中套用 table 的时候，阅读代码会显得异常混乱</li><li>混乱的 colspan 与 rowspan，用来布局时，频繁使用他们会造成整个文档顺序混乱。</li><li>table 需要多次计算才能确定好其在渲染树中节点的属性，通常要花 3 倍于同等元素的时间。</li><li>不够语义</li></ol><h3 id="10、-简述一下-src-与-href-的区别。"><a href="#10、-简述一下-src-与-href-的区别。" class="headerlink" title="10、 简述一下 src 与 href 的区别。"></a>10、 简述一下 src 与 href 的区别。</h3><p>src 用于替换当前元素，href 用于在当前文档和引用资源之间确立联系。</p><ul><li>href 是指向 网络资源 所在位置，建立 引用资源 和 当前元素（锚点）/当前文档（链接） 之间的链接。</li><li>src 是指向 外部资源 的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本，img 图片和 frame 等元素。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将 js 脚本放在底部而不是头部。</li></ul><h3 id="11、HTML中-input-和-textarea-的区别。"><a href="#11、HTML中-input-和-textarea-的区别。" class="headerlink" title="11、HTML中 input 和 textarea 的区别。"></a>11、HTML中 <code>input</code> 和 <code>textarea</code> 的区别。</h3><p><code>&lt;input&gt;</code>元素： 单行文本框</p><ol><li>一定要指定<code>type</code>的值为<code>text</code>；</li><li>通过<code>size</code>属性指定显示字符的长度，<code>value</code>属性指定初始值，<code>Maxlength</code>属性指定文本框可以输入的最长长度；<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">""</span> <span class="attr">size</span>=<span class="string">"10"</span> <span class="attr">Maxlength</span>=<span class="string">"15"</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p><code>&lt;textarea&gt;</code>元素： 多行文本框。</p><ol><li>使用<code>&lt;textarea&gt;&lt;/textarea&gt;</code>标签对</li><li>内容放在<code>&lt;textarea&gt;&lt;/textarea&gt;</code>标签对中</li><li>使用<code>row</code>、<code>col</code>指定大小<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">row</span>=<span class="string">"3"</span> <span class="attr">col</span>=<span class="string">"4"</span>&gt;</span>内容内容内容内容<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="12、用一个div模拟textarea的实现。"><a href="#12、用一个div模拟textarea的实现。" class="headerlink" title="12、用一个div模拟textarea的实现。"></a>12、用一个div模拟<code>textarea</code>的实现。</h3><p>利用 <code>contenteditable=&quot;true&quot;</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">contenteditable</span>=<span class="string">"true"</span> <span class="attr">style</span>=<span class="string">"border: 1px blue solid;outline: 0;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="13、在手机上访问的响应式页面增加一串meta标签，以阻止移动端浏览器的这些自动行为。"><a href="#13、在手机上访问的响应式页面增加一串meta标签，以阻止移动端浏览器的这些自动行为。" class="headerlink" title="13、在手机上访问的响应式页面增加一串meta标签，以阻止移动端浏览器的这些自动行为。"></a>13、在手机上访问的响应式页面增加一串meta标签，以阻止移动端浏览器的这些自动行为。</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"telephone=no"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"email=no"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"address=no"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"date=no"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="14、补全下面的代码，实现一个四分之一圆："><a href="#14、补全下面的代码，实现一个四分之一圆：" class="headerlink" title="14、补全下面的代码，实现一个四分之一圆："></a>14、补全下面的代码，实现一个四分之一圆：</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">”quarter”</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.quarter</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>:blue;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">100%</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 前端面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>博客和域名连接后,博客的重新开始</title>
      <link href="/2018/03/27/%E7%94%9F%E6%B4%BB/%E5%8D%9A%E5%AE%A2%E5%92%8C%E5%9F%9F%E5%90%8D%E8%BF%9E%E6%8E%A5%E5%90%8E-%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B/"/>
      <url>/2018/03/27/%E7%94%9F%E6%B4%BB/%E5%8D%9A%E5%AE%A2%E5%92%8C%E5%9F%9F%E5%90%8D%E8%BF%9E%E6%8E%A5%E5%90%8E-%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B/</url>
      <content type="html"><![CDATA[<p>早很久前就想将原来的博客重新更换一下，想换一个更好的主题，能够让我将我需要的知识保存并更方便查看。也是早很久前就想买个属于自己的域名。<br>腾讯来华科进行技术宣讲，现在我很庆幸我当时去了。<br>在宣讲会上可能能获取到的知识不多，但是我领到了一张腾讯云的100元优惠券。O(∩_∩)O 用那张优惠券，免费买了三年的域名使用权~<br>于是，现在我又重新开始在这里写博客啦！</p>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>ECMAScript数据类型</title>
      <link href="/2018/03/27/LearnES5/ECMAScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/03/27/LearnES5/ECMAScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>ECMAScirpt 5.1 中定义了6种数据类型，其中有5中简单数据类型（基本数据类型）:</p><ol><li><strong>Undefined：</strong>只有一个值，为undefined，意味着“空值(no value)”，适用于所有数据类型。</li><li><strong>Null：</strong>只有一个值，为null，意味着“空对象(no object)”，只适用于对象类型。（literal）</li><li><strong>Boolean：</strong>有两个值，为true与false </li><li><strong>Number：</strong>值遵循IEEE 754标准的64位浮点数的集合，没有整型数据结构。此外还包含三个特殊的值：NaN、Infinity、Infinity</li><li><strong>String：</strong>值是有穷个Unicode字符的集合。必须用’或”括起来。</li><li>还有一种复杂数据类型： <strong>Object</strong></li><li>最新的ECMAScript 6 又加了一种类型：<strong>Symbol</strong> (ECMAScript 6 新定义)</li></ol><hr><h2 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h2><p>用来检测给定变量的数据类型。<br>对一个值使用typeof操作符可能返回下列某个字符：</p><ol><li>“undefined”值未定义 </li><li>“boolean”布尔值 </li><li>“string”字符串 </li><li>“number”数值 </li><li>“object”对象或null</li><li>“function”函数</li></ol><p>使用：typeof 操作数  /  typeof(操作数)  ——&gt;圆括号不是必须的，因为typeof不是函数</p><hr><h2 id="Undefine类型"><a href="#Undefine类型" class="headerlink" title="Undefine类型"></a>Undefine类型</h2><p>首字母大写的Undefined表示的是一种数据类型，小写的undefined表示的是属于这种数据类型的唯一的一个值。<br>使用var声明变量但未进行初始化时，这个变量的值就是undefined，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message;</span><br><span class="line">alert(message == <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>一个未初始化的变量的值为undefined，一个没有传入实参的形参变量的值为undefined，如果一个函数什么都不返回，则该函数默认返回undefined。</p><blockquote><p>注意： 对未声明的变量执行typeof操作符同样会返回undefined。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message; <span class="comment">//这个变量声明之后默认为undefined</span></span><br><span class="line"><span class="comment">// 下面这个变量未声明</span></span><br><span class="line"><span class="comment">// var age</span></span><br><span class="line">alert(<span class="keyword">typeof</span> message); <span class="comment">// "undefined"</span></span><br><span class="line">alert(<span class="keyword">typeof</span> age); <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure><hr><h2 id="Null类型"><a href="#Null类型" class="headerlink" title="Null类型"></a>Null类型</h2><p>首字母大写的Null表示的是一种数据类型，小写的null表示的是属于这种数据类型的唯一的一个值。<br>null值表示一个空对象指针：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> car = <span class="literal">null</span>;</span><br><span class="line">alert(<span class="keyword">typeof</span> car); <span class="comment">//"object"</span></span><br></pre></td></tr></table></figure><p>如果定义的变量准备用于保存对象，那么最好将该变量初始化为null。</p><p>undefined 值派生自 null，因此规定相等性测试返回 true。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span>  == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><p>null 是一个字面量 (而不是全局对象的一个属性，undefined 是 )</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span>);             <span class="comment">//null</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span>);        <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.null);      <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.undefined); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p><strong>null与undefined的区别</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foot); <span class="comment">// Uncaught ReferenceError: foot is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="built_in">console</span>.log(foo);  <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(bar);  <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>        <span class="comment">// object (bug in ECMAScript, should be null)</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>   <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><hr><h2 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h2><p>1、如果 Boolean 构造函数的参数不是一个布尔值，则该参数会被转换成一个布尔值。<br>2、<strong>转换规则:</strong></p><table><thead><tr><th>数据类型</th><th>true</th><th>false</th></tr></thead><tbody><tr><td>Boolean</td><td>true</td><td>false</td></tr><tr><td>String</td><td>任何非空字符串</td><td>“”（空字符串）</td></tr><tr><td>Number</td><td>任何非零数字值（包括无穷大）</td><td>0 和 NaN</td></tr><tr><td>Object</td><td>任何对象</td><td>null</td></tr><tr><td>Undefined</td><td>（不适用）</td><td>undefined</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化的时候</span></span><br><span class="line"><span class="comment">//false</span></span><br><span class="line"><span class="keyword">var</span> bfalse = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">var</span> bEmptyString = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="string">""</span>);</span><br><span class="line"><span class="keyword">var</span> bZero = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> bNaN = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">NaN</span>);</span><br><span class="line"><span class="keyword">var</span> bNull = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">var</span> bNoParam = <span class="keyword">new</span> <span class="built_in">Boolean</span>(); <span class="comment">//相当于传入undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="keyword">var</span> btrue = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">var</span> btrueString = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="string">"true"</span>);</span><br><span class="line"><span class="keyword">var</span> bfalseString = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="string">"false"</span>);</span><br><span class="line"><span class="keyword">var</span> bSuLin = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="string">"Su Lin"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>不要通过新建 Boolean 对象的方法来将一个非布尔值转化成布尔值。 直接使用 Boolean 函数才是正确的</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="built_in">Boolean</span>(expression);     <span class="comment">// 这样用</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="built_in">Boolean</span>(expression); <span class="comment">// 而不要这样!</span></span><br></pre></td></tr></table></figure><h2 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h2><p>根据 ECMAScript 标准，JavaScript 中只有一种数字类型：基于 IEEE 754 标准的双精度 64 位二进制格式的值（-(253 -1) 到 253 -1）。它并没有为整数给出一种特定的类型。除了能够表示浮点数外，还有一些带符号的值：+Infinity，-Infinity 和 NaN (非数值，Not-a-Number)</p><h3 id="1-数值字面量格式："><a href="#1-数值字面量格式：" class="headerlink" title="1.数值字面量格式："></a>1.数值字面量格式：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intNum = <span class="number">55</span>; <span class="comment">//十进制整数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> octalNum1 = <span class="number">070</span>; <span class="comment">//八进制 56</span></span><br><span class="line"><span class="keyword">var</span> octalNum1 = <span class="number">079</span>; <span class="comment">//无效，解析为79</span></span><br><span class="line"><span class="keyword">var</span> octalNum1 = <span class="number">08</span>;  <span class="comment">//无效，解析为8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hexNum1 = <span class="number">0xA</span>;  <span class="comment">//十六进制 10</span></span><br><span class="line"><span class="keyword">var</span> hexNum1 = <span class="number">0x1f</span>; <span class="comment">//十六进制31</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> floatNum1 = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">var</span> floatNum2 = <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">var</span> floatNum3 = <span class="number">.1</span>; <span class="comment">//有效但不推荐</span></span><br><span class="line"><span class="keyword">var</span> floatNum4 = <span class="number">1.0</span>; <span class="comment">//小数点后面没有数字，转换为整数 解析为1</span></span><br><span class="line"><span class="keyword">var</span> floatNum5 = <span class="number">10.0</span>; <span class="comment">//整数 解析为10</span></span><br><span class="line"><span class="keyword">var</span> floatNum6 = <span class="number">3.125e7</span>; <span class="comment">//等于31250000</span></span><br></pre></td></tr></table></figure><p>数字类型只有一个整数，它有两种表示方法： 0 可表示为 -0 和 +0（”0” 是 +0 的简写）。 在实践中，这也几乎没有影响。 例如 +0 === -0 为真。 但是，你可能要注意除以0的时候：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">42</span> / +<span class="number">0</span>; <span class="comment">// Infinity</span></span><br><span class="line"><span class="number">42</span> / <span class="number">-0</span>; <span class="comment">// -Infinity</span></span><br></pre></td></tr></table></figure><h3 id="2-数值范围"><a href="#2-数值范围" class="headerlink" title="2.数值范围"></a>2.数值范围</h3><table><thead><tr><th>表示</th><th>描述</th></tr></thead><tbody><tr><td>Number.MIN_VALUE</td><td>最小数值，一般为5e-324</td></tr><tr><td>Number.MAX_VALUE</td><td>最大数值，一般为1.7976931348623157e+308</td></tr><tr><td>Infinity</td><td>正无穷，是不能参与计算的数值</td></tr><tr><td>-Infinity</td><td>负无穷，是不能参与计算的数值</td></tr></tbody></table><h3 id="3-NAN"><a href="#3-NAN" class="headerlink" title="3.NAN"></a>3.NAN</h3><p>如果参数无法被转换为数字，则返回 NaN。</p><ul><li>任何涉及NaN的操作（例如NaN/10）都会返回NaN。</li><li>NaN与任何值都不相等，包括NaN本身。</li></ul><p>ECMAScript定义了isNaN()函数来确定某个参数是否“不是数值”。isNaN()在接收到一个值之后，会尝试将这个值转换为数值。某些不是数值的值会直接转换为数值，而任何不能被转换为数值的值都会导致这个函数返回true。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>);        <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="built_in">Number</span>.NaN); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">0</span> / <span class="number">0</span>)       <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// e.g. these would have been true with global isNaN()</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">"NaN"</span>);      <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">undefined</span>);  <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(&#123;&#125;);         <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">"blabla"</span>);   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// These all return false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">37</span>);</span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">"37"</span>);</span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">"37.37"</span>);</span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">""</span>);</span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">" "</span>);</span><br></pre></td></tr></table></figure><p>将非数值转换为数值：Number()、parseInt()、parseFloat()</p><p><strong>Number() 可用于任何数据类型</strong></p><h3 id="转换规则："><a href="#转换规则：" class="headerlink" title="转换规则："></a>转换规则：</h3><ul><li>Boolean值：true false分别转换为1 0</li><li>数字值：简单的传入和返回</li><li>null值：0</li><li>undefined值：返回NaN</li><li>字符串：<ul><li>只包含数字（包括前面带正、负号）则转换为十进制数值</li><li>包含有效的浮点格式，如“1.1”，则转换为对应的浮点数</li><li>包含有效的十六进制格式，如“0xf”，则转换为相同大小的十进制整数</li><li>字符串为空，则转换为0</li><li>字符串中包含除上述格式之外的字符，则转换为NaN</li></ul></li><li>若为对象，则调用对象的valueof()方法，然后依照前面的规则转换返回值。若转换的结果是NaN，则调用对象的toString()方法，然后再次依照前面的规则转换返回值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">Number</span>(<span class="string">"hello world!"</span>); <span class="comment">//NaN</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">Number</span>(<span class="string">""</span>);             <span class="comment">//0</span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">Number</span>(<span class="string">"000011"</span>);       <span class="comment">//11</span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">Number</span>(<span class="literal">true</span>);           <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//处理整数常用parseInt()函数</span></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseInt</span>(<span class="string">"1234blue"</span>); <span class="comment">//1234</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">""</span>);         <span class="comment">//NaN</span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseInt</span>(<span class="string">"0xA"</span>);      <span class="comment">//10</span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseInt</span>(<span class="number">22.5</span>);       <span class="comment">//22</span></span><br><span class="line"><span class="keyword">var</span> num5 = <span class="built_in">parseInt</span>(<span class="string">"070"</span>);      <span class="comment">//ECMAScript 3 认为是56 八进制，ECMAScript 5 认为是70 十进制</span></span><br><span class="line"><span class="keyword">var</span> num6 = <span class="built_in">parseInt</span>(<span class="string">"70"</span>);       <span class="comment">//70 十进制</span></span><br><span class="line"><span class="keyword">var</span> num7 = <span class="built_in">parseInt</span>(<span class="string">"0xf"</span>);      <span class="comment">//15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//处理浮点数常用parseFloat()函数</span></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseFloat</span>(<span class="string">"1234blue"</span>); <span class="comment">//1234</span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseFloat</span>(<span class="string">"0xA"</span>);      <span class="comment">//0</span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseFloat</span>(<span class="string">"22.5"</span>);     <span class="comment">//22.5</span></span><br><span class="line"><span class="keyword">var</span> num5 = <span class="built_in">parseFloat</span>(<span class="string">"22.34.5"</span>);  <span class="comment">//22.34</span></span><br><span class="line"><span class="keyword">var</span> num6 = <span class="built_in">parseFloat</span>(<span class="string">"0908.5"</span>);   <span class="comment">//908.5</span></span><br><span class="line"><span class="keyword">var</span> num7 = <span class="built_in">parseFloat</span>(<span class="string">"3.125e7"</span>);  <span class="comment">//31250000</span></span><br></pre></td></tr></table></figure><hr><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>1、JavaScript的字符串类型用于表示文本数据。它是一组16位的无符号整数值的“元素”。<br>2、在字符串中的每个元素占据了字符串的位置。第一个元素的索引为0，下一个是索引1，依此类推。字符串的长度是它的元素的数量<br>3、与 C 语言不同，JavaScript 中字符串是不可变的（译注：如，JavaScript 中对字符串的操作一定返回了一个新字符串，原始字符串并没有被改变）<br>Javascript中一切都是object-based。</p><h3 id="创建string，也有两种类型"><a href="#创建string，也有两种类型" class="headerlink" title="创建string，也有两种类型"></a>创建string，也有两种类型</h3><ol><li>使用字面量方式创建的字符串，为基本类型的 string              <ul><li>实际上保存就是的值，是一个基本类型 </li></ul></li><li>使用String()创建的字符串，为基本类型的 string     </li><li>使用构造函数 new String()的方式创建的字符串，为对象类型的 string  <ul><li>实际上保存的是一个指向字符串对象的指针</li></ul></li></ol><h3 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h3><ul><li>第一种方法：toString() 返回相应值的字符串表现（null与undefined值没有这个方法）</li><li>第二种方法：在不知道转换的值是不是null或undefined情况下，可以用转型函数String()，能将任何类型的值转换为字符串。</li></ul><hr><h2 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h2><p>数据和功能的集合。是所有对象的基础，所有对象都具有Object的基本属性和方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>; <span class="comment">// 有效，但不推荐省略圆括号</span></span><br></pre></td></tr></table></figure><h3 id="①constructor属性"><a href="#①constructor属性" class="headerlink" title="①constructor属性"></a>①constructor属性</h3><p>构造函数属性,可确定当前对象的构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">console</span>.log(o.constructor == <span class="built_in">Object</span>);<span class="comment">//true</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="built_in">console</span>.log(arr.constructor == <span class="built_in">Array</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="②hasOwnProperty-propertyName"><a href="#②hasOwnProperty-propertyName" class="headerlink" title="②hasOwnProperty(propertyName)"></a>②hasOwnProperty(propertyName)</h3><p>判断属性是否存在于当前对象实例中（而不是在实例的原型中）。</p><h3 id="③isPrototypeOf-object"><a href="#③isPrototypeOf-object" class="headerlink" title="③isPrototypeOf(object)"></a>③isPrototypeOf(object)</h3><p>判断传入的对象是否是当前对象的原型</p><h3 id="④propertyIsEnumerable-propertyName"><a href="#④propertyIsEnumerable-propertyName" class="headerlink" title="④propertyIsEnumerable(propertyName)"></a>④propertyIsEnumerable(propertyName)</h3><p>判断给定的属性是否能使用for-in语句来枚举</p><h3 id="⑤toLocaleString"><a href="#⑤toLocaleString" class="headerlink" title="⑤toLocaleString()"></a>⑤toLocaleString()</h3><p>返回对象的字符串表示，该字符串与执行环境的地区对应</p><h3 id="⑥toString"><a href="#⑥toString" class="headerlink" title="⑥toString()"></a>⑥toString()</h3><p>返回对象的字符串表示</p><h3 id="⑦valueOf"><a href="#⑦valueOf" class="headerlink" title="⑦valueOf()"></a>⑦valueOf()</h3><p>返回对象的字符串、数值或布尔值表示</p><hr><h2 id="Symbol类型"><a href="#Symbol类型" class="headerlink" title="Symbol类型"></a>Symbol类型</h2><p>ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。 可以从根本上防止属性名的冲突。</p><p>Symbol值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">typeof</span> s            <span class="comment">// "symbol"</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量s就是一个独一无二的值。typeof运算符的结果，表明变量s是 Symbol 数据类型，而不是字符串之类的其他类型。</p><blockquote><p>注意， Symbol 函数前不能使用 new 命令，否则会报错。这是因为生成的  Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol  值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p></blockquote><p>Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);</span><br><span class="line">s1 <span class="comment">// Symbol(foo)</span></span><br><span class="line">s2 <span class="comment">// Symbol(bar)</span></span><br><span class="line">s1.toString() <span class="comment">// "Symbol(foo)"</span></span><br><span class="line">s2.toString() <span class="comment">// "Symbol(bar)"</span></span><br></pre></td></tr></table></figure><p>上面代码中，s1和s2是两个 Symbol 值。如果不加参数，它们在控制台的输出都是Symbol()，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。</p><blockquote><p>注意，Symbol 函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的 Symbol 函数的返回值是不相等的。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  没有参数的情况</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>();</span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  有参数的情况</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，s1和s2都是Symbol函数的返回值，而且参数相同，但是它们是不相等的。</p><p>由于每一个Symbol值都是不相等的，这意味着Symbol值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。Symbol值作为对象属性名时，不能用点运算符。在对象的内部，使用Symbol值定义属性时，Symbol值必须放在方括号之中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="comment">//  第一种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">'Hello!'</span>;</span><br><span class="line"><span class="comment">//  第二种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">[mySymbol]: <span class="string">'Hello!'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//  第三种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, mySymbol, &#123; <span class="attr">value</span>: <span class="string">'Hello!'</span> &#125;);</span><br><span class="line"><span class="comment">//  以上写法都得到同样结果</span></span><br><span class="line">a[mySymbol] <span class="comment">// "Hello!"</span></span><br></pre></td></tr></table></figure><p><strong>Symbol 值不能与其他类型的值进行运算，会报错。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym = <span class="built_in">Symbol</span>(<span class="string">'My symbol'</span>);</span><br><span class="line"><span class="string">"your symbol is "</span> + sym</span><br><span class="line"><span class="comment">// TypeError: can't convert symbol to string</span></span><br><span class="line"><span class="string">`your symbol is <span class="subst">$&#123;sym&#125;</span>`</span></span><br><span class="line"><span class="comment">// TypeError: can't convert symbol to string</span></span><br></pre></td></tr></table></figure><p>但是， Symbol 值可以显式转为字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym = <span class="built_in">Symbol</span>(<span class="string">'My symbol'</span>);</span><br><span class="line"><span class="built_in">String</span>(sym) <span class="comment">// 'Symbol(My symbol)'</span></span><br><span class="line">sym.toString() <span class="comment">// 'Symbol(My symbol)'</span></span><br></pre></td></tr></table></figure><h3 id="Symbol-for-，-Symbol-keyFor"><a href="#Symbol-for-，-Symbol-keyFor" class="headerlink" title="Symbol.for() ， Symbol.keyFor()"></a>Symbol.for() ， Symbol.keyFor()</h3><p>有时，我们希望重新使用同一个 Symbol 值，Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line">s1 === s2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中， s1 和 s2 都是 Symbol 值，但是它们都是同样参数的Symbol.for方法生成的，所以实际上是同一个值。</p><p>Symbol.for()与Symbol()这两种写法，都会生成新的 Symbol 。<br><strong>区别：</strong><br>前者会被登记在全局环境中供搜索，后者不会。</p><ul><li>Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的 key 是否已经存在，如果不存在才会新建一个值。<blockquote><p>比如，如果你调用Symbol.for(“cat”) 30次，每次都会返回同一个 Symbol 值，但是调用Symbol(“cat”) 30 次，会返回 30 个不同的 Symbol 值。</p></blockquote></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>.for(<span class="string">"bar"</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>(<span class="string">"bar"</span>)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，由于Symbol()写法没有登记机制，所以每次调用都会返回一个不同的值。</p><ul><li>Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key 。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1) <span class="comment">// "foo"</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量s2属于未登记的 Symbol 值，所以返回undefined。</p><blockquote><p>需要注意的是，Symbol.for为 Symbol 值登记的名字，是全局环境的，可以在不同的 iframe 或 service worker中取到同一个值。</p></blockquote>]]></content>
      
      <categories>
          
          <category> LearnES5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
  
  
    
  
</search>
